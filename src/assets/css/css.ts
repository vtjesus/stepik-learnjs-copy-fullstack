import { BookPart, BookTypeWork } from '@/types/Book';

export const css: BookPart[] = [
	{
		book: 'CSS',
		title: 'Научитесь стилизовать HTML с помощью CSS',
		
		content:
			'<header><h1>Научитесь стилизовать HTML с помощью CSS</h1></header><div class="section-content"><p>Каскадные таблицы стилей — или <a>CSS</a> — это технология, которую следует изучать непосредственно после HTML. В отличие от HTML, который служит для определения структуры и семантики содержимого, CSS отвечает за его внешний вид и отображение. К примеру, с помощью CSS можно изменять шрифт, цвет, размер, межстрочный интервал, разделять содержимое на колонки, а также добавлять анимацию и другие декоративные элементы.</p>\n<div class="callout" id="sect1">\n  <h4 id="хотите_стать_frontend-разработчиком">Хотите стать frontend-разработчиком?</h4>\n  <p>Мы составили курс, который содержит всю необходимую информацию для достижения этой цели.</p>\n  <p><a><strong>Начать изучение курса</strong></a></p>\n</div></div><section aria-labelledby="необходимые_условия"><h2 id="необходимые_условия"><a>Необходимые условия</a></h2><div class="section-content"><p>Прежде чем браться за CSS, вам стоит разобраться с основами HTML. Мы рекомендуем сначала изучить модуль <a>Введение в HTML</a></p>\n<p>После того как вы разберётесь с основами HTML, мы рекомендуем продолжать изучение HTML и CSS одновременно, переключаясь между темами. HTML гораздо интереснее в сочетании с CSS, и вы не можете по настоящему изучить CSS не зная HTML</p>\n<p>В данном разделе содержится информация, которая требует базового знакомства с компьютером и интернетом. В статье <a>Установка рабочего пространства</a> подробно описано необходимое ПО и способы его установки, необходимо также будет уметь создавать и управлять файлами, в чём поможет статья <a>Работа с файлами</a>, которая включена в полное руководство для новичка <a>Основы веб</a>.</p>\n<p>Перед тем как начинать данный раздел, мы рекомендуем пройти руководство <a>Основы веб</a>, хотя это вовсе не обязательно — большая часть того, что вы найдёте в статье об основах CSS также встречается в разделе <a>Введение в CSS</a>, хотя и более детально.</p></div></section><section aria-labelledby="модули"><h2 id="модули"><a>Модули</a></h2><div class="section-content"><p>Этот раздел содержит модули в порядке, наиболее подходящем для работы с ними. Лучше всего начать с самого первого.</p>\n<dl>\n  <dt id="введение_в_css"><a>Введение в CSS</a></dt>\n  <dd>\n    <p>CSS (каскадные таблицы стилей) используется для стилизации и компоновки веб-страниц — например, для изменения шрифта, цвета, размера и интервала содержимого, разделения его на несколько столбцов или добавления анимации и других декоративных элементов. Этот модуль обеспечивает хорошее начало вашего пути к освоению CSS с основами того, как он работает, как выглядит синтаксис и как вы можете начать использовать его для добавления стилей в HTML.</p>\n  </dd>\n  <dt id="устройство_css"><a>Устройство CSS</a></dt>\n  <dd>\n    <p>Этот модуль продолжается с того места, где закончился модуль <a>введение в CSS</a> — теперь, после того как вы познакомились с языком и получили опыт его использования, пришло время погрузится немного глубже. В этот модуле рассказывается про каскад и наследование, все доступные типы селекторов, единицы измерения, размеры, стилизацию фона и рамок, отладку, и многое другое.</p>\n    <p>Цель этого модуля — предоставить вам инструментарий для написания компетентного CSS, перед переходом к более специфичным дисциплинам, как <a>стилизация текста</a> и <a>CSS раскладки</a>.</p>\n  </dd>\n  <dt id="стилизация_текста"><a>Стилизация текста</a></dt>\n  <dd>\n    <p>После изучения основ, следующая тема, которую стоит изучить — стилизация текста. Это одна из самых распространенных вещей, для которых используется CSS. В этом модуле мы рассмотрим основы стилизации текста, включая установку шрифта, жирность, курсив, межстрочный и межбуквенный интервалы, тени и другие особенности оформления. В завершении модуля мы рассмотрим подключение пользовательских шрифтов на странице, а так же стилизацию списков и ссылок</p>\n  </dd>\n  <dt id="css_раскладки"><a>CSS раскладки</a></dt>\n  <dd>\n    <p>К текущему моменту мы познакомились с основами CSS. Мы знаем, как оформлять текст, как оформлять и изменять блоки, в которых находится ваш контент. Пришло время узнать, как разместить ваши блоки в нужных местах в зависимости от области просмотра и тому подобного. Мы уже знаем достаточно, чтобы погрузиться в изучение раскладки с помощью CSS, в то, как изменять отображение в зависимости от особенностей экрана, как использовать современные методы раскладки, такие как Flexbox и CSS grid, и некоторые традиционные методы раскладки, которые все ещё применяются.</p>\n  </dd>\n</dl></div></section><section aria-labelledby="решаем_часто_встречающиеся_проблемы_в_css"><h2 id="решаем_часто_встречающиеся_проблемы_в_css"><a>Решаем часто встречающиеся проблемы в CSS</a></h2><div class="section-content"><p>В разделе <strong><a>Использование CSS для решения общих проблем</a></strong> даны ссылки на разделы, объясняющие, как следует использовать CSS для решения самых распространённых проблем при создании веб-страницы.</p>\n<p>В самом начале вы будете применять цвет к тексту и фону HTML-элементов, изменять их размер, форму, местоположение, добавлять и стилизовать границы. Однако с углублённым знанием даже основ CSS вы сможете сделать практически что угодно. Одним из плюсов изучения CSS является то, что вы быстро начнёте понимать, можно или нельзя что-то сделать средствами CSS, даже если вы ещё не уверены, как это сделать.</p></div></section><section aria-labelledby="css_странный"><h2 id="css_странный"><a>"CSS странный"</a></h2><div class="section-content"><p>CSS иначе, чем большинство языков программирования и инструментов для дизайна, с которыми вы можете столкнуться. Почему это работает именно так? В следующем видео, Мириам Сюзанна дает объяснение того, почему CSS работает так, как он работает, и почему он так развивался:</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Основы CSS',
		
		content:
			'<header><h1>Основы CSS</h1></header><div class="section-content">\n<p>CSS (Cascading Style Sheets) — это код, который вы используете для стилизации вашей веб-страницы. <em>Основы CSS</em> помогут вам понять, что вам нужно для начала работы. Мы ответим на такие вопросы как: Как сделать мой текст черным или красным? Как сделать так, чтобы контент появлялся в определённом месте на экране? Как украсить мою веб-страницу с помощью фоновых изображений и цветов?</p></div><section aria-labelledby="так_что_же_такое_css"><h2 id="так_что_же_такое_css"><a>Так что же такое CSS?</a></h2><div class="section-content"><p>Как и HTML, CSS на самом деле не является языком программирования. Это не язык разметки - это <em>язык таблицы стилей.</em> Это означает, что он позволяет применять стили выборочно к элементам в документах HTML. Например, чтобы выбрать <strong>все</strong> элементы абзаца на HTML странице и изменить текст внутри них с чёрного на красный, вы должны написать этот CSS:</p>\n<pre compile="false" disable="true" language="markup">p {\n  color: red;\n}\n</pre>\n<p>Давайте попробуем: вставьте эти три строки CSS в новый файл в ваш текстовый редактор, а затем сохраните файл как <code>style.css</code> в вашей папке <code>styles</code>.</p>\n<p>Но нам всё равно нужно применить CSS к нашему HTML документу. В противном случае, CSS стиль не повлияет на то, как ваш браузер отобразит HTML документ. (Если вы не следили за нашим проектом, то прочитайте раздел <a>Работа с файлами</a> и <a>Основы HTML</a>, чтобы узнать, что вам нужно сделать в первую очередь.)</p>\n<ol>\n  <li>Откройте ваш файл <code>index.html</code> и вставьте следующую строку куда-нибудь в шапку, между <code>&lt;head&gt;</code> и <code>&lt;/head&gt;</code> тегами:\n    <div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><link href="styles/style.css" rel="stylesheet" type="text/css">\n</pre></div>\n  </li>\n  <li>Сохраните <code>index.html</code> и загрузите его в вашем браузере. Вы должны увидеть что-то вроде этого:</li>\n</ol>\n<p>\n  Если текст вашего абзаца теперь красный, примите наши поздравления! Вы написали свой первый успешный CSS!\n</p></div></section><section aria-labelledby="анатомия_набора_правил_css"><h3 id="анатомия_набора_правил_css"><a>Анатомия набора правил CSS</a></h3><div class="section-content"><p>Давайте взглянем на вышеупомянутый CSS немного более подробно:</p>\n<p>\n  \n</p>\n<p>Вся структура называется <strong>набором правил</strong> (но зачастую для краткости "правило"). Отметим также имена отдельных частей:</p>\n<dl>\n  <dt id="селектор_selector"><a>Селектор (Selector)</a></dt>\n  <dd>\n    <p>Имя HTML-элемента в начале набора правил. Он выбирает элемент(ы) для применения стиля (в данном случае, элементы <code>p</code> ). Для стилизации другого элемента, просто измените селектор.</p>\n  </dd>\n  <dt id="объявление_declaration"><a>Объявление (Declaration)</a></dt>\n  <dd>\n    <p>Единственное правило, например <code>color: red;</code> указывает, какие из <strong>свойств</strong> элемента вы хотите стилизовать.</p>\n  </dd>\n  <dt id="свойства_properties"><a>Свойства (Properties)</a></dt>\n  <dd>\n    <p>Способы, которыми вы можете стилизовать определённый HTML-элемент (в данном случае, <code>color</code> является свойством для элементов <a><code>&lt;p&gt;</code></a>). В CSS вы выбираете, какие свойства вы хотите затронуть в вашем правиле.</p>\n  </dd>\n  <dt id="значение_свойства_property_value"><a>Значение свойства (Property value)</a></dt>\n  <dd>\n    <p>Справа от свойства, после двоеточия, у нас есть <strong>значение свойства</strong>, которое выбирает одно из множества возможных признаков для данного свойства (существует множество значений <code>color</code>, помимо <code>red</code>).</p>\n  </dd>\n</dl>\n<p>Обратите внимание на важные части синтаксиса:</p>\n<ul>\n  <li>Каждый набор правил (кроме селектора) должен быть обёрнут в фигурные скобки (<code>{}</code>).</li>\n  <li>В каждом объявлении необходимо использовать двоеточие (<code>:</code>), чтобы отделить свойство от его значений.</li>\n  <li>В каждом наборе правил вы должны использовать точку с запятой (<code>;</code>), чтобы отделить каждое объявление от следующего.</li>\n</ul>\n<p>Таким образом, чтобы изменить несколько значений свойств сразу, вам просто нужно написать их, разделяя точкой с запятой, например так:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">p {\n  color: red;\n  width: 500px;\n  border: 1px solid black;\n}\n</pre></div></div></section><section aria-labelledby="выбор_нескольких_элементов"><h3 id="выбор_нескольких_элементов"><a>Выбор нескольких элементов</a></h3><div class="section-content"><p>Вы также можете выбрать несколько элементов разного типа и применить единый набор правил для всех из них. Добавьте несколько селекторов, разделённых запятыми. Например:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">p,\nli,\nh1 {\n  color: red;\n}\n</pre></div></div></section><section aria-labelledby="разные_типы_селекторов"><h3 id="разные_типы_селекторов"><a>Разные типы селекторов</a></h3><div class="section-content"><p>Существует множество различных типов селектора. Выше мы рассматривали только <strong>селектор элементов</strong>, который выбирает все элементы определённого типа в HTML документе. Но мы можем сделать выбор более конкретным. Вот некоторые из наиболее распространённых типов селекторов:</p>\n\n<p>Существует ещё много селекторов для изучения, и вы можете найти более подробный список в нашем <a class="only-in-en-us" title="Currently only available in English (US)">Руководстве селекторов <small>(en-US)<small></small></small></a>.</p></div></section><section aria-labelledby="шрифты_и_текст"><h2 id="шрифты_и_текст"><a>Шрифты и текст</a></h2><div class="section-content"><p>Теперь, когда мы изучили некоторые основы CSS, давайте добавим ещё несколько правил и информацию в наш файл <code>style.css</code>, чтобы наш пример хорошо выглядел. Прежде всего, давайте сделаем, чтобы наши шрифты и текст выглядели немного лучше.</p>\n<ol>\n  <li>Прежде всего, вернитесь и найдите <a>вывод из Google Fonts</a>, который вы уже где-то сохранили. Добавьте элемент <a><code>&lt;link&gt;</code></a> где-нибудь внутри шапки вашего <code>index.html</code> (снова, в любом месте между тегами <code>&lt;head&gt;</code> и <code>&lt;/head&gt;</code>). Это будет выглядеть примерно так:\n    <div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><link href="http://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">\n</pre></div>Этот код связывает вашу страницу с таблицой стилями, которая загружает семейство шрифтов Open Sans вместе с вашей страницей и позволяет вам применять их к вашим HTML-элементам используя свою собственную таблицу стилей.\n  </li>\n  <li>Затем, удалите существующее правило в вашем <code>style.css</code> файле. Это был хороший тест, но красный текст, на самом деле, не очень хорошо выглядит.</li>\n  <li>Добавьте следующие строки в нужное место, заменив строку <code>placeholder</code> актуальной <code>font-family</code> строкой, которую вы получили из Google Fonts. (<code>font-family</code> просто означает, какой шрифт(ы) вы хотите использовать для вашего текста). Это правило устанавливает глобальный базовый шрифт и размер шрифта для всей страницы (поскольку <code>&lt;html&gt;</code> является родительским элементом для всей страницы, и все элементы внутри него наследуют такой же <code>font-size</code> и <code>font-family</code>):\n    <div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">html {\n  font-size: 10px; /* px значит \'пиксели\': базовый шрифт будет 10 пикселей в высоту  */\n  font-family: placeholder: здесь должно быть имя шрифта из Google fonts\n}\n</pre></div>\n    <div class="notecard note" id="sect1">\n      <p><strong>Примечание:</strong> Все в CSS документе между <code>/*</code> и <code>*/</code> является <strong>CSS комментарием</strong>, который браузер игнорирует при исполнении кода. Это место, где вы можете написать полезные заметки о том, что вы делаете.</p>\n    </div>\n  </li>\n  <li>Теперь мы установим размер шрифта для элементов, содержащих текст внутри HTML тела (<a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;h1&gt;</code> <small>(en-US)</small></a>, <a><code>&lt;li&gt;</code></a>, и <a><code>&lt;p&gt;</code></a>). Мы также отцентрируем текст нашего заголовка и установим некоторую высоту строки и расстояние между буквами в теле документа, чтобы сделать его немного более удобным для чтения:\n    <div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">h1 {\n  font-size: 60px;\n  text-align: center;\n}\n\np,\nli {\n  font-size: 16px;\n  line-height: 2;\n  letter-spacing: 1px;\n}\n</pre></div>\n  </li>\n</ol>\n<p>Вы можете настроить значения <code>px</code> так, как вам нравится, чтобы ваш дизайн выглядел так, как вы хотите, но, в общем, ваш дизайн должен выглядеть вот так:</p>\n<p>\n  \n</p></div></section><section aria-labelledby="блоки_блоки_и_ещё_раз_блоки"><h2 id="блоки_блоки_и_ещё_раз_блоки"><a>Блоки, блоки и ещё раз блоки</a></h2><div class="section-content"><p>Одна вещь, которую вы заметите в написании CSS, заключается в том, что многое из этого касается блоков - настройка их размера, цвета, положения и т.д. Большинство HTML-элементов на странице можно рассматривать как блоки, расположенные друг над другом.</p>\n<p>\n  \n</p>\n<p>Не удивительно, макет CSS основан, главным образом, на <em>блочной модели (box model)</em>. Каждый из блоков, занимающий пространство на вашей странице имеет такие свойства, как:</p>\n<ul>\n  <li><code>padding</code>, пространство только вокруг контента (например, вокруг абзаца текста)</li>\n  <li><code>border</code>, сплошная линия, которая расположена рядом с padding</li>\n  <li><code>margin</code>, пространство вокруг внешней стороны элемента</li>\n</ul>\n<p>\n  \n</p>\n<p>В этом разделе мы также используем:</p>\n<ul>\n  <li><code>width</code> (ширину элемента)</li>\n  <li><code>background-color</code>, цвет позади контента и padding элементов</li>\n  <li><code>color</code>, цвет контента элемента (обычно текста)</li>\n  <li><code>text-shadow</code>: устанавливает тень на тексте внутри элемента</li>\n  <li><code>display</code>: устанавливает режим отображения элемента (пока что не волнуйтесь об этом)</li>\n</ul>\n<p>Итак, давайте начнём и добавим больше CSS на нашей странице! Продолжайте добавлять эти новые правила, расположенные в нижней части страницы, и не бойтесь экспериментировать с изменением значений, чтобы увидеть, как это работает.</p></div></section><section aria-labelledby="изменение_цвета_страницы"><h3 id="изменение_цвета_страницы"><a>Изменение цвета страницы</a></h3><div class="section-content"><div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">html {\n  background-color: #00539f;\n}\n</pre></div>\n<p>Это правило устанавливает цвет фона для всей страницы. Измените код цвета сверху, на цвет который <a>вы выбрали при планировании вашего сайта</a>.</p></div></section><section aria-labelledby="разбираемся_с_телом"><h3 id="разбираемся_с_телом"><a>Разбираемся с телом</a></h3><div class="section-content"><div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">body {\n  width: 600px;\n  margin: 0 auto;\n  background-color: #ff9500;\n  padding: 0 20px 20px 20px;\n  border: 5px solid black;\n}\n</pre></div>\n<p>Теперь для <a><code>&lt;body&gt;</code></a> элемента. Здесь есть немало деклараций, так что давайте пройдём через них всех по одному:</p>\n<ul>\n  <li><code>width: 600px;</code> — заставляет тело быть всегда 600 пикселей в ширину.</li>\n  <li><code>margin: 0 auto;</code> — когда вы устанавливаете два значения для таких свойств как <code>margin</code> или <code>padding</code>, первое значение элемента влияет на верхнюю <strong>и</strong> нижнюю сторону (делает их <code>0</code> в данном случае), и второе значение на левую <strong>и</strong> правую сторону (здесь, <code>auto</code> является особым значением, которое делит доступное пространство по горизонтали поровну слева и справа). Вы также можете использовать один, три или четыре значения, как описано <a>здесь</a>.</li>\n  <li><code>background-color: #FF9500;</code> — как и прежде, устанавливает цвет фона элемента. Я использовал красновато-оранжевый для тела, в отличие от темно-синего цвета для <a><code>&lt;html&gt;</code></a> элемента, но не стесняйтесь и экспериментируйте.</li>\n  <li><code>padding: 0 20px 20px 20px;</code> — у нас есть четыре значения, установленные для padding, чтобы сделать немного пространства вокруг нашего контента. В этот раз мы не устанавливаем padding на верхней части тела, но делаем 20 пикселей слева, снизу и справа. Значения устанавливаются сверху, справа, снизу, слева, в таком порядке.</li>\n  <li><code>border: 5px solid black;</code> — просто устанавливает сплошную чёрную рамку шириной 5 пикселей со всех сторон тела.</li>\n</ul></div></section><section aria-labelledby="позиционирование_и_стилизация_нашего_заголовка_главной_страницы"><h3 id="позиционирование_и_стилизация_нашего_заголовка_главной_страницы"><a>Позиционирование и стилизация нашего заголовка главной страницы</a></h3><div class="section-content"><div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">h1 {\n  margin: 0;\n  padding: 20px 0;\n  color: #00539f;\n  text-shadow: 3px 3px 1px black;\n}\n</pre></div>\n<p>Вы, возможно, заметили, что есть ужасный разрыв в верхней части тела. Это происходит, потому что браузеры применяют некоторый <strong>стиль по умолчанию</strong> для элемента <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;h1&gt;</code> <small>(en-US)</small></a> (по сравнению с другими), даже если вы не применяли какой-либо CSS вообще! Это может звучать как плохая идея, но мы хотим, чтобы веб-страница без стилей имела базовую читаемость. Чтобы избавиться от разрыва, мы переопределили стиль по умолчанию, установив <code>margin: 0;</code>.</p>\n<p>Затем мы установили заголовку верхний и нижний padding на 20 пикселей, и сделали текст заголовка того же цвета, как и цвет фона html.</p>\n<p>Здесь, мы использовали одно довольно интересное свойство - это <code>text-shadow</code>, которое применяет тень к текстовому контенту элемента. Оно имеет следующие четыре значения:</p>\n<ul>\n  <li>Первое значение пикселей задаёт <strong>горизонтальное смещение</strong> тени от текста — как далеко она движется поперёк: отрицательное значение должно двигать её влево.</li>\n  <li>Второе значение пикселей задаёт <strong>вертикальное смещение</strong> тени от текста — как далеко она движется вниз, в этом примере: отрицательное значение должно переместить её вверх.</li>\n  <li>Третье значение пикселей задаёт <strong>радиус размытия</strong> тени — большее значение будет означать более размытую тень.</li>\n  <li>Четвёртое значение задаёт основной цвет тени.</li>\n</ul>\n<p>И вновь попробуйте поэкспериментировать с различными значениями, чтобы посмотреть, что вы можете придумать.</p></div></section><section aria-labelledby="центрирование_изображения"><h3 id="центрирование_изображения"><a>Центрирование изображения</a></h3><div class="section-content"><div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">img {\n  display: block;\n  margin: 0 auto;\n}\n</pre></div>\n<p>В заключение, мы отцентрируем изображение, чтобы оно лучше выглядело. Мы можем использовать <code>margin: 0 auto</code> уловку снова, как мы это делали раньше для body, но мы также должны сделать кое-что ещё. Элемент <a><code>&lt;body&gt;</code></a> является <strong>блочным</strong>, это значит, что он занимает всю ширину страницы и может иметь margin и другие значения отступов, применяемых к нему. Изображения, наоборот, являются <strong>строчными</strong> элементами, то есть они этого не могут. Таким образом, чтобы применить margin к изображению, мы должны дать изображению блочное поведение с помощью <code>display: block;</code>.</p>\n<div class="notecard note" id="sect2">\n  <p><strong>Примечание:</strong> Приведённые выше инструкции предполагают, что вы используете изображение меньшей ширины, чем заданная для <a><code>&lt;body&gt;</code></a> (600px). Если ваше изображение больше, тогда оно выйдет за границы <a><code>&lt;body&gt;</code></a> и займёт пространство страницы. Чтобы исправить это, вы можете: 1) уменьши ширину изображения используя <a class="external" target="_blank">графический редактор</a>, или 2) изменить размер изображения используя CSS путём установки свойства <a><code>width</code></a> для <code>&lt;img&gt;</code> меньше, чем у <a><code>&lt;body&gt;</code></a>.</p>\n</div>\n<div class="notecard note" id="sect3">\n  <p><strong>Примечание:</strong> Не стоит беспокоиться, если вы ещё не понимаете <code>display: block;</code> и различия между блочным/строчным. Вы поймёте, когда будете изучать CSS более подробно. Вы можете узнать больше о различных доступных значениях display на нашей странице о свойстве <a>display</a>.</p>\n</div></div></section><section aria-labelledby="заключение"><h2 id="заключение"><a>Заключение</a></h2><div class="section-content"><p>Если вы следовали всем инструкциям в этой статье, вы должны получить страницу, которая выглядит примерно так (вы также можете <a class="external" target="_blank">посмотреть нашу версию здесь</a>):</p>\n<p>\n  \n</p>\n<p>Если вы застряли, вы всегда можете сравнить свою работу с нашим <a class="external" target="_blank">готовым примером кода на Github</a>.</p>\n<p>Здесь мы узнали только самую поверхность CSS. Чтобы узнать больше, перейдите на нашу <a>страницу изучения CSS</a>.</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Введение в CSS',
		
		content:
			'<header><h1>Введение в CSS</h1></header><div class="section-content"><p>CSS (каскадные таблицы стилей) используется для стилизации и компоновки веб-страниц - например, для изменения шрифта, цвета, размера и интервала содержимого, разделения его на несколько столбцов или добавления анимации и других декоративных элементов. Этот модуль обеспечивает хорошее начало вашего пути к освоению CSS с основами того, как он работает, как выглядит синтаксис и как вы можете начать использовать его для добавления стилей в HTML.</p></div><section aria-labelledby="необходимые_условия"><h2 id="необходимые_условия"><a>Необходимые условия</a></h2><div class="section-content"><p>Перед запуском этого модуля вы должны иметь:</p>\n<ol>\n  <li>Базовое знакомство с использованием компьютеров и пассивным использованием Интернета (то есть, просматривая его, потребляя контент).</li>\n  <li>Базовая рабочая среда, описанная в разделе <a>Установка базового программного обеспечения</a>, и понимание того, как создавать файлы и управлять ими, подробно описано в разделе <a>Работа с файлами</a>.</li>\n  <li>Основное знакомство с HTML, как описано в модуле <a>Введение в HTML</a>.</li>\n</ol>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> Если вы работаете на компьютере / планшете / другом устройстве, на котором у вас нет возможности создавать свои собственные файлы, вы можете опробовать (большую часть) примеры кода в онлайн-программах кодирования, таких как JSBin или Thimble.</p>\n</div></div></section><section aria-labelledby="руководства"><h2 id="руководства"><a>Руководства</a></h2><div class="section-content"><p>Этот модуль содержит следующие статьи, в которых вы ознакомитесь со всеми основными теориями CSS и сможете проверить некоторые навыки.</p>\n<dl>\n  <dt id="что_такое_css"><a>Что такое CSS?</a></dt>\n  <dd>\n    <p><strong><a>CSS</a></strong> (Каскадные таблицы стилей) позволяет создавать великолепно выглядящие веб-страницы, но как же это работает? Эта статья объясняет, что такое CSS с помощью простого примера синтаксиса, а также охватывает некоторые ключевые термины о языке.</p>\n  </dd>\n  <dt id="начало_работы_с_css"><a>Начало работы с CSS</a></dt>\n  <dd>\n    <p>В этой статье мы возьмём простой HTML-документ и применим к нему CSS, изучая некоторые практические вещи о языке.</p>\n  </dd>\n  <dt id="как_структурирован_css"><a>Как структурирован CSS</a></dt>\n  <dd>\n    <p>Теперь, когда у вас есть представление о том, что такое CSS и как его использовать, пришло время немного углубиться в структуру самого языка. Мы уже встречали множество концепций, обсуждаемых здесь; вы можете вернуться к этому, чтобы повторить, если вы находите какие-либо более поздние концепции запутанными.</p>\n  </dd>\n  <dt id="как_работает_css"><a>Как работает CSS</a></dt>\n  <dd>\n    <p>Мы изучили основы CSS — для чего он нужен и как писать простые таблицы стилей. В этом уроке мы рассмотрим, как браузер берёт CSS и HTML и превращает их в веб-страницу.</p>\n  </dd>\n  <dt id="использование_ваших_новых_знаний"><a>Использование ваших новых знаний</a></dt>\n  <dd>\n    <p>С учётом того, что вы узнали за последние несколько уроков, вы должны обнаружить, что вы можете форматировать простые текстовые документы с использованием CSS, чтобы добавить к ним свой собственный стиль. Эта статья даёт вам шанс сделать это.</p>\n  </dd>\n</dl></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Что такое CSS',
		
		content:
			'<header><h1>Что такое CSS?</h1></header><div class="section-content">\n<p><strong><a>CSS</a></strong> (Каскадные таблицы стилей) позволяет создавать великолепно выглядящие веб-страницы, но как же это работает? Эта статья объясняет, что такое CSS, с помощью простого примера синтаксиса, а также охватывает некоторые ключевые термины о языке.</p>\n\n<p>В модуле <a>Основы HTML</a> мы рассмотрели, что такое HTML и как он используется для разметки документов. Эти документы будут доступны для чтения в веб-браузере. Заголовки будут выглядеть больше, чем обычный текст, абзацы разбиваются на новую строку и будут иметь пространство между друг другом. Ссылки выделены цветом и подчёркнуты, чтобы отличить их от остального текста. То, что вы видите, — это стили браузера по умолчанию — самые основные стили, которые браузер применяет к HTML, чтобы гарантировать, что он будет в основном читабельным, даже если автор страницы не указал явный стиль.</p>\n<p>\n  \n</p>\n<p>Тем не менее, интернет был бы скучным, если бы все сайты выглядели так. Используя CSS, вы можете до мелочей контролировать, как элементы HTML выглядят в браузере, представляя вашу разметку, используя любой понравившийся вам дизайн.</p></div><section aria-labelledby="для_чего_нужен_css"><h2 id="для_чего_нужен_css"><a>Для чего нужен CSS?</a></h2><div class="section-content"><p>Как мы уже упоминали ранее, CSS — это язык для определения того, как документы представляются пользователям — как они оформляются, размещаются и т. д.</p>\n<p><strong>Документ</strong> обычно представляет собой текстовый файл, структурированный с использованием языка разметки: <a>HTML</a> — самый распространённый язык разметки, но вы также можете встретить другие языки разметки, такие как <a>SVG</a> или <a>XML</a>.</p>\n<p><strong>Представление</strong> документа пользователю означает преобразование его в форму, используемую вашей аудиторией**.** <a>Browsers</a>, такие как <a class="only-in-en-us" title="Currently only available in English (US)">Firefox <small>(en-US)</small></a>, <a class="only-in-en-us" title="Currently only available in English (US)">Chrome <small>(en-US)</small></a> или <a class="only-in-en-us" title="Currently only available in English (US)">Edge <small>(en-US)</small></a> , предназначены для визуального представления документов, например, на экране компьютера, проектора или принтера.</p>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> Браузер иногда называют <a>user agent</a>, что в основном означает компьютерную программу, которая представляет человека внутри компьютерной системы. Браузеры — это основной тип пользовательского агента, о котором мы думаем, когда говорим о CSS, но он не единственный. Доступны и другие пользовательские агенты, например, те, которые преобразуют документы HTML и CSS в файлы PDF для печати.</p>\n</div>\n<p>CSS может использоваться для очень простой стилизации текста документа, например, изменение <a>цвета</a> и <a>размера</a> заголовков и ссылок. Он может быть использован для создания макета, например, <a class="only-in-en-us" title="Currently only available in English (US)">превращение одного столбца текста в макет <small>(en-US)<small></small></small></a> с основной областью контента и боковой панелью для соответствующей информации. Это может даже использоваться для эффектов, таких как <a>анимация</a>. Посмотрите на ссылки в этом параграфе для конкретных примеров.</p></div></section><section aria-labelledby="синтаксис_css"><h2 id="синтаксис_css"><a>Синтаксис CSS</a></h2><div class="section-content"><p>CSS — это язык на основе правил: вы задаёте правила, определяющие группы стилей, которые должны применяться к определённым элементам или группам элементов на вашей веб-странице. Например:</p>\n<p>«Я хочу, чтобы основной заголовок на моей странице отображался крупным красным текстом».</p>\n<p>В следующем коде показано очень простое правило CSS, которое будет соответствовать стилю, описанному выше:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">h1 {\n  color: red;\n  font-size: 5em;\n}\n</pre></div>\n<p>Правило открывается с помощью <a>селектора</a> . Этот селектор выбирает HTML-элемент, который мы собираемся стилизовать. В этом случае мы используем заголовки первого уровня — (<a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;h1&gt;</code> <small>(en-US)</small></a>).</p>\n<p>Затем у нас есть набор фигурных скобок <code>{ }</code>. Внутри них будет один или несколько <strong>объявлений</strong>, которые принимают форму пары <strong>свойства</strong> и его <strong>значения</strong>. Каждая пара указывает свойство элемента(-ов), который(-е) мы выбираем, а затем значение, которое мы хотели бы присвоить свойству.</p>\n<p>Перед двоеточием у нас есть свойство, а после двоеточия — значение. CSS-<a class="only-in-en-us" title="Currently only available in English (US)">свойства <small>(en-US)</small></a> имеют разные допустимые значения в зависимости от того, какое свойство указывается. В нашем примере мы имеем свойство <code>color</code>, которое может принимать различные <a>цветовые значения</a>. У нас также есть свойство <code>font-size</code>. Это свойство может принимать различные <a>значения размера</a>, как и свойства.</p>\n<p>Таблица стилей CSS будет содержать много таких правил, написанных одно за другим.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">h1 {\n  color: red;\n  font-size: 5em;\n}\n\np {\n  color: black;\n}\n</pre></div>\n<p>Вы обнаружите, что вы быстро изучаете некоторые значения, тогда как другие вам нужно искать. Страницы отдельных свойств в MDN дают вам быстрый способ поиска свойств и их значений, когда вы забыли или хотите узнать, что ещё вы можете использовать в качестве значения.</p>\n<div class="notecard note" id="sect2">\n  <p><strong>Примечание:</strong> вы можете найти ссылки на все страницы свойств CSS (вместе с другими функциями CSS), перечисленные в MDN <a>Руководстве по CSS</a>. Кроме того, вы должны привыкнуть к поиску "MDN <em>css-feature-name</em>" в вашем браузере, когда вам нужно узнать больше информации о функции CSS. Например, попробуйте поискать «mdn color» и «mdn font-size»!</p>\n</div></div></section><section aria-labelledby="css-модули"><h2 id="css-модули"><a>CSS-модули</a></h2><div class="section-content"><p>Поскольку существует множество вещей, которые можно стилизовать с помощью CSS, язык разбит на модули. По мере изучения MDN вы увидите ссылки на эти модули, а многие страницы документации организованы вокруг определённого модуля. Например, вы можете взглянуть на ссылку MDN в модуле <a class="only-in-en-us" title="Currently only available in English (US)">Свойства фона и границ <small>(en-US)<small></small></small></a>, чтобы узнать, какова его цель и какие различные свойства и другие функции он содержит. Вы также найдёте ссылки на спецификацию CSS, которая определяет технологию (см. ниже).</p>\n<p>На этом этапе вам не нужно слишком беспокоиться о том, как структурирован CSS, однако это может упростить поиск информации, если, например, вы знаете, что определённое свойство может быть найдено среди других похожих вещей, и поэтому, вероятно, в той же спецификации.</p>\n<p>Для конкретного примера давайте вернёмся к модулю Свойства фона и границ — вы можете подумать, что это логично для свойств <a><code>background-color</code></a> и <a class="only-in-en-us" title="Currently only available in English (US)"><code>border-color</code> <small>(en-US)<small></small></small></a>, которые будут определены в этом модуле. И Вы правы.</p></div></section><section aria-labelledby="технические_характеристики_css"><h3 id="технические_характеристики_css"><a>Технические характеристики CSS</a></h3><div class="section-content"><p>Все технологии веб-стандартов (HTML, CSS, JavaScript и т. д.) определены в гигантских документах, называемых спецификациями, которые публикуются организациями по стандартизации (такие как <a>W3C</a>, <a>WHATWG</a>, <a>ECMA</a> или <a class="only-in-en-us" title="Currently only available in English (US)">Khronos <small>(en-US)</small></a>) и определяют, как эти технологии должны вести себя.</p>\n<p>CSS ничем не отличается — он разработан группой в W3C, которая называется <a class="external" target="_blank">CSS Working Group</a>. Эта группа состоит из представителей производителей браузеров и других компаний, которые заинтересованы в CSS. Есть также другие люди, известные как приглашённые эксперты, которые выступают как независимые голоса; они не связаны с членами организации.</p>\n<p>Новые функции CSS разрабатываются или определяются рабочей группой CSS. Иногда потому, что конкретный браузер заинтересован в том, чтобы иметь какие-то возможности, иногда потому, что веб-дизайнеры и разработчики запрашивают функцию, а иногда потому, что сама рабочая группа определила требование. CSS постоянно развивается, появляются новые функции. Тем не менее, ключевым моментом в CSS является то, что все работают очень усердно, чтобы никогда не менять вещи таким образом, чтобы это сломало старые сайты. Веб-сайт, созданный в 2000 году, с использованием ограниченного CSS, доступного в то время, должен всё ещё использоваться в браузере сегодня!</p>\n<p>Как новичок в CSS, вполне вероятно, что вы найдёте CSS-спецификации ошеломляющими — они предназначены для инженеров, чтобы использовать их для реализации поддержки функций в пользовательских агентах, а не для веб-разработчиков, чтобы читать, чтобы понимать CSS. Многие опытные разработчики предпочитают обращаться к документации MDN или другим учебникам. Однако стоит знать, что они существуют, понимать взаимосвязь между используемым CSS, поддержкой браузера (см. ниже) и спецификациями.</p></div></section><section aria-labelledby="информация_о_совместимости_с_браузерами"><h2 id="информация_о_совместимости_с_браузерами"><a>Информация о совместимости с браузерами</a></h2><div class="section-content"><p>После того как CSS был указан, он будет полезен для разработки веб-страниц, только если один или несколько браузеров его реализовали. Это означает, что код был написан для превращения инструкции в нашем CSS-файле во что-то, что может быть выведено на экран. Мы рассмотрим этот процесс подробнее на уроке <a>Как работает CSS</a><a>.</a> Это необычно для всех браузеров, чтобы реализовать функцию одновременно, и поэтому обычно есть пробел, где вы можете использовать некоторую часть CSS в одних браузерах, а не в других. По этой причине полезно проверять состояние реализации. На каждой странице свойств в MDN вы можете видеть статус интересующего вас свойства, чтобы вы могли определить, сможете ли вы использовать её на веб-сайте.</p></div></section><section aria-labelledby="что_дальше"><h2 id="что_дальше"><a>Что дальше?</a></h2><div class="section-content"><p>Теперь, когда у вас есть некоторое представление о том, что такое CSS, давайте перейдём к <a>Началу работы с CSS</a>, где вы можете начать писать CSS самостоятельно.</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Начало работы с CSS',
		
		content:
			'<header><h1>Начало работы с CSS</h1></header><div class="section-content">\n<p>В этой статье мы возьмём простой HTML-документ и применим к нему CSS, изучая некоторые практические вещи о языке.</p>\n</div><section aria-labelledby="начнём_с_html"><h2 id="начнём_с_html"><a>Начнём с HTML</a></h2><div class="section-content"><p>Нашей отправной точкой является HTML-документ. Вы можете скопировать код снизу, если вы хотите работать на своём компьютере. Сохраните приведённый ниже код как <code>index.html</code> в папке на вашем компьютере.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup">\n\n  \n    <meta charset="utf-8">\n    <title>Начало работы с CSS</title>\n  \n\n  \n    <h1>Я заголовок первого уровня</h1>\n\n    <p>\n      Это абзац. В нём есть <span>элемент span</span>, а также\n      <a href="http://example.com">ссылка</a>.\n    </p>\n\n    <p>Это второй абзац. Он содержит <em>акцентирующий</em> текст.</p>\n\n    <ul>\n      <li>Элемент один</li>\n      <li>Элемент два</li>\n      <li>Элемент <em>три</em></li>\n    </ul>\n  \n\n</pre></div>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> Если вы читаете это на устройстве или в среде, где вы не можете легко создавать файлы, не беспокойтесь — ниже представлены редакторы кода, чтобы вы могли написать код прямо здесь, на странице.</p>\n</div></div></section><section aria-labelledby="добавление_css_в_наш_документ"><h2 id="добавление_css_в_наш_документ"><a>Добавление CSS в наш документ</a></h2><div class="section-content"><p>Самое первое, что нам нужно сделать, — это сообщить HTML-документу, что у нас есть некоторые правила CSS, которые мы хотим использовать. Существует три различных способа применения CSS к документу HTML, с которым вы обычно сталкиваетесь, однако сейчас мы рассмотрим наиболее обычный и полезный способ сделать это — связать CSS с заголовком вашего документа.</p>\n<p>Создайте файл в той же папке, что и документ HTML, и сохраните его как <code>styles.css</code>. Расширение .css показывает, что это файл CSS.</p>\n<p>Чтобы связать styles.css с index.html, добавьте следующую строку где-то внутри<a><code>&lt;head&gt;</code></a> HTML документа:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><link rel="stylesheet" href="styles.css">\n</pre></div>\n<p>Элемент <a><code>&lt;link&gt;</code></a> сообщает браузеру, что у нас есть таблица стилей, используя атрибут <em>rel</em>, и местоположение этой таблицы стилей в качестве значения атрибута <em>href.</em> вы можете проверить, работает ли CSS, добавив правило в <em>styles.css</em>. Используя ваш редактор кода, добавьте следующее в ваш файл CSS:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">h1 {\n  color: red;\n}\n</pre></div>\n<p>Сохраните файлы HTML и CSS и перезагрузите страницу в веб-браузере. Заголовок первого уровня в верхней части документа теперь должен быть красным. Если это произойдёт, поздравляю — вы успешно применили CSS к документу HTML. Если этого не произойдёт, внимательно проверьте, правильно ли вы ввели всё.</p>\n<p>Вы можете продолжить работу в <code>styles.css</code> локально, или вы можете использовать наш интерактивный редактор ниже, чтобы продолжить этот урок. Интерактивный редактор действует так, как если бы CSS на первой панели был связан с документом HTML, как это было в нашем документе выше.</p></div></section><section aria-labelledby="стилизация_html-элементов"><h2 id="стилизация_html-элементов"><a>Стилизация HTML-элементов</a></h2><div class="section-content"><p>Делая наш заголовок красным, мы уже продемонстрировали, что можем нацеливать и стилизовать элемент HTML. Мы делаем это путём нацеливания на элемент <em>selector</em> — это селектор, который напрямую соответствует имени элемента HTML. Чтобы нацелиться на все абзацы в документе, вы должны использовать селектор <code>p</code>. Чтобы сделать все абзацы зелёными, вы должны использовать:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">p {\n  color: green;\n}\n</pre></div>\n<p>Вы можете выбрать несколько селекторов одновременно, разделив их запятыми. Если я хочу, чтобы все параграфы и все элементы списка были зелёными, моё правило выглядит так:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">p,\nli {\n  color: green;\n}\n</pre></div>\n<p>Попробуйте это в интерактивном редакторе ниже (отредактируйте поля кода) или в своём локальном документе CSS.</p></div></section><section aria-labelledby="изменение_поведения_элементов_по_умолчанию"><h2 id="изменение_поведения_элементов_по_умолчанию"><a>Изменение поведения элементов по умолчанию</a></h2><div class="section-content"><p>Когда мы смотрим на хорошо размеченный HTML-документ, даже такой простой, как наш пример, мы можем увидеть, как браузер делает HTML читаемым, добавив некоторые стили по умолчанию. Заголовки большие и жирные, в нашем списке есть маркеры. Это происходит потому, что в браузерах есть внутренние таблицы стилей, содержащие стили по умолчанию, которые по умолчанию применяются ко всем страницам; без них весь текст работал бы вместе, и мы должны были бы стилизовать всё с нуля. Все современные браузеры по умолчанию отображают HTML-контент практически одинаково.</p>\n<p>Однако вам часто захочется что-то другое, кроме выбора, сделанного браузером. Это можно сделать, просто выбрав элемент HTML, который вы хотите изменить, и используя правило CSS, чтобы изменить его внешний вид. Хорошим примером является наш <code>&lt;ul&gt;</code> — неупорядоченный список. Он добавляет маркеры, и если я решу, что я не хочу эти маркеры, я могу удалить их вот так:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">li {\n  list-style-type: none;\n}\n</pre></div>\n<p>Попробуйте добавить это в свой CSS сейчас.</p>\n<p>Свойство <code>list-style-type</code> — это хорошее свойство, информацию о котором можно найти на MDN, чтобы увидеть, какие значения поддерживаются. Взгляните на страницу для <a class="only-in-en-us" title="Currently only available in English (US)"><code>list-style-type</code> <small>(en-US)<small></small></small></a> и вы найдёте интерактивный пример в верхней части страницы, чтобы опробовать некоторые другие значения, затем все допустимые значения будут подробно описаны ниже.</p>\n<p>Глядя на эту страницу, вы обнаружите, что помимо удаления маркеров списка вы можете изменить их — попробуйте изменить их на квадратные маркеры, используя значение <code>square</code>.</p></div></section><section aria-labelledby="добавление_класса"><h2 id="добавление_класса"><a>Добавление класса</a></h2><div class="section-content"><p>Пока у нас есть стилизованные элементы, основанные на их именах HTML-элементов. Это работает до тех пор, пока вы хотите, чтобы все элементы этого типа в вашем документе выглядели одинаково. В большинстве случаев это не так, и вам нужно будет найти способ выбрать подмножество элементов, не меняя остальные. Самый распространённый способ сделать это — добавить класс к вашему HTML-элементу и нацелиться на этот класс.</p>\n<p>В своём HTML-документе добавьте Атрибут <a>class</a> ко второму пункту списка. Ваш список теперь будет выглядеть так:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><ul>\n  <li>Элемент один</li>\n  <li class="special">Элемент два</li>\n  <li>Элемент <em>три</em></li>\n</ul>\n</pre></div>\n<p>В вашем CSS вы можете выбрать класс <code>special</code> к любому элементу на странице, чтобы он выглядел так же, как и этот элемент списка. Добавьте следующее в ваш файл CSS:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.special {\n  color: orange;\n  font-weight: bold;\n}\n</pre></div>\n<p>Сохраните и обновите, чтобы увидеть результат.</p>\n<p>Вы можете захотеть, чтобы &lt;span&gt; в абзаце также был оранжевым и жирным. Попробуйте добавить класс "<code>special"</code>, затем перезагрузите страницу и посмотрите, что получится.</p>\n<p>Иногда вы увидите правила с селектором, который перечисляет селектор HTML-элемента вместе с классом:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">li.special {\n  color: orange;\n  font-weight: bold;\n}\n</pre></div>\n<p>Этот синтаксис означает «предназначаться для любого элемента li, который имеет класс special». Если бы вы сделали это, вы бы больше не смогли применить класс к <code>&lt;span&gt;</code> или другому элементу, просто добавив к нему класс; вы должны добавить этот элемент в список селекторов:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">li.special,\nspan.special {\n  color: orange;\n  font-weight: bold;\n}\n</pre></div>\n<p>Как вы можете себе представить, некоторые классы могут быть применены ко многим элементам, и вам не нужно постоянно редактировать свой CSS каждый раз, когда что-то новое должно принять этот стиль. Поэтому иногда лучше обойти элемент и просто обратиться к классу, если только вы не знаете, что хотите создать некоторые специальные правила для одного элемента и, возможно, хотите убедиться, что они не применяются к другим элементам.</p></div></section><section aria-labelledby="стилизация_элементов_на_основе_их_расположения_в_документе"><h2 id="стилизация_элементов_на_основе_их_расположения_в_документе"><a>Стилизация элементов на основе их расположения в документе</a></h2><div class="section-content"><p>Есть моменты, когда вы хотите, чтобы что-то выглядело иначе, в зависимости от того, где оно находится в документе. Здесь есть несколько селекторов, которые могут вам помочь, но сейчас мы рассмотрим только пару. В нашем документе два элемента <code>&lt;em&gt;</code> — один внутри абзаца, а другой внутри элемента списка. Чтобы выбрать только <code>&lt;em&gt;</code> который вложен в элемент <code>&lt;li&gt;</code>, я могу использовать селектор под названием <strong>descendant combinator (комбинатор-потомок)</strong>, который просто принимает форму пробела между двумя другими селекторами.</p>\n<p>Добавьте следующее правило в таблицу стилей.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">li em {\n  color: rebeccapurple;\n}\n</pre></div>\n<p>Этот селектор выберет любой элемент <code>&lt;em&gt;</code>, который находится внутри (потомка) <code>&lt;li&gt;</code>. Итак, в вашем примере документа вы должны найти, что <code>&lt;em&gt;</code> в третьем элементе списка теперь фиолетовый, но тот, который находится внутри абзаца, не изменился.</p>\n<p>Ещё можно попробовать стилизовать абзац, когда он идёт сразу после заголовка на том же уровне иерархии в HTML. Для этого поместите <code>+</code> (<strong>соседний братский комбинатор</strong>) между селекторами.</p>\n<p>Попробуйте также добавить это правило в таблицу стилей:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">h1 + p {\n  font-size: 200%;\n}\n</pre></div>\n<p>Пример ниже включает в себя два правила выше. Попробуйте добавить правило, чтобы сделать элемент span красный, если он внутри абзаца. Вы узнаете, правильно ли вы это сделали, так как промежуток в первом абзаце будет красным, но цвет в первом элементе списка не изменит цвет.</p>\n<div class="notecard note" id="sect2">\n  <p><strong>Примечание:</strong> Как вы можете видеть, CSS даёт нам несколько способов нацеливания на элементы, и мы пока только слегка изучили его! Мы будем внимательно смотреть на все эти селекторы и многое другое в нашей статье <a>Селекторы</a> позже в нашем курсе.</p>\n</div></div></section><section aria-labelledby="стилизация_элементов_на_основе_состояния"><h2 id="стилизация_элементов_на_основе_состояния"><a>Стилизация элементов на основе состояния</a></h2><div class="section-content"><p>Последний тип стилей, который мы рассмотрим в этом уроке, — это возможность стилизовать элементы в зависимости от их состояния. Прямым примером этого является стиль ссылок. Когда мы создаём ссылку, мы должны нацелить элемент <a><code>&lt;a&gt;</code></a> (якорь). Он имеет различные состояния в зависимости от того, посещается ли он, посещается, находится над ним, фокусируется с помощью клавиатуры или в процессе нажатия (активации). Вы можете использовать CSS для нацеливания на эти разные состояния — CSS-код ниже отображает невидимые ссылки розового цвета и посещённые ссылки зелёного цвета.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">a:link {\n  color: pink;\n}\n\na:visited {\n  color: green;\n}\n</pre></div>\n<p>Вы можете изменить внешний вид ссылки, когда пользователь наводит на неё курсор, например, удалив подчёркивание, что достигается с помощью следующего правила:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">a:hover {\n  text-decoration: none;\n}\n</pre></div>\n<p>В приведённом ниже примере вы можете поиграть с разными значениями для разных состояний ссылки. Я добавил к нему правила, приведённые выше, и теперь понимаю, что розовый цвет довольно лёгкий и трудно читаемый — почему бы не изменить его на лучший цвет? Можете ли вы сделать ссылки жирным шрифтом?</p>\n<p>Мы удалили подчёркивание на нашей ссылке при наведении курсора. Вы можете удалить подчёркивание из всех состояний ссылки. Однако стоит помнить, что на реальном сайте вы хотите, чтобы посетители знали, что ссылка является ссылкой. Оставив подчёркивание на месте, люди могут понять, что на какой-то текст внутри абзаца можно нажимать — к такому поведению они привыкли. Как и всё в CSS, существует возможность сделать документ менее доступным с вашими изменениями — мы постараемся выделить потенциальные подводные камни в соответствующих местах.</p>\n<div class="notecard note" id="sect3">\n  <p><strong>Примечание:</strong> вы часто будете видеть упоминание о <a>доступности</a> в этих уроках и по всей MDN. Когда мы говорим о доступности, мы имеем в виду требование, чтобы наши веб-страницы были понятными и доступными для всех.</p>\n  <p>Ваш посетитель вполне может быть на компьютере с мышью или сенсорной панелью или на телефоне с сенсорным экраном. Либо они могут использовать программу чтения с экрана, которая считывает содержимое документа, либо им может потребоваться использовать текст значительно большего размера, либо перемещаться по сайту только с помощью клавиатуры.</p>\n  <p>Простой HTML-документ, как правило, доступен каждому — когда вы начинаете оформлять этот документ, важно, чтобы вы не сделали его менее доступным.</p>\n</div></div></section><section aria-labelledby="сочетание_селекторов_и_комбинаторов"><h2 id="сочетание_селекторов_и_комбинаторов"><a>Сочетание селекторов и комбинаторов</a></h2><div class="section-content"><p>Стоит отметить, что вы можете комбинировать несколько селекторов и комбинаторов вместе. Вот пример:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">/* выбирает любой <span> внутри <p>, который находится внутри </p><article>  */\narticle p span { ... }\n\n/* выбирает любой <p>, который идёт сразу после </p><ul>, который идёт сразу после <h1>  */\nh1 + ul + p { ... }\n</h1></ul></article></span></pre></div>\n<p>Вы также можете комбинировать несколько типов вместе. Попробуйте добавить следующее в ваш код:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">body h1 + p .special {\n  color: yellow;\n  background-color: black;\n  padding: 5px;\n}\n</pre></div>\n<p>Это будет стиль любого элемента с классом <code>special</code>, который находится внутри <code>&lt;p&gt;</code>, который приходит сразу после <code>&lt;h1&gt;</code>, который находится внутри <code>&lt;body&gt;</code>. Уф!</p>\n<p>В оригинальном HTML, который мы предоставили, единственный элемент в стиле <code>&lt;span class="special"&gt;</code>.</p>\n<p>Не беспокойтесь, если это покажется сложным — вы скоро начнёте понимать это, когда будете писать больше на CSS.</p></div></section><section aria-labelledby="завершение"><h2 id="завершение"><a>Завершение</a></h2><div class="section-content"><p>В этом уроке мы рассмотрели несколько способов стилизации документа с использованием CSS. Мы будем развивать эти знания по мере прохождения остальных уроков. Однако вы уже знаете достаточно, чтобы стилизовать текст, применять CSS на основе различных способов нацеливания на элементы в документе и искать свойства и значения в документации MDN.</p>\n<p>На следующем уроке мы рассмотрим структуру CSS.</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Как структурирован CSS',
		
		content:
			'<header><h1>Как структурирован CSS</h1></header><div class="section-content">\n<p>Теперь, когда у вас есть представление о том, чем является CSS, и о его основах, настало время посмотреть немного глубже в структуру самого языка. Нам уже встречались многие из обсуждаемых здесь концепций; вы можете вернуться к этому, чтобы разобраться, если вы обнаружите какие-либо более поздние концепции запутанными.</p>\n</div><section aria-labelledby="применение_css_к_вашему_html"><h2 id="применение_css_к_вашему_html"><a>Применение CSS к вашему HTML</a></h2><div class="section-content"><p>Первое, что мы рассмотрим, это три метода применения CSS к документу.</p></div></section><section aria-labelledby="внешняя_таблица_стилей"><h3 id="внешняя_таблица_стилей"><a>Внешняя таблица стилей</a></h3><div class="section-content"><p>В статье <a>Начало работы с CSS</a> мы связывали внешнюю таблицу стилей с нашей страницей. Это самый распространённый и полезный способ крепления CSS к документу, так вы можете привязать CSS сразу к нескольким страницам, что позволяет стилизовать их всё с той же таблицей стилей. В большинстве случаев различные страницы сайта будут выглядеть почти так же, поэтому вы можете использовать один и тот же набор правил для основного вида.</p>\n<p>Внешняя таблица стилей - это когда у вас есть CSS отдельным файлом с расширением <code>.css</code>, и ссылка на него из HTML-элемента <code>&lt;link&gt;</code>:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup">\n\n  \n    <meta charset="utf-8">\n    <title>Я пробую писать CSS</title>\n    <link rel="stylesheet" href="styles.css">\n  \n  \n    <h1>Привет!</h1>\n    <p>Это мой первый опыт в CSS</p>\n  \n\n</pre></div>\n<p>Файл CSS может выглядеть следующим образом:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">h1 {\n  color: blue;\n  background-color: yellow;\n  border: 1px solid black;\n}\n\np {\n  color: red;\n}\n</pre></div>\n<p>Атрибут <code>href</code> элемента <a><code>&lt;link&gt;</code></a> должен ссылаться на файл в файловой системе.</p>\n<p>В приведённом выше примере файл CSS находится в той же папке, что и HTML-документ, но вы можете поместить его куда-нибудь ещё и настроить относительный путь, например:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><!-- Файл находится внутри под-директории styles, находящейся в текущей директории -->\n<link rel="stylesheet" href="styles/style.css">\n\n<!-- Файл — внутри под-директории styles внутри под-под-директории general и так далее -->\n<link rel="stylesheet" href="styles/general/style.css">\n\n<!-- Вверх на один уровень в директории, затем направиться в под-директорию styles -->\n<link rel="stylesheet" href="../styles/style.css">\n</pre></div></div></section><section aria-labelledby="внутренняя_таблица_стилей"><h3 id="внутренняя_таблица_стилей"><a>Внутренняя таблица стилей</a></h3><div class="section-content"><p>Внутренняя таблица стилей, где у вас нет внешнего файла CSS, но вместо этого CSS помещён внутри элемента <a><code>&lt;style&gt;</code></a>, содержащейся внутри HTML <a><code>&lt;head&gt;</code></a>.</p>\n<p>Таким образом, HTML будет выглядеть вот так:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup">\n\n  \n    <meta charset="utf-8">\n    <title>Я пробую писать CSS</title>\n    <style>\n      h1 {\n        color: blue;\n        background-color: yellow;\n        border: 1px solid black;\n      }\n\n      p {\n        color: red;\n      }\n    </style>\n  \n  \n    <h1>Привет!</h1>\n    <p>Это мой первый опыт в CSS</p>\n  \n\n</pre></div>\n<p>Это может быть полезно в некоторых обстоятельствах (возможно, вы работаете с системой управления контентом, где вы не можете изменить CSS-файлы непосредственно), но это менее эффективно, чем внешние таблицы стилей: CSS будет необходимо прописывать отдельно для каждой страницы и изменять, если требуются изменения.</p></div></section><section aria-labelledby="встроенные_стили"><h3 id="встроенные_стили"><a>Встроенные стили</a></h3><div class="section-content"><p>Встроенные стили являются правилами CSS, которые влияют только на один элемент, содержащиеся в атрибуте <code>style</code>:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup">\n\n  \n    <meta charset="utf-8">\n    <title>Я пробую писать CSS</title>\n  \n  \n    <h1 style="color: blue;background-color: yellow;border: 1px solid black;">\n      Привет!\n    </h1>\n    <p style="color:red;">Это мой первый опыт в CSS</p>\n  \n\n</pre></div>\n<p><strong>Пожалуйста, не делайте этого!</strong> Это очень плохо для технического обслуживания (вам, возможно, придётся обновить одну и ту же информацию несколько раз в одном документе), а также смешивает ваши презентационные данные CSS с структурной информацией HTML, что делает код трудным для чтения и понимания. Хранение различных типов кода отделено делает работу гораздо более лёгкой для всех, кто работает над кодом.</p>\n<p>Есть несколько мест, где встроенные стили являются более распространёнными или даже желательными. Вам, возможно, придётся прибегнуть к использованию их, если ваша рабочая среда сильно ограничена (возможно, ваша CMS позволяет редактировать только HTML-тело). Вы также увидите, как они использовали много в HTML электронной почте, чтобы получить совместимость с таким количеством почтовых клиентов, со скольким это возможно.</p></div></section><section aria-labelledby="игра_с_css_в_этой_статье"><h2 id="игра_с_css_в_этой_статье"><a>Игра с CSS в этой статье</a></h2><div class="section-content"><p>Существует много возможностей, чтобы поиграть с CSS в этой статье. Для этого мы рекомендуем создать новый каталог / папку на вашем компьютере и внутри него создать копии следующих двух файлов:</p>\n<p>index.html:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup">\n\n  \n    <meta charset="utf-8">\n    <title>Я пробую писать CSS</title>\n    <link rel="stylesheet" href="styles.css">\n  \n  \n    <p>Пишите сюда свой код</p>\n  \n\n</pre></div>\n<p>styles.css:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">/* Пишите сюда свой код */\n\np {\n  color: red;\n}\n</pre></div>\n<p>Затем, когда вы столкнётесь с CSS и захотите поэкспериментировать со стилями, измените содержимое <code>&lt;body&gt;</code> HTML-документа и начинайте добавлять CSS-стили внутри вашего файла CSS.</p>\n<p>Если вы не используете систему, в которой вы можете легко создавать файлы, вы можете вместо этого использовать интерактивный редактор ниже чтобы экспериментировать.</p>\n<p>Читайте дальше и получайте удовольствие!</p></div></section><section aria-labelledby="селекторы"><h2 id="селекторы"><a>Селекторы</a></h2><div class="section-content"><p>Говоря о CSS, нельзя не упомянуть о селекторах, о некоторых типах которых мы уже говорили в руководстве <a>Начало работы с CSS</a>. Селектор — это то, как мы обозначаем что-либо в нашем HTML-документе, чтобы стилизовать его. Если стиль не применился, то это, скорее всего, потому, что селектор в таблицах стилей не совпал с тем, что в HTML-документе.</p>\n<p>Каждое CSS-правило начинается с одного или нескольких селекторов, отделяемых друг от друга запятыми, чтобы дать понять браузеру, к чему применять стили. В следующем примере перечислены стандартные селекторы:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">h1  /* это селектор тегов */\na:link  /* это селектор ссылок */\n.manythings  /* это селектор классов (классы применяются тогда, когда необходимо применить правило к нескольким элементам) */\n#onething  /* это селектор идентификаторов (они применяются, когда правило относится к одному элементу) */\n*  /* универсальный селектор */\n.box p  /* селектор потомков */\n.box p:first-child  /* селектор потомков + селектор псевдоклассов */\nh1, h2, .intro  /* перечисление селекторов */\n</pre></div>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> вы узнаете больше о селекторах в руководстве <a>CSS-селекторы</a> в следующем модуле.</p>\n</div></div></section><section aria-labelledby="спецификация"><h3 id="спецификация"><a>Спецификация</a></h3><div class="section-content"><p>Иногда может случаться такое, что два селектора будут относиться к одному и тому же элементу HTML. Смотрите: в примере ниже я задал правило для элемента <code>p</code> — он будет синим; также я задал класс, который сделает элемент красным:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.special {\n  color: red;\n}\n\np {\n  color: blue;\n}\n</pre></div>\n<p>А теперь допустим, что в нашем HTML-коде у нас есть абзац <code>p</code> с классом <code>special</code>. Оба правила могут быть добавлены: так какое же одержит верх? Как вы думаете, какого цвета будет надпись?</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><p class="special">Какого же я цвета?</p>\n</pre></div>\n<p>В языке CSS есть правила, которые определяют, какое правило "выиграет" в случае подобного столкновения — они называются <strong>каскадами</strong>, или <strong>спецификациями</strong>. В примере ниже мы задали два правила для селектора <code>p</code>, но в итоге текст будет синим: объявление, делающее надпись синей, появилось позже того, которое делает её красной. Это каскад в действии.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">p {\n  color: red;\n}\n\np {\n  color: blue;\n}\n</pre></div>\n<p>А в примере с селектором класса и селектором тега победит селектор класса — даже если он объявлен раньше.</p>\n<p><strong>Попрактикуйтесь сами — добавьте два правила для параграфа <code>p { ... }</code> в вашу таблицу стилей. Затем добавьте класс к одному элементу <code>p</code> и попробуйте применить к нему какой-нибудь стиль.</strong></p>\n<p>Понимание каскадов, или правил, улучшается с практикой. В статье <a>Каскад и наследование</a> я хорошенько объясню, как определить уровень спецификации. А пока что запомните, что иногда CSS не применяется так, как вы того хотели бы, так как у чего-то в таблице стилей больший уровень спецификации.</p></div></section><section aria-labelledby="свойства_и_значения"><h2 id="свойства_и_значения"><a>Свойства и значения</a></h2><div class="section-content"><p>Если говорить в общем, CSS строится на двух его составляющих:</p>\n<dl>\n  <dt id="свойства"><a><strong>Свойства</strong></a></dt>\n  <dd>\n    <p>Определяют, какую характеристику вы желаете изменить (например, <a><code>font-size</code></a>, <a><code>width</code></a>, <a><code>background-color</code></a>).</p>\n  </dd>\n  <dt id="значения"><a>Значения</a></dt>\n  <dd>\n    <p>Это величина свойства, определяющая, как и/или насколько вы желаете изменить свойство.</p>\n  </dd>\n</dl>\n<p>На изображении внизу выделены свойство и его значение. Здесь свойство — <code>color</code>, а его значение — <code>blue</code>.</p>\n<p>\n  \n</p>\n<p>Свойство вкупе со значением называется <em>CSS-объявлением</em>. CSS-объявления помещаются внутри <em>блока объявлений CSS</em>. Ниже показан наш CSS-код с выделенным блоком объявлений.</p>\n<p>\n  \n</p>\n<p>Наконец блок объявлений воссоединяется с <em>селекторами</em>, образуя <em>CSS-правила</em>. Наше изображение содержит два правила — одно для селектора <code>h1</code>, другое для селектора <code>p</code>. Правило для <code>h1</code> выделено.</p>\n<p>\n  \n</p>\n<p>Установление значений для CSS-свойств — вот суть языка CSS. Движок CSS определяет, какие объявления применять к каждому элементу на странице, чтобы соответствующим образом размещать и стилизовать его. Необходимо запомнить, что и свойства, и значения чувствительны к регистру. Пара свойство–значение разделяется двоеточием (<code>:</code>).</p>\n<p><strong>Попробуйте подобрать нужные значения к следующим свойствам, а свойства добавить в ваш код:</strong></p>\n<ul>\n  <li><strong><a><code>font-size</code></a></strong></li>\n  <li><strong><a><code>width</code></a></strong></li>\n  <li><strong><a><code>background-color</code></a></strong></li>\n  <li><strong><a class="only-in-en-us" title="Currently only available in English (US)"><code>color</code> <small>(en-US)</small></a></strong></li>\n  <li><strong><a><code>border</code></a></strong></li>\n</ul>\n<div class="notecard warning" id="sect2">\n  <p><strong>Предупреждение:</strong> <strong>Важно</strong>: Если свойство или значение не определено, то объявление считается <em>недействительным</em> — и будет попросту проигнорировано.</p>\n</div>\n<div class="notecard warning" id="sect3">\n  <p><strong>Предупреждение:</strong> <strong>Важно</strong>: В CSS (и прочих веб-стандартах) американское написание является стандартом. Например, <code>color</code> надо <em>всегда</em> писать <code>color</code>; британский вариант <code>colour</code> не будет работать.</p>\n</div></div></section><section aria-labelledby="функции"><h3 id="функции"><a>Функции</a></h3><div class="section-content"><p>Чаще всего в качестве значений выступают ключевые слова или числа. Но некоторые значения могут быть функциями.</p>\n<h4 id="функция_calc">Функция calc()</h4>\n<p>Напрмер, рассмотрим функцию <code>calc()</code>, с попомщью которой можно выполнять простые математические операции в CSS:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><div class="outer">\n  <div class="box">Ширина внутреннего контейнера равна 90% - 30px.</div>\n</div>\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.outer {\n  border: 5px solid black;\n}\n\n.box {\n  padding: 10px;\n  width: calc(90% - 30px);\n  background-color: rebeccapurple;\n  color: white;\n}\n</pre></div>\n<p>Этот код отобразит следующий результат:</p><div class="code-example" id="sect4"><div class="example-header" id="sect5"></div></div>\n<p>Вызов функции состоит из имени функции, круглых скобок и значения внутри них. В приведённом выше примере с помощью функции <code>calc()</code> устанавливается ширина контейнера равная 90% от ширины родтиельского блока минус 30 пикселей. Результат такого расчёта нельзя вычислить заранее и ввести как статическое значение.</p>\n<h4 id="функции_трансформации">Функции трансформации</h4>\n<p>Другим примером могут служить различные <a><code>функции трансформации</code></a>, такие как <code>rotate()</code>.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><div class="box"></div>\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.box {\n  margin: 30px;\n  width: 100px;\n  height: 100px;\n  background-color: rebeccapurple;\n  transform: rotate(0.8turn);\n}\n</pre></div>\n<p>Результат приведённого выше кода будет таким:</p><div class="code-example" id="sect6"><div class="example-header" id="sect7"></div></div>\n<p><strong>Найдите различные значения свойств, перечисленных ниже. Напишите правила CSS, которые применяют стили к различным элементам HTML:</strong></p>\n<ul>\n  <li><strong><a><code>transform</code></a></strong></li>\n  <li><strong><a><code>background-image</code></a>, в том числе значения градиента</strong></li>\n  <li><strong><a class="only-in-en-us" title="Currently only available in English (US)"><code>color</code> <small>(en-US)</small></a>, в том числе значения rgb и hsl</strong></li>\n</ul></div></section><section aria-labelledby="правила"><h2 id="правила"><a>Правила</a></h2><div class="section-content"><p>До сих пор не сталкивались мы с правилами <a><code>@rules</code></a> (произносится как <em>эт-рулс</em>, от английского "at-rules"). Это особые правила, дающие CSS инструкции, как вести себя. У некоторых правил <code>@rules</code> простые названия и значения. Чтобы, к примеру, импортировать ещё одну таблицу стилей в основной CSS-файл, нужно использовать <code>@import</code>:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">@import "styles2.css";\n</pre></div>\n<p>Чаще других встречается <code>@rules</code> под названием <code>@media</code>: оно позволяет вам использовать <a>медиавыражения</a>, чтобы применять CSS в определённых случаях, только если выполняются те или иные условия (например, при изменении размеров окна или при просмотре сайта с иного типа устройства).</p>\n<p>Ниже у нас CSS-файл, в котором значение заднего фона элемента <code>&lt;body&gt;</code> равно <code>pink</code>. Однако после мы добавили правило <code>@media</code>, которое делает задний фон элемента синим, при условии если ширина окна не менее 30em.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">body {\n  background-color: pink;\n}\n\n@media (min-width: 30em) {\n  body {\n    background-color: blue;\n  }\n}\n</pre></div>\n<p>Вы столкнётесь и с другими правилами <code>@rules</code> в продолжение следующих уроков.</p>\n<p><strong>Добавьте правило, которое изменяет стиль элемента, основываясь на ширине окна. Измените ширину окна, чтобы увидеть результат.</strong></p></div></section><section aria-labelledby="стенография"><h2 id="стенография"><a>Стенография</a></h2><div class="section-content"><p>Некоторые свойства вроде <a><code>font</code></a>, <a><code>background</code></a>, <a><code>padding</code></a>, <a><code>border</code></a> и <a><code>margin</code></a> называются <em>стенографическими свойствами</em>, — они позволяют установить несколько значений свойств в одной строке, ускоряя запись и делая её аккуратной.</p>\n<p>К примеру, это строка (комментарий не в счёт):</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">/* В четырёхзначных стенографиях наподобие padding и margin значения добавляются\n   в порядке верх–право–низ–лево (по часовой стрелке сверху). В трёхзначных стенограммах\n   значения добавляются в порядке верх(низ)–право–лево.\n   В двузначных стенограммах значения добавляются\n   от верхнего/нижнего края к левому/правому краю */\npadding: 10px 15px 15px 5px;\n</pre></div>\n<p>делает то же самое, что и эти четыре, вместе взятые:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">padding-top: 10px;\npadding-right: 15px;\npadding-bottom: 15px;\npadding-left: 5px;\n</pre></div>\n<p>или эти:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="cpp">padding-block-start: 10px\npadding-inline-end: 15px;\npadding-block-end: 15px;\npadding-inline-start: 5px;\n</pre></div>\n<p>в то время как строка:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">background: red url(bg-graphic.png) 10px 10px repeat-x fixed;\n</pre></div>\n<p>делает то же, что и эти строки:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">background-color: red;\nbackground-image: url(bg-graphic.png);\nbackground-position: 10px 10px;\nbackground-repeat: repeat-x;\nbackground-scroll: fixed;\n</pre></div>\n<p>Мы не будем проходить это сейчас — вы можете найти эти и многие другие стенографии в <a>Руководстве по CSS</a>.</p>\n<p><strong>Добавьте вышеупомянутые объявления в ваш код. Попробуйте изменить значения и посмотреть на результат.</strong></p>\n<div class="notecard warning" id="sect8">\n  <p><strong>Предупреждение:</strong> <strong>Осторожно</strong>: Стенографии позволяют пропускать некоторые величины, и это может отразиться на результате недолжным образом.</p>\n</div></div></section><section aria-labelledby="комментарии"><h2 id="комментарии"><a>Комментарии</a></h2><div class="section-content"><p>Как и в HTML, вы можете делать комментарии, чтобы прояснить тот или иной отрывок кода.</p>\n<p>Комментарии в CSS начинаются с <code>/*</code> и окачиваются с <code>*/</code>. В примере ниже я отметил комментариями различные разделы кода. Это очень полезно для навигации — комментарии легче искать.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">/* Работаю над основными элементами */\n/* -------------------------------------------------------------------------------------------- */\nbody {\n  font:\n    1em/150% Helvetica,\n    Arial,\n    sans-serif;\n  padding: 1em;\n  margin: 0 auto;\n  max-width: 33em;\n}\n\n@media (min-width: 70em) {\n  /* Позволяет определить размер шрифта. На широких экранах\n     больше размер шрифта для удобства чтения */\n  body {\n    font-size: 130%;\n  }\n}\n\nh1 {\n  font-size: 1.5em;\n}\n\n/* Работаю над элементами, вложенными в DOM  */\n/* -------------------------------------------------------------------------------------------- */\ndiv p,\n#id:first-line {\n  background-color: red;\n  background-style: none;\n}\n\ndiv p {\n  margin: 0;\n  padding: 1em;\n}\n\ndiv p + p {\n  padding-top: 0;\n}\n</pre></div>\n<p>Отделяя комментариями участки кода, не нуждающиеся в проверке, вы можете выискивать ошибку (если такая есть). Ниже я отделил правило для селектора <code>.special</code>.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">/*.special {\n  color: red;\n}*/\n\np {\n  color: blue;\n}\n</pre></div>\n<p><strong>Добавьте комментарии в ваш CSS-код, чтобы приноровиться к ним.</strong></p></div></section><section aria-labelledby="отступы"><h2 id="отступы"><a>Отступы</a></h2><div class="section-content"><p>Под отступами подразумеваются пробелы, табуляция и перенос на новую строку. Как и в HTML, браузер будет стараться игнорировать большие отступы в CSS-коде; к тому же большие отступы пагубны для читаемости кода.</p>\n<p>В примере ниже каждое объявление (а также начало/окончание правила) находится на своей строке — это, возможно, наилучший вариант написания CSS-кода: он понятен и аккуратен:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">body {\n  font:\n    1em/150% Helvetica,\n    Arial,\n    sans-serif;\n  padding: 1em;\n  margin: 0 auto;\n  max-width: 33em;\n}\n\n@media (min-width: 70em) {\n  body {\n    font-size: 130%;\n  }\n}\n\nh1 {\n  font-size: 1.5em;\n}\n\ndiv p,\n#id:first-line {\n  background-color: red;\n  background-style: none;\n}\n\ndiv p {\n  margin: 0;\n  padding: 1em;\n}\n\ndiv p + p {\n  padding-top: 0;\n}\n</pre></div>\n<p>То же самое вы можете написать, не добавляя большие отступы, — коды идентичны; но я уверен, вы согласитесь, что это очень тяжело прочитать:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">body {\n  font:\n    1em/150% Helvetica,\n    Arial,\n    sans-serif;\n  padding: 1em;\n  margin: 0 auto;\n  max-width: 33em;\n}\n@media (min-width: 70em) {\n  body {\n    font-size: 130%;\n  }\n}\n\nh1 {\n  font-size: 1.5em;\n}\n\ndiv p,\n#id:first-line {\n  background-color: red;\n  background-style: none;\n}\ndiv p {\n  margin: 0;\n  padding: 1em;\n}\ndiv p + p {\n  padding-top: 0;\n}\n</pre></div>\n<p>Как вы будете оформлять код — решать вам; хотя, работая в команде, вы обнаружите, что она придерживается тех правил форматирования, которые в ней утверждены.</p>\n<p>Внимательно делайте отступы в свойствах и значениях. К примеру, такие объявления будут работать:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">margin: 0 auto;\npadding-left: 10px;\n</pre></div>\n<p>А такие объявления не действительны:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">margin: 0auto;\npadding- left: 10px;\n</pre></div>\n<p>Всегда отделяйте друг от друга значения, а свойства пишите без пробелов через дефис.</p>\n<p><strong>Добавьте отступы в ваш код и посмотрите, что повлияет на код, а что нет.</strong></p></div></section><section aria-labelledby="что_дальше"><h2 id="что_дальше"><a>Что дальше?</a></h2><div class="section-content"><p>Полезно знать, как браузер делает из HTML и CSS готовую страницу, поэтом следующая ваша статья — <a>Как работает CSS</a> — мы рассмотрим этот процесс.</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Как работает CSS',
		
		content:
			'<header><h1>Как работает CSS</h1></header><div class="section-content">\n<p>Мы уже изучили основы CSS, для чего он нужен и как создавать простые таблицы стилей. В этом уроке мы посмотрим, как браузер обрабатывает CSS и HTML и выводит содержимое на веб-страницу.</p>\n</div><section aria-labelledby="как_работает_css"><h2 id="как_работает_css"><a>Как работает CSS?</a></h2><div class="section-content"><p>Когда браузер отображает документ, он должен совместить его содержимое с его стилями. Этот процесс идёт в несколько этапов, о которых мы сейчас поговорим. Держите в уме, что это очень упрощённая версия того как браузер действительно загружает веб-страницу, а также то, что разные браузеры делают это по разному. Но, происходит, грубо говоря, следующее:</p>\n<ol>\n  <li>Браузер получает HTML-страницу (например, из Интернета)</li>\n  <li>Преобразует <a>HTML</a> в <a>DOM</a> (<em>Document Object Model</em>). DOM (или DOM-дерево) - это представление страницы в памяти компьютера. Подробнее на DOM мы остановимся чуть позже.</li>\n  <li>Затем браузер забирает все ресурсы и описания, связанные с HTML-документом, например: встроенные картинки, видео ... и стили CSS! JavaScript присоединяется чуть позже и мы пока не будем говорить об этом, чтобы все не усложнять.</li>\n  <li>После этого браузер анализирует полученный CSS код, сортирует описанные там правила в зависимости от их селекторов и раскладывает их в различные «корзины»: элементы, классы, идентификаторы(ID) и т.п. Основываясь на найденных селекторах браузер понимает какие правила относятся к определённым «узлам» в DOM-дереве и применяет их по мере необходимости (этот промежуточный шаг называют «формированием дерева представления» или «формированием дерева рендеринга»)</li>\n  <li>Дерево представления (<em>render tree</em>) формируется в том порядке, в каком оно затем должно будет отображаться, когда все правила будут применены.</li>\n  <li>Затем происходит визуальное отображение контента на странице (этот этап называется «отрисовкой»)</li>\n</ol>\n<p>Диаграмма демонстрирует этот процесс.</p>\n<p>\n  \n</p></div></section><section aria-labelledby="dom-дерево"><h2 id="dom-дерево"><a>DOM-дерево</a></h2><div class="section-content"><p>DOM напоминает дерево. Каждый элемент, атрибут, отрывок текста становится <a class="only-in-en-us" title="Currently only available in English (US)">DOM node <small>(en-US)</small></a> в разметке. DOM-узлы определяются их отношением с другими узлами. Некоторые родительские элементы имеют дочерние, а у дочерних элементов есть братские.</p>\n<p>Понимание DOM позволит вам разрабатывать, отлаживать и поддерживать ваш CSS, потому что именно в DOM-дереве ваши таблицы стилей и код встречаются. Когда вы начнёте работать с браузерным DevTools(инструменты для разработки) вы будете перемещаться по DOM при выборе элементов чтобы увидеть какие правила применяются.</p></div></section><section aria-labelledby="как_представлено_dom-дерево"><h2 id="как_представлено_dom-дерево"><a>Как представлено DOM-дерево</a></h2><div class="section-content"><p>Вместо длинного, нудного объяснения взглянем лучше на пример, чтобы понять, как HTML-код преобразуется в DOM.</p>\n<p>Возьмём следующий пример:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><p>\n  Let\'s use:\n  <span>Cascading</span>\n  <span>Style</span>\n  <span>Sheets</span>\n</p>\n</pre></div>\n<p>В DOM-дереве узел, соответствующий элементу <code>&lt;p&gt;</code>, — это родительский элемент. Его дочерние элементы — текст и три элемента <code>&lt;span&gt;</code>. Узлы <code>SPAN</code> также будут родителями — с текстом в качестве дочерних элементов:</p>\n<pre compile="false" disable="true" language="markup">P\n├─ "Let\'s use:"\n├─ SPAN\n|  └─ "Cascading"\n├─ SPAN\n|  └─ "Style"\n└─ SPAN\n   └─ "Sheets"\n</pre>\n<p>Вот как браузер преобразует HTML-код — он загружает DOM-дерево, и в результате мы получим это:</p><div class="code-example" id="sect1"><div class="example-header" id="sect2"></div></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">p {\n  margin: 0;\n}\n</pre></div></div></section><section aria-labelledby="добавление_css_в_dom"><h2 id="добавление_css_в_dom"><a>Добавление CSS в DOM</a></h2><div class="section-content"><p>Допустим, мы добавили таблицу стилей к нашему примеру:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><p>\n  Let\'s use:\n  <span>Cascading</span>\n  <span>Style</span>\n  <span>Sheets</span>\n</p>\n</pre></div>\n<p>А вот CSS-код:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">span {\n  border: 1px solid black;\n  background-color: lime;\n}\n</pre></div>\n<p>Браузер загрузит HTML-код, преобразует его в DOM и только потом загрузит CSS. Так как у нас всего одно правило, браузер загрузит CSS очень быстро! Это правило будет добавлено к каждому из трёх элементов <code>&lt;span&gt;</code>. После этого информация будет отображена на экране.</p>\n<p>Новый результат:</p><div class="code-example" id="sect3"><div class="example-header" id="sect4"></div></div>\n<p>В статье <a>Отладка CSS</a> мы будем использовать браузер DevTools для отладки CSS.</p></div></section><section aria-labelledby="что_происходит_когда_браузер_не_понимает_css"><h2 id="что_происходит_когда_браузер_не_понимает_css"><a>Что происходит, когда браузер не понимает CSS?</a></h2><div class="section-content"><p><a>В предыдущем уроке</a> я упомянул, что некоторые браузеры могут не поддерживать новые функции CSS. Вдобавок не все используют новейшие версии браузеров. Зная, что CSS разрабатывается всё время, вы можете поразиться и крайне ужаснуться тому, что происходит, если браузер не распознаёт объявление или селектор. Что же произойдёт?</p>\n<p>— Да ничего: браузер просто пропустит это!</p>\n<p>Если браузер встретит свойство, которое он не понимает, он просто-напросто проигнорирует его и двинется дальше. Он сделает так, если вы допустите опечатку или ошибку в свойстве или значении или если он не поддерживает какое-либо свойство или значение.</p>\n<p>Если же браузер встретит селектор, который он не распознаёт, то он просто пропустит данное правило и двинется дальше.</p>\n<p>Ниже я использовал британское написание слова <em>color</em>, что делает свойство некорректным. Поэтому текст не будет синим. Однако всё остальное будет работать; пропущено только недействительное свойство.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><p>I want this text to be large, bold and blue.</p>\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">p {\n  font-weight: bold;\n  colour: blue; /* некорректное написание свойства цвета */\n  font-size: 200%;\n}\n</pre></div><div class="code-example" id="sect5"><div class="example-header" id="sect6"></div></div>\n<p>Такое поведение можно использовать, например, при добавлении новых функций CSS в качестве дополнения, причём вы будете уверены, что ничего не сломается, если браузер не распознает элемент. Вы можете использовать два правила с одинаковыми уровнями спецификации: одно — в качестве альтернативы для случая, если браузер не поддерживает нововведение.</p>\n<p>Это хорошо применяется, если вы хотите использовать величину, не использующуюся везде в документе. К примеру, некоторые старые браузеры не поддерживают <code>calc()</code> как значение. Я добавлю резерв — значение в px, затем задам ширину с помощью функции <code>calc()</code>, равной <code>100% - 50px</code>. Старые браузеры используют пиксельное значение, потому что не распознают <code>calc()</code>. Новые браузеры используют <code>calc()</code> так как эта строка появляется позже в каскаде.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.box {\n  width: 500px;\n  width: calc(100% - 50px);\n}\n</pre></div></div></section><section aria-labelledby="завершение"><h2 id="завершение"><a>Завершение</a></h2><div class="section-content"><p>Вы почти закончили модуль; осталось только одно. В следующей статье вы попрактикуетесь в <a>использовании ваших новых знаний</a>.</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Использование ваших новых знаний',
		
		content:
			'<header><h1>Использование ваших новых знаний</h1></header><div class="section-content">\n<p>С учётом того что вы узнали за последние несколько уроков, вы должны обнаружить, что вы можете форматировать простые текстовые документы с использованием CSS, чтобы добавить к ним свой собственный стиль. Эта статья даёт вам возможность сделать это.</p>\n</div><section aria-labelledby="перед_началом"><h2 id="перед_началом"><a>Перед началом</a></h2><div class="section-content"><p>Вы можете писать код в редакторе ниже или <a class="external" target="_blank">скачать исходный код</a>, чтобы работать в вашем собственном редакторе. Это страница с кодом HTML и CSS внутри него. Если вам так удобнее, вы можете переместить CSS в отдельный файл на вашем компьютере. Или вы можете использовать онлайн-редакторы, такие как <a class="external" target="_blank">CodePen</a>, <a class="external" target="_blank">jsFiddle</a> или <a class="external" target="_blank">Glitch</a>.</p>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> Если у вас не получается, попросите о помощи — читайте раздел <a>Помощь</a> с кодом ниже.</p>\n</div></div></section><section aria-labelledby="работа_с_css"><h2 id="работа_с_css"><a>Работа с CSS</a></h2><div class="section-content"><p>В следующем примере демонстрируется биография, стилизованная с помощью CSS. Каждое использованное мной свойство CSS — ссылка на соответствующую страницу MDN.</p>\n<ul>\n  <li><a><code>font-family</code></a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>color</code> <small>(en-US)</small></a></li>\n  <li><a><code>border-bottom</code></a></li>\n  <li><a><code>font-weight</code></a></li>\n  <li><a><code>font-size</code></a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>text-decoration</code> <small>(en-US)</small></a></li>\n</ul>\n<p>Я использовал разные селекторы, такие как h1 и h2, а также создал класс для названия профессии для его стилизации.</p>\n<p>Измените значения свойств CSS, чтобы поменять внешний вид биографии.</p>\n<ol>\n  <li>Сделайте заголовок розовым, используя CSS-цвет <code>hotpink</code>.</li>\n  <li>Значение свойства заголовка <a><code>border-bottom</code></a> сделайте пунктирным (10px dotted) и добавьте цвет <code>purple</code>.</li>\n  <li>Примените к подзаголовку <code>&lt;h2&gt;</code> курсив.</li>\n  <li>Установите цвет <code>#eeeeee</code> для фона <a><code>background-color</code></a> маркированного списка с контактными данными и значение 5px solid purple для <a><code>border</code></a>. Используйте <a><code>padding</code></a>, чтобы отделить содержимое блока от границы.</li>\n  <li>Сделайте ссылки <code>зелёными</code> при наведении.</li>\n</ol>\n<p>У вас должно получиться примерно как-то так:</p>\n<p>\n  \n</p>\n<p>После этого попробуйте использовать селекторы, не указанные здесь, но описанные в <a>Руководстве по CSS</a>. Не бойтесь ошибок — практикуйтесь!</p>\n<p>Помните: тут нет неверного решения — сейчас вы предоставлены сами себе; развлекайтесь!</p></div></section><section aria-labelledby="помощь"><h2 id="помощь"><a>Помощь</a></h2><div class="section-content"><p>Если вы хотите, чтобы вашу работу оценили, или вы не справляетесь, и вам нужна помощь:</p>\n<ol>\n  <li>Загрузите ваш код на <a class="external" target="_blank">CodePen</a>, <a class="external" target="_blank">jsFiddle</a> или <a class="external" target="_blank">Glitch</a>.</li>\n  <li>Напишите пост с просьбой о помощи и / или оценке на <a class="external" target="_blank">форуме MDN</a>. Добавьте тег "learning" к вашему посту, чтобы нам легче было его найти. В вашем посте должны быть:\n    <ul>\n      <li>Заголовок с описанием наподобие "Assessment wanted for CSS First Steps".</li>\n      <li>Описание того, что вам нужно, — к примеру, что вы уже пробовали, что у вас не получается и вам нужна помощь.</li>\n      <li>Ссылка на ваш код в онлайн-редакторе.</li>\n      <li>Ссылка на страницу о помощи, чтобы мы смогли помочь вам с вашим вопросом.</li>\n    </ul>\n  </li>\n</ol></div></section><section aria-labelledby="что_дальше"><h2 id="что_дальше"><a>Что дальше?</a></h2><div class="section-content"><p>Поздравляем вас с завершением первого модуля! Теперь вы неплохо разбираетесь в CSS и можете разобраться в таблицах стилей. В следующем модуле, <a>Как устроен CSS</a>, мы глубже разберёмся в некоторых аспектах языка.</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Устройство CSS',
		
		content:
			'<header><h1>Устройство CSS</h1></header><div class="section-content"><p>Этот модуль — продолжение раздела <a>Введение в CSS</a>: вы уже знакомы с синтаксисом языка и опробовали основные функции; пришло время углубиться в CSS. В этом модуле рассматриваются каскады и наследование, все доступные типы селекторов, блоков, изменений размеров, фонов, границ, а также отладка и многое другое.</p>\n<p>Наша цель в этом модуле — обеспечить вас необходимым набором инструментов для написания хорошего CSS-кода, а также помочь вам понять необходимую теорию для перехода к особым дисциплинам, таким как <a>стилизация текста</a> и <a>размещение элементов с помощью CSS</a>.</p></div><section aria-labelledby="необходимые_умения"><h2 id="необходимые_умения"><a>Необходимые умения</a></h2><div class="section-content"><p>Перед изучением этого раздела вы должны иметь:</p>\n<ol>\n  <li>Стандартную рабочую среду (<a>Установке базового программного обеспечения</a>), а также понимание того, как создавать файлы и работать с ними (<a>Работа с файлами</a>).</li>\n  <li>Общее представление о HTML (модуль <a>Введение в HTML</a>).</li>\n  <li>Общее представление о CSS (модуль <a>Начало работы с CSS</a>).</li>\n</ol>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> Если вы работаете на компьютере/планшете/другом устройстве, где нет возможности создавать файлы, вы можете опробовать примеры (большую часть) на таких онлайн-программах, как <a class="external" target="_blank">JSBin</a> или <a class="external" target="_blank">Thimble</a>.</p>\n</div></div></section><section aria-labelledby="руководства"><h2 id="руководства"><a>Руководства</a></h2><div class="section-content"><p>В этом модуле содержатся следующие статьи, в которых рассказывается об основных составляющих языка. По мере обучения вы встретите упражнения, позволяющие вам усвоить пройденный материал.</p>\n<dl>\n  <dt id="каскад_и_наследование"><a>Каскад и наследование</a></dt>\n  <dd>\n    <p>Цель данного урока — углубить ваше понимание основных концепций CSS — каскадов, спецификаций и наследования, — которые контролируют, как CSS добавляется в HTML и как разрешаются конфликты.</p>\n  </dd>\n  <dt id="css-селекторы"><a>CSS-селекторы</a></dt>\n  <dd>\n    <p>Существует широкий выбор CSS-селекторов, позволяющий максимально точно отбирать элементы для стилизации. В этой статье и её подстатьях мы рассмотрим разные типы в мельчайших подробностях и увидим как они работают. Подстатьи по порядку:</p>\n    <ul>\n      <li><a>Селекторы типа, класса и ID</a></li>\n      <li><a>Селекторы атрибутов</a></li>\n      <li><a>Псевдоклассы, псевдоэлементы</a></li>\n      <li><a>Комбинации селекторов</a></li>\n    </ul>\n  </dd>\n  <dt id="блоки_в_css"><a>Блоки в CSS</a></dt>\n  <dd>\n    <p>Всё в CSS имеет форму блока, и понимание блоков позволяет вам размещать элементы с помощью CSS или согласовывать их друг с другом. В этом уроке мы как следует рассмотрим <em>CSS-блоки.</em></p>\n  </dd>\n  <dt id="фон_и_границы"><a>Фон и границы</a></dt>\n  <dd>\n    <p>В этом уроке мы рассмотрим всякие интересные вещи, которые вы можете делать благодаря CSS-фонам и границам, — от добавления градиентов и фоновых изображений до скругления углов, фонов и границ.</p>\n  </dd>\n  <dt id="изменение_направления_текста"><a>Изменение направления текста</a></dt>\n  <dd>\n    <p>Раньше CSS развивался, чтобы лучше поддерживать разные <strong>режимы написания</strong>, включая <em>справа налево</em> или <em>сверху вниз</em> (как в японском языке). Мы рассмотрим их в этой статье.</p>\n  </dd>\n  <dt id="перекрытие_содержимого"><a>Перекрытие содержимого</a></dt>\n  <dd>\n    <p>В этом уроке мы рассмотрим ещё одну важную концепцию CSS — <strong>overflow</strong>. Переполнение происходит, когда слишком много информации находится в пределах ограниченного блока. В этой статье мы рассмотрим, как это исправить.</p>\n  </dd>\n  <dt id="значения_свойств_css"><a>Значения свойств CSS</a></dt>\n  <dd>\n    <p>У каждого CSS-свойства есть значения. В этом уроке мы рассмотрим основные значения и их единицы.</p>\n  </dd>\n  <dt id="изменение_размеров_в_css"><a>Изменение размеров в CSS</a></dt>\n  <dd>\n    <p>В предыдущих уроках вы встречались с различными способами изменения размеров элементов с использованием CSS. В этой статье мы собрали разные способы изменить размер через CSS.</p>\n  </dd>\n  <dt id="элементы_изображений_форм_и_медиа-элементы"><a>Элементы изображений, форм и медиа-элементы</a></dt>\n  <dd>\n    <p>Мы рассмотрим, как некоторые элементы относятся к CSS. Изображения, формы и другие медиа-элементы ведут себя по-другому, когда вы стилизуете их через CSS. Некоторые функции могут не работать, поэтому в этой статье мы рассмотрим то, что вам нужно знать про эти элементы.</p>\n  </dd>\n  <dt id="стилизация_таблиц"><a>Стилизация таблиц</a></dt>\n  <dd>\n    <p>Стилизация HTML таблиц — это не самая гламурная работа в мире, но иногда нам нужно это делать. Эта статья описывает, как сделать, чтобы Ваши HTML-таблицы выглядели хорошо, и некоторые свойства, подробно рассмотренные в предыдущих статьях.</p>\n  </dd>\n  <dt id="отладка_css"><a>Отладка CSS</a></dt>\n  <dd>\n    <p>При написании CSS вы можете столкнуться с тем, что ваш CSS-код работает не так, как вы того хотели. Вы узнаете, как отлаживать CSS и как с помощью инструментов разработчика понять, где неполадка.</p>\n  </dd>\n  <dt id="организация_css-кода"><a class="only-in-en-us" title="Currently only available in English (US)">Организация CSS-кода <small>(en-US)<small></small></small></a></dt>\n  <dd>\n    <p>Как только вы начнёте работать над большими проектами и таблицами стилей, вы поймёте, что обслуживать такие таблицы не так-то и легко. В статье мы рассмотрим, как лучше писать CSS, чтобы его было легче обслуживать.</p>\n  </dd>\n</dl></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Селекторы CSS',
		
		content:
			'<header><h1>Селекторы CSS</h1></header><div class="section-content">\n<p>В <a>CSS</a>-селекторы используются для стилизации <a>HTML</a> элементов на веб-странице. Существует широкий выбор CSS-селекторов, позволяющий максимально точно отбирать элементы для стилизации. В этой статье и её подстатьях мы в мельчайших подробностях рассмотрим разные их типы и увидим, как они работают.</p>\n</div><section aria-labelledby="что_такое_селекторы"><h2 id="что_такое_селекторы"><a>Что такое селекторы?</a></h2><div class="section-content"><p>Вы уже встречались с селекторами. Это выражения, которые говорят браузеру, к какому элементу HTML нужно применить те или иные свойства CSS, определённые внутри блока объявления стиля.</p>\n<p>\n  \n</p>\n<p>Ранее вы встречали несколько разных селекторов и узнали, что существуют селекторы, которые по-разному относятся к документу, — например используя элемент <code>h1</code> или класс <code>.special</code>.</p>\n<p>В CSS селекторы определяются в спецификации CSS-селекторов; как и другие части CSS, нужно поддерживать их работу в браузерах. Большинство селекторов, которые вы встретите, определены в <a class="external" target="_blank">Спецификации селекторов 3 уровня</a>, где вы сможете найти всю информацию о поддержке селекторов в браузерах.</p></div></section><section aria-labelledby="несколько_селекторов"><h2 id="несколько_селекторов"><a>Несколько селекторов</a></h2><div class="section-content"><p>Несколько селекторов, использующих одни и те же таблицы стилей, можно объединить в <em>лист селекторов</em>: правило будет добавлено к каждому селектору. К примеру, у меня есть одинаковые правила для заголовка <code>h1</code> и класса <code>.special</code>; я могу написать их так:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">h1 {\n  color: blue;\n}\n\n.special {\n  color: blue;\n}\n</pre></div>\n<p>А могу написать короче — просто отделив селекторы запятыми:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">h1, .special {\n  color: blue;\n}\n</pre></div>\n<p>Пробел можно вставлять до или после запятой. Ещё удобнее писать каждый селектор с новой строки:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">h1,\n.special {\n  color: blue;\n}\n</pre></div>\n<p>В упражнении ниже объедините два селектора в одном правиле. Результат должен остаться таким же.</p>\n<p>При объединении селекторов таким образом, при условии если хоть один селектор будет недействительным, всё правило будет пропущено.</p>\n<p>В примере ниже правило для селектора класса не будет работать, в то время как <code>h1</code> будет стилизован.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">h1 {\n  color: blue;\n}\n\n..special {\n  color: blue;\n}\n</pre></div>\n<p>Но если мы объединим селекторы, правило не применится ни к <code>h1</code>, ни к классу: оно считается недействительным.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">h1,\n..special {\n  color: blue;\n}\n</pre></div></div></section><section aria-labelledby="типы_селекторов"><h2 id="типы_селекторов"><a>Типы селекторов</a></h2><div class="section-content"><p>Понимание того, какой именно селектор вам нужен, очень помогает подобрать подходящий элемент. Сейчас мы разберём разные виды селекторов.</p></div></section><section aria-labelledby="селекторы_тегов_классов_и_идентификаторов"><h3 id="селекторы_тегов_классов_и_идентификаторов"><a>Селекторы тегов, классов и идентификаторов</a></h3><div class="section-content"><p>К этой группе относятся селекторы HTML-элементов, таких как <code>&lt;h1&gt;</code>.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">h1 {\n}\n</pre></div>\n<p>К группе относятся и селекторы классов:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.box {\n}\n</pre></div>\n<p>или селекторы идентификаторов (ID):</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">#unique {\n}\n</pre></div></div></section><section aria-labelledby="селекторы_атрибутов"><h3 id="селекторы_атрибутов"><a>Селекторы атрибутов</a></h3><div class="section-content"><p>Эта группа селекторов позволяет выбирать селекторы, основываясь на <em>наличии</em> у них конкретного атрибута элемента:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">a[title] {\n}\n</pre></div>\n<p>или основываясь на <em>значении</em> атрибута:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">a[href="https://example.com"]\n{\n}\n</pre></div></div></section><section aria-labelledby="псевдоклассы_псевдоэлементы"><h3 id="псевдоклассы_псевдоэлементы"><a>Псевдоклассы, псевдоэлементы</a></h3><div class="section-content"><p>К этой группе относятся псевдоклассы, которые стилизуют определённое состояние элемента. Псевдокласс <code>:hover</code>, например, применяет правило, только если на элемент наведён курсор мыши</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">a:hover {\n}\n</pre></div>\n<p>К группе ещё относятся псевдоэлементы, которые выбирают определённую часть элемента (вместо целого элемента). Например, <code>::first-line</code> всегда выбирает первую строку внутри элемента (абзаца <code>&lt;p&gt;</code> в нашем случае), действуя, как если бы тег <code>&lt;span&gt;</code> оборачивал первую строку, а затем был стилизован.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">p::first-line {\n}\n</pre></div></div></section><section aria-labelledby="комбинаторы"><h3 id="комбинаторы"><a>Комбинаторы</a></h3><div class="section-content"><p>И последняя группа селекторов: она позволяет объединять селекторы, чтобы было легче находить конкретные элементы внутри документа. В следующем примере мы отыскали дочерний элемент <code>&lt;article&gt;</code> с помощью комбинатора дочерних элементов (<code>&gt;</code>):</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">article &gt; p {\n}\n</pre></div></div></section><section aria-labelledby="продолжение"><h2 id="продолжение"><a>Продолжение</a></h2><div class="section-content"><p>Ниже можно просмотреть таблицу различных видов селекторов с соответствующими ссылками, или вы можете двинуться дальше: нас ждут <a>селекторы тегов, классов и идентификаторов</a>.</p></div></section><section aria-labelledby="справка_о_селекторах"><h2 id="справка_о_селекторах"><a>Справка о селекторах</a></h2><div class="section-content"><p>В таблице ниже — доступные сейчас селекторы, а также ссылки к страницам, где рассказывается, как использовать каждый из них. Я также добавил ссылки на страницы MDN для каждого селектора, чтобы вы могли проверить, поддерживаются ли они браузерами.</p>\n</div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Селекторы типа, класса и ID',
		
		content:
			'<header><h1>Селекторы типа, класса и ID</h1></header><div class="section-content">\n<p>В этом уроке мы рассмотрим некоторые из базисных селекторов, которые вы, вероятно, будете чаще всего использовать в вашей работе.</p>\n</div><section aria-labelledby="селекторы_типа"><h2 id="селекторы_типа"><a>Селекторы типа</a></h2><div class="section-content"><p><strong>Селектор типа</strong> иногда называется <em>селектором имени тега</em> или <em>селектором элемента</em>, поскольку он выбирает тег/элемент HTML в вашем документе. В примере ниже мы использовали селекторы span, em и strong.</p>\n<p><strong>Попробуйте добавить CSS-правило, чтобы выбрать элемент <code>&lt;h1&gt;</code> и изменить его цвет на синий.</strong></p></div></section><section aria-labelledby="универсальный_селектор"><h2 id="универсальный_селектор"><a>Универсальный селектор</a></h2><div class="section-content"><p>Универсальный селектор обозначается звёздочкой (<code>*</code>). Он выбирает всё в документе (или внутри родительского элемента, если он сцеплен с другим элементом и с комбинатором потомка). В следующем примере мы используем универсальный селектор, чтобы убрать внешние отступы у всех элементов. Несмотря на стилизацию по умолчанию, добавленную браузером, — она раздвигает заголовки и абзацы с помощью отступов, — всё плотно сжато.</p>\n<p>Такого рода поведение иногда можно увидеть в «таблицах сброса стилей», которые вычищают всю стилизацию браузера. Так как универсальный селектор вызывает глобальные изменения, мы используем его в очень специфических ситуациях, таких как та, что описана ниже.</p></div></section><section aria-labelledby="использование_универсального_селектора_для_облегчения_чтения_ваших_селекторов"><h3 id="использование_универсального_селектора_для_облегчения_чтения_ваших_селекторов"><a>Использование универсального селектора для облегчения чтения ваших селекторов</a></h3><div class="section-content"><p>Одно из применений универсального селектора состоит в том, чтобы облегчить чтение селекторов и сделать их более удобопонятными с точки зрения того, что они делают. Например, если мы хотим выбрать элементы-потомки элемента <code>&lt;article&gt;</code>, которые являются первыми дочерними элементами своего родителя, включая дочерние элементы самого <code>&lt;article&gt;</code>, и сделать их шрифт жирным, мы могли бы использовать псевдокласс <a><code>:first-child</code></a>, который мы будем изучать в уроке о <a>псевдоклассах и псевдо-элементах</a>, как селектор-потомок вместе с селектором элемента <code>&lt;article&gt;</code>:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">article :first-child {\n  font-weight: bold;\n}\n</pre></div>\n<p>Однако этот селектор можно спутать с <code>article:first-child</code>, который выберет любой элемент <code>&lt;article&gt;</code>, являющийся первым дочерним элементом другого элемента .</p>\n<p>Чтобы избежать этой путаницы, мы можем добавить универсальный селектор в псевдокласс <code>:first-child</code> , чтобы было очевидно, что делает селектор. Он выбирает <em>любой</em> элемент, который является первым дочерним элементом элемента <code>&lt;article&gt;</code> или первым дочерним элементом любого потомка элемента <code>&lt;article&gt;</code>:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">article *:first-child {\n  font-weight: bold;\n}\n</pre></div>\n<p>Хотя оба делают одно и то же, удобочитаемость значительно улучшилась.</p></div></section><section aria-labelledby="селекторы_класса"><h2 id="селекторы_класса"><a>Селекторы класса</a></h2><div class="section-content"><p>Селектор класса начинается с символа точки (<code>.</code>). Он выберет в документе всё, к чему применён этот класс. В живом примере ниже мы создали класс с именем <code>.highlight</code>, и применили его к нескольким местам в документе. Все элементы, к которым применён класс, подсвечиваются.</p></div></section><section aria-labelledby="нацеливание_классов_на_отдельные_элементы"><h3 id="нацеливание_классов_на_отдельные_элементы"><a>Нацеливание классов на отдельные элементы</a></h3><div class="section-content"><p>Вы можете создать селектор, нацеленный на конкретные элементы, к которым применён класс. В следующем примере мы подсветим <code>&lt;span&gt;</code> с классом <code>highlight</code> иначе, чем заголовок <code>&lt;h1&gt;</code> с классом <code>highlight</code>. Мы сделаем это, используя селектор типа для элемента, на который нацелены, с классом, добавленным с помощью точки, без пробела между ними.</p>\n<p>Этот подход сужает границы правила. Правило будет применяться только к этой конкретной комбинации элемента и класса. Вам нужно будет добавить другой селектор, если вы решили, что правило должно применяться и к другим элементам.</p></div></section><section aria-labelledby="нацеливание_на_элемент_к_которому_применено_более_одного_класса"><h3 id="нацеливание_на_элемент_к_которому_применено_более_одного_класса"><a>Нацеливание на элемент, к которому применено более одного класса</a></h3><div class="section-content"><p>Вы можете применить несколько классов к элементу и нацелиться на них по отдельности, или выбрать элемент только если присутствуют все классы селектора. Это может быть полезно при создании компонентов, которые могут сочетаться на вашем сайте разными способами.</p>\n<p>В примере ниже у нас есть <code>&lt;div&gt;</code>, содержащий примечание. Серая граница применяется когда блок имеет класс <code>notebox</code>. Если у блока есть также класс <code>warning</code> или <code>danger</code>, мы меняем <a class="only-in-en-us" title="Currently only available in English (US)"><code>border-color</code> <small>(en-US)</small></a>.</p>\n<p>Мы можем указать браузеру, что мы хотим подобрать только такой элемент, к которому применены два класса, сцепив их вместе без пробелов между ними. Вы увидите, что к последнему <code>&lt;div&gt;</code> не применён ни один стиль, так как он имеет только класс <code>danger</code>; ему нужен ещё и класс <code>notebox</code>, чтобы получить какую-нибудь стилизацию.</p></div></section><section aria-labelledby="селекторы_id"><h2 id="селекторы_id"><a>Селекторы ID</a></h2><div class="section-content"><p>Селектор ID начинается с <code>#</code>, а не с точки, но используется так же, как и селектор класса. Однако ID может быть использован единожды на странице, и к элементу может быть применён только один <code>id</code>. Можно выбрать элемент, которому присвоен <code>id</code>, а также вы можете предварить ID селектором типа для нацеливания на элемент, имеющий соответствующее сочетание элемента и ID. Вы можете увидеть оба варианта использования в следующем примере:</p>\n<blockquote>\n  <p>**Предупреждение:**Может показаться, что неоднократное использование в документе одного и того же ID выполняет задачи стилизования, но не стоит этого делать. Результатом будет неверный код, который приведёт к многочисленным странностям в поведении.</p>\n</blockquote>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> Как мы знаем из урока по специфичности, ID имеет высокую специфичность. Он будет брать верх над большинством других селекторов. В большинстве случаев предпочтительнее добавить элементу класс, чем ID. Однако, если использование ID это единственный способ нацелиться на элемент — возможно, потому вы не имеете доступа к разметке и, следовательно, возможности её редактировать — это будет работать.</p>\n</div></div></section><section aria-labelledby="в_следующей_статье"><h2 id="в_следующей_статье"><a>В следующей статье</a></h2><div class="section-content"><p>Мы продолжим изучение селекторов и рассмотрим <a>селекторы атрибута</a>.</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Селекторы атрибута',
		
		content:
			'<header><h1>Селекторы атрибута</h1></header><div class="section-content">\n<p>Как вы знаете из курса о HTML, элементы могут иметь атрибуты, которые дают дополнительную информацию о размечаемом элементе. В CSS вы можете использовать селекторы атрибута для стилизации элементов с определёнными атрибутами. Этот урок покажет вам, как использовать эти очень полезные селекторы.</p>\n</div><section aria-labelledby="селекторы_наличия_и_значения"><h2 id="селекторы_наличия_и_значения"><a>Селекторы наличия и значения</a></h2><div class="section-content"><p>Эти селекторы делают возможным выбор элемента, основанный только на наличии атрибута (например, <code>href</code>) или на всевозможных разного рода сочетаниях со значением атрибута.</p>\n\n<p>В приведённом ниже примере вы можете увидеть использование этих селекторов.</p>\n<ul>\n  <li>Используя <code>li[class],</code> мы можем выбрать каждый селектор с атрибутом класса. Это соответствует всем пунктам списка, за исключением первого.</li>\n  <li><code>li[class="a"]</code> выбирает селектор с классом <code>a</code>, но не селектор с классом <code>a</code> в сочетании с другим, отделённым запятой, классом как частью значения. Он выбирает второй пункт списка.</li>\n  <li><code>li[class~="a"]</code> выберет класс <code>a</code>, а также значение, которое содержит класс <code>a</code> как часть разделённого пробелом списка. Он выберет второй и третий пункты списка.</li>\n</ul></div></section><section aria-labelledby="селекторы_вхождения_подстроки"><h2 id="селекторы_вхождения_подстроки"><a>Селекторы вхождения подстроки</a></h2><div class="section-content"><p>Эти селекторы предоставляют более широкие возможности для выявления вхождения подстроки в значение атрибута. Например, если у вас есть классы <code>box-warning</code> и <code>box-error</code> и вы хотите выбрать всё, что начинается со строки "box-", вы можете использовать <code>[class^="box-"]</code>, чтобы выбрать оба класса (или <code>[class|="box"]</code> как описано в предыдущем разделе).</p>\n\n<p>(Отступление: возможно, будет полезным заметить, что <code>^</code> и <code>$</code> давно используются как <em>якоря</em> в так называемых <em>регулярных выражениях</em> и обозначают <em>начинается с</em> и <em>заканчивается на</em>.)</p>\n<p>Следующий пример показывает, как используются эти селекторы:</p>\n<ul>\n  <li><code>li[class^="a"]</code> выбирает все значения атрибута, которые начинаются с <code>a</code>, что соответствует первым двум элементам списка.</li>\n  <li><code>li[class$="a"]</code> выбирает все значения атрибута, которые заканчиваются на <code>a</code>, что соответствует первому и третьему элементу списка.</li>\n  <li><code>li[class*="a"]</code> выбирает все значения атрибута, где появляется <code>a</code>, независимо от положения в строке, что соответствует всем элементам нашего списка.</li>\n</ul></div></section><section aria-labelledby="чувствительность_к_регистру"><h2 id="чувствительность_к_регистру"><a>Чувствительность к регистру</a></h2><div class="section-content"><p>Если вы хотите выбрать значения атрибута без учёта регистра, вы можете использовать значение <code>i</code> перед закрывающей скобкой. Этот признак говорит браузеру, что символы ASCII должны сопоставляться без учёта регистра. Без этого признака значения будут сопоставлены в соответствии с чувствительностью к регистру языка документа — в случае HTML такая чувствительность присутствует.</p>\n<p>В примере ниже первый селектор выберет значение, начинающееся с <code>a</code> — это соответствует только первому элементу списка, потому что два других элемента списка начинаются с заглавной буквы A. Второй селектор использует признак нечувствительности к регистру и поэтому выберет все элементы списка.</p>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> Существует также более новое значение <code>s</code>, которое вызывает сопоставление с учётом регистра в контекстах, где сопоставление обычно не учитывает регистр, однако это не так хорошо поддерживается в браузерах и не очень полезно в контексте HTML.</p>\n</div></div></section><section aria-labelledby="следующие_шаги"><h2 id="следующие_шаги"><a>Следующие шаги</a></h2><div class="section-content"><p>Итак, мы рассмотрели селекторы атрибута, и вы можете перейти к следующей статье, в которой рассказывается о <a>псевдоклассах и псевдоэлементах</a>.</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Псевдоклассы, псевдоэлементы',
		
		content:
			'<header><h1>Псевдоклассы, псевдоэлементы</h1></header><div class="section-content">\n<p>Следующий набор селекторов, который мы рассмотрим, относится к псевдоклассам и псевдоэлементам. Их очень много, и они часто служат довольно специфическим целям. После того как вы узнаете порядок их использования, просмотрите список — не найдётся ли в нём что-либо, что поможет решить стоящую перед вами задачу. Кроме того, будет полезным заглянуть на соответствующую каждому селектору страницу MDN, чтобы прояснить, как его обрабатывает браузер.</p>\n</div><section aria-labelledby="что_такое_псевдокласс"><h2 id="что_такое_псевдокласс"><a>Что такое псевдокласс?</a></h2><div class="section-content"><p>Псевдокласс — это селектор, который выбирает элементы, находящиеся в специфическом состоянии, например, они являются первым элементом своего типа, или на них наведён указатель мыши. Они обычно действуют так, как если бы вы применили класс к какой-то части вашего документа, что часто помогает сократить избыточные классы в разметке и даёт более гибкий, удобный в поддержке код.</p>\n<p>Псевдоклассы — это ключевые слова, которые начинаются с двоеточия:</p>\n<pre compile="false" disable="true" language="markup">:pseudo-class-name\n</pre></div></section><section aria-labelledby="простой_пример_псевдокласса"><h3 id="простой_пример_псевдокласса"><a>Простой пример псевдокласса</a></h3><div class="section-content"><p>Давайте рассмотрим простой пример. Если бы мы хотели сделать шрифт первого абзаца статьи более крупным и жирным, мы могли бы добавить класс к этому абзацу, а затем добавить CSS к этому классу, как показано в первом примере ниже:</p>\n<p>Однако поддержка может оказаться утомительной — что если новый абзац будет добавлен в верхнюю часть документа? Тогда нам нужно будет передвинуть класс к новому абзацу. Вместо добавления класса мы могли бы использовать селектор псевдокласса <a><code>:first-child</code></a> — он всегда будет нацелен на первый дочерний элемент в статье, и нам больше не нужно будет редактировать HTML (к тому же это не всегда возможно, например, в случае если он генерируется CMS.)</p>\n<p>Все псевдоклассы ведут себя подобным образом. Они нацелены на какой-то фрагмент вашего документа, находящийся в определённом состоянии, и ведут себя так, как если бы вы добавили класс в свой HTML. Рассмотрим некоторые другие примеры в MDN:</p>\n<ul>\n  <li><a><code>:last-child</code></a></li>\n  <li><a><code>:only-child</code></a></li>\n  <li><a><code>:invalid</code></a></li>\n</ul>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> Правильно писать псевдоклассы и элементы без какого бы то ни было предшествующего им селектора элемента. В примере выше вы могли бы написать <code>:first-child</code> и правило было бы применено к <em>любому</em> элементу, оказавшемуся первым дочерним для <code>&lt;article&gt;</code>, не только к первому дочернему абзацу — <code>:first-child</code> равнозначно <code>*:first-child</code>. Однако обычно вы хотите б<em>о</em>льшего контроля, поэтому вам нужен более специфичный селектор.</p>\n</div></div></section><section aria-labelledby="псевдоклассы_пользовательского_действия"><h3 id="псевдоклассы_пользовательского_действия"><a>Псевдоклассы пользовательского действия</a></h3><div class="section-content"><p>Некоторые псевдоклассы применяются только тогда, когда пользователь некоторым образом взаимодействует с документом. Эти псевдоклассы действий пользователя, иногда называемые динамическими псевдоклассами, действуют так, как если бы класс был добавлен к элементу в момент взаимодействия с ним пользователя. Примеры даны для:</p>\n<ul>\n  <li><a><code>:hover</code></a> — упоминался выше; он применяется только в том случае, если пользователь наводит указатель мыши на элемент, обычно на ссылку.</li>\n  <li><a><code>:focus</code></a> — применяется только в том случае, если пользователь фокусируется на элементе, используя управление с клавиатуры.</li>\n</ul></div></section><section aria-labelledby="что_такое_псевдоэлемент"><h2 id="что_такое_псевдоэлемент"><a>Что такое псевдоэлемент?</a></h2><div class="section-content"><p>Псевдоэлементы ведут себя сходным образом, однако они действуют так, как если бы вы добавили в разметку целый новый HTML-элемент, а не применили класс к существующим элементам. Псевдоэлементы начинаются с двойного двоеточия <code>::</code>.</p>\n<pre compile="false" disable="true" language="markup">::pseudo-element-name\n</pre>\n<div class="notecard note" id="sect2">\n  <p><strong>Примечание:</strong> Некоторые ранние псевдоэлементы использовали синтаксис одинарного двоеточия, которое вы можете иногда видеть в коде или примерах. Современные браузеры поддерживают ранние псевдоэлементы с одинарным или двойным двоеточием синтаксиса для обратной совместимости.</p>\n</div>\n<p>Например, если вы хотите выбрать первую строку абзаца, вы могли бы обернуть её в <code>&lt;span&gt;</code> и использовать селектор элемента; однако это может не сработать, если количество слов, которые вы обернули, будет больше или меньше ширины родительского элемента. Поскольку мы, как правило, не знаем, сколько слов поместится в строке — т.к. их количество меняется, если меняется ширина экрана или размер шрифта — то надёжного решения при помощи HTML нет.</p>\n<p>Селектор псевдоэлемента <code>::first-line</code> сделает это наверняка — если количество слов увеличивается или уменьшается, он всё равно будет выбирать только первую строку.</p>\n<p>Он действует так, как если бы <code>&lt;span&gt;</code> волшебным образом был обёрнут вокруг этой первой отформатированной строки и обновлялся бы каждый раз при изменении длины строки.</p>\n<p>Вы можете видеть, что селектор выбирает первую строку обоих абзацев.</p></div></section><section aria-labelledby="объединение_псевдоклассов_и_псевдоэлементов"><h2 id="объединение_псевдоклассов_и_псевдоэлементов"><a>Объединение псевдоклассов и псевдоэлементов</a></h2><div class="section-content"><p>Если вы хотите сделать шрифт первой строки первого абзаца жирным, вы можете связать вместе селекторы <code>:first-child</code> и <code>::first-line</code>. Попробуйте отредактировать предыдущий живой пример, чтобы использовалась следующая CSS. Мы говорим, что хотим выбрать первую строку первого элемента <code>&lt;p&gt;,</code> который находится внутри элемента <code>&lt;article&gt;</code>.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">article p:first-child::first-line {\n  font-size: 120%;\n  font-weight: bold;\n}\n</pre></div></div></section><section aria-labelledby="генерация_контента_с_помощью_before_и_after"><h2 id="генерация_контента_с_помощью_before_и_after"><a>Генерация контента с помощью ::before и ::after</a></h2><div class="section-content"><p>Существует пара специальных псевдоэлементов, которые используются вместе со свойством <a><code>content</code></a> для вставки содержимого в документ с помощью CSS.</p>\n<p>Вы можете использовать их для вставки строки текста, как в приведённом ниже живом примере. Попробуйте изменить текстовое значение свойства <a><code>content</code></a> и вы увидите, как изменится результат. Можете также изменить псевдоэлемент <code>::before</code> на <code>::after</code> и увидите, что текст вставлен в конце элемента, а не в начале.</p>\n<p>Однако вставка строк текста из CSS в реальности происходит не слишком часто, поскольку этот текст недоступен для некоторых экранных дикторов и его будет трудно найти и отредактировать в будущем.</p>\n<p>Более корректным использованием этих псевдоэлементов является вставка значка, например маленькой стрелки, добавленной в приведённом ниже примере, которая является визуальным указателем, не предназначенным для зачитывания с помощью экранного диктора:</p>\n<p>Эти псевдоэлементы также часто используются для вставки пустой строки, которая затем может быть стилизована так же, как и любой элемент на странице.</p>\n<p>В следующем примере мы добавили пустую строку, используя псевдоэлемент <code>::before.</code> Мы установили <code>display: block</code>, чтобы стилизовать его по ширине и высоте. Затем мы используем CSS, чтобы стилизовать его так же, как и любой другой элемент. Вы можете поиграть с CSS и изменить его внешний вид и поведение.</p>\n<p>Использование псевдоэлементов <code>::before</code> и <code>::after</code> вместе со свойством <code>content</code> в CSS называется "генерируемым контентом" в CSS, и вы часто будете видеть, как этот метод используется для различных задач. Отличным примером является сайт <a class="external" target="_blank">CSS Arrow Please</a>, который помогает вам генерировать стрелку с помощью CSS. Посмотрите на CSS, когда вы создадите свою стрелку, и вы увидите использование псевдо-элементов <a><code>::before</code></a> и <a><code>::after</code></a>. Всякий раз, когда вы будете видеть эти селекторы, смотрите на свойство <a><code>content</code></a>, чтобы увидеть, что добавляется в документ..</p></div></section><section aria-labelledby="справочный_раздел"><h2 id="справочный_раздел"><a>Справочный раздел</a></h2><div class="section-content"><p>Существует большое количество псевдоклассов и псевдоэлементов, и полезно иметь список, к которому можно обращаться. Ниже приведены таблицы, в которых они перечислены, со ссылками на их справочные страницы в MDN. Используйте эти таблицы как справочник, чтобы видеть массив доступных вам средств для нацеливания на элементы.</p></div></section><section aria-labelledby="псевдоклассы"><h3 id="псевдоклассы"><a>Псевдоклассы</a></h3><div class="section-content"></div></section><section aria-labelledby="псевдоэлементы"><h3 id="псевдоэлементы"><a>Псевдоэлементы</a></h3><div class="section-content"></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Комбинаторы',
		
		content:
			'<header><h1>Комбинаторы</h1></header><div class="section-content">\n<p>Наконец мы рассмотрим селекторы, которые называются комбинаторами, поскольку они соединяют другие селекторы, создавая полезную связь селекторов друг с другом и расположением содержимого в документе.</p>\n</div><section aria-labelledby="комбинатор_потомка"><h2 id="комбинатор_потомка"><a>Комбинатор потомка</a></h2><div class="section-content"><p><strong>Селектор потомка</strong> — обычно представляется символом пробела (" ") — соединяет два селектора так, что элементы, соответствующие второму селектору, выбираются, если они имеют предка (родителя, родителя родителя, родителя родителя родителя и т.д.), соответствующего первому селектору. Селекторы, которые используют комбинатор потомка, называются <em>селекторами потомка.</em></p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">body article p\n</pre></div>\n<p>В приведённом ниже примере выбирается только тот элемент &lt;p&gt;, который находится внутри элемента с классом<code>.box</code>.</p></div></section><section aria-labelledby="дочерний_комбинатор"><h2 id="дочерний_комбинатор"><a>Дочерний комбинатор</a></h2><div class="section-content"><p><strong>Дочерний комбинатор</strong> (<code>&gt;</code>) помещается между двумя селекторами CSS. При этом будут выбраны только те элементы, соответствующие второму селектору, которые являются прямыми потомками элементов, соответствующих первому селектору. Все элементы-потомки на более низких уровнях иерархии будут пропущены. Например, чтобы выбрать только те элементы <code>&lt;p&gt;</code>, которые являются дочерними элементами <code>&lt;article&gt;</code>, селектор пишется так:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">article &gt; p\n</pre></div>\n<p>Другой пример. Имеется неупорядоченный список, заключающий в себе другой, упорядоченный список. Дочерний комбинатор используется для того, чтобы выбрать только те элементы <code>&lt;li&gt;</code>, которые являются прямыми потомками <code>&lt;ul&gt;</code>, и присвоить им верхнюю границу красного цвета.</p>\n<p>Если вы уберёте символ <code>&gt;</code>, указывающий на то, что это селектор с дочерним комбинатором, селектор превратится в селектор всех потомков (комбинатор - пробел) и все элементы <code>&lt;li&gt;</code> получат верхнюю границу красного цвета.</p></div></section><section aria-labelledby="соседний_родственный_комбинатор"><h2 id="соседний_родственный_комбинатор"><a>Соседний родственный комбинатор</a></h2><div class="section-content"><p>Соседний родственный селектор (<code>+</code>) используется для выбора элемента, который непосредственно следует за другим элементом и находится на одном с ним уровне иерархии. Например, чтобы выбрать все элементы <code>&lt;img&gt;</code> , которые идут сразу после элементов <code>&lt;p&gt;</code> :</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">p + img\n</pre></div>\n<p>Распространённый вариант использования — сделать что-то с абзацем, который следует за заголовком, как в примере ниже. Здесь мы ищем абзац, который непосредственно примыкает к <code>&lt;h1&gt;</code>, и стилизуем его.</p>\n<p>Если вы вставите какой-то другой элемент, например <code>&lt;h2&gt;</code> между <code>&lt;h1&gt;</code> и <code>&lt;p&gt;</code>, вы обнаружите, что абзац больше не соответствует селектору и поэтому не получает цвет фона и переднего плана, применяемый, когда элемент является соседним.</p></div></section><section aria-labelledby="общий_родственный_комбинатор"><h2 id="общий_родственный_комбинатор"><a>Общий родственный комбинатор</a></h2><div class="section-content"><p>Если вы хотите выбрать родственные элементы, даже если они не являются непосредственными соседями, то вы можете использовать общий родственный комбинатор (<code>~</code>). Чтобы выбрать все элементы <code>&lt;img&gt;</code>, которые находятся в <em>любом</em> месте после элементов <code>&lt;p&gt;</code>, надо указать так:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">p ~ img\n</pre></div>\n<p>В приведённом ниже примере мы выбираем все элементы <code>&lt;p&gt;</code>, которые идут после <code>&lt;h1&gt;</code>, и хотя в документе есть также <code>&lt;div&gt;</code>, тем не менее <code>&lt;p&gt;</code>, который идёт после него, будет выбран.</p></div></section><section aria-labelledby="использование_комбинаторов"><h2 id="использование_комбинаторов"><a>Использование комбинаторов</a></h2><div class="section-content"><p>Вы можете соединять с помощью комбинаторов любые селекторы, которые мы изучали в предыдущих уроках, чтобы выбрать часть вашего документа. Например, если мы хотим выбрать пункты списка с классом "a", которые являются прямыми потомками <code>&lt;ul&gt;</code>, можно использовать следующую комбинацию:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">ul &gt; li[class="a"] {\n}\n</pre></div>\n<p>Однако будьте осторожны при создании больших списков селекторов, которые выделяют очень конкретные части вашего документа. Будет трудно повторно использовать правила CSS, так как вы сделали селектор очень специфичным для определения местоположения этого элемента в разметке.</p>\n<p>Часто бывает лучше создать простой класс и применить его к рассматриваемому элементу. Тем не менее, ваши знания о комбинаторах будут очень полезны, если вам нужно добраться до чего-то в вашем документе и вы не можете получить доступ к HTML, возможно, из-за того, что он генерируется CMS.</p></div></section><section aria-labelledby="проверьте_ваши_навыки!"><h2 id="проверьте_ваши_навыки!"><a>Проверьте ваши навыки!</a></h2><div class="section-content"><p>Мы охватили много тем в этой статье. А вы можете вспомнить наиболее важную информацию? Можете пройти несколько дополнительных тестов для того чтобы убедиться в том, что вы усвоили эту информацию, прежде чем пойдёте дальше — смотрите <a>Проверьте ваши навыки: Селекторы</a>.</p></div></section><section aria-labelledby="двигаемся_дальше"><h2 id="двигаемся_дальше"><a>Двигаемся дальше</a></h2><div class="section-content"><p>Это последний раздел в наших уроках по селекторам. Далее мы перейдём к другой важной части CSS — <a>CSS модель коробки</a>.</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Каскад и наследование',
		
		content:
			'<header><h1>Каскад и наследование</h1></header><div class="section-content">\n<p>Цель этого урока — углубить ваше понимание некоторых основополагающих концепций CSS — каскадов, спецификаций и наследования, — которые контролируют то, как CSS применяется к HTML и как разрешаются конфликты.</p>\n<p>Хотя изучение этого урока может показаться менее актуальным и немного более академичным, чем некоторые другие части курса, понимание этих вещей спасёт вас от головной боли в дальнейшем! Мы рекомендуем вам внимательно изучить этот раздел и убедиться, что вы понимаете концепции, перед тем, как двигаться дальше.</p>\n</div><section aria-labelledby="конфликтующие_правила"><h2 id="конфликтующие_правила"><a>Конфликтующие правила</a></h2><div class="section-content"><p>CSS (Cascading Style Sheets) означает Каскадные Таблицы Стилей и первое слово <em>"каскадные"</em> является невероятно важным для понимания: то, как ведёт себя каскад — ключевой момент в понимании CSS.</p>\n<p>В какой-то момент, работая над проектом, вы обнаружите, что CSS, который, по-вашему, должен быть применён к элементу, не работает. Обычно проблема заключается в том, что вы создали два правила, которые могут потенциально применяться к одному и тому же элементу. <strong>Каскад</strong> и тесно связанная концепция <strong>специфичности</strong> — это механизмы, которые контролируют, какое именно правило применяется, когда имеется такой конфликт. Стиль вашего элемента может определять не то правило, на которое вы рассчитывали, поэтому вам необходимо понимать, как работают эти механизмы.</p>\n<p>Также значимой является концепция <strong>наследования,</strong> которая заключается в том, что некоторые свойства CSS наследуют по умолчанию значения, установленные для родительского элемента текущего элемента, а некоторые не наследуют. Это также может стать причиной поведения, которое вы, возможно, не ожидаете.</p>\n<p>Давайте начнём с краткого обзора ключевых моментов, которых мы касаемся, далее рассмотрим каждый из них по очереди и посмотрим, как они взаимодействуют друг с другом и с вашим CSS. Это может показаться набором сложных для понимания понятий. Однако, когда вы получите больше опыта в написании CSS, для вас станет более очевидным то, как это работает.</p></div></section><section aria-labelledby="каскад"><h3 id="каскад"><a>Каскад</a></h3><div class="section-content"><p>Каскад таблицы стилей, если говорить упрощённо, означает, что порядок следования правил в CSS имеет значение; когда применимы два правила, имеющие одинаковую специфичность, используется то, которое идёт в CSS последним.</p>\n<p>В приведённом ниже примере у нас есть два правила, которые могут применяться к h1. В результате h1 окрасится синим цветом — эти правила имеют идентичный селектор и, следовательно, одинаковую специфичность, поэтому побеждает последний в порядке следования.</p></div></section><section aria-labelledby="специфичность"><h3 id="специфичность"><a>Специфичность</a></h3><div class="section-content"><p>Специфичность определяет, как браузер решает, какое именно правило применяется в случае, когда несколько правил имеют разные селекторы, но, тем не менее, могут быть применены к одному и тому же элементу. <em>Различные типы селекторов ( селекторы элементов <code>h1{...}</code>, селекторы классов, селекторы идентификаторов и т.д ) имеют разной степени влияние на элементы страницы. Чем более общее влияние оказывает селектор на элементы страницы тем меньше его специфичность, конкретность.</em> По существу, это мера того, насколько специфическим будет отбор по селектору:</p>\n<ul>\n  <li>Селектор элементов ( <em>например <code>h1</code></em> ) менее специфичен — он выберет все элементы этого типа на странице — поэтому получит меньше баллов.</li>\n  <li>Селектор класса более специфичен — он выберет только те элементы на странице, которые имеют конкретное значение атрибута <code>class</code> — поэтому получит больше баллов, <em>селектор класса применится после селектора элемента и поэтому перекроет его стили</em>.</li>\n</ul>\n<p>Например. Как указано ниже, у нас опять есть два правила, которые могут применяться к <code>h1</code>. <code>h1</code> в результате будет окрашен красным цветом — селектор класса даёт своему правилу более высокую специфичность, поэтому он будет применён, несмотря на то, что правило для селектора элемента расположено ниже в таблице стилей.</p>\n<p>Позже мы объясним, как сделать оценку специфичности, и прочие детали.</p></div></section><section aria-labelledby="наследование"><h3 id="наследование"><a>Наследование</a></h3><div class="section-content"><p>Наследование также надо понимать в этом контексте — некоторые значения свойства CSS, установленные для родительских элементов наследуются их дочерними элементами, а некоторые нет.</p>\n<p>Например, если вы установили значение <code>color</code> и <code>font-family</code> для элемента, то каждый элемент внутри него также будет иметь этот цвет и шрифт, если только вы не применили к ним напрямую стиль с другим цветом и шрифтом.</p>\n<p>Некоторые свойства не наследуются — например, если вы установили для элемента <a><code>width</code></a> равным 50%, все его дочерние элементы не получат ширину в 50% от ширины своего родительского элемента. Если бы это было так, CSS было бы чрезвычайно трудно использовать!</p>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> На страницах справочника CSS-свойств вы можете найти окно технической информации, обычно в конце раздела спецификации, в котором перечислены некоторые технические данные об этом свойстве, в том числе наследуется оно или нет. Например, здесь: <a class="only-in-en-us" title="Currently only available in English (US)">color property Specifications section <small>(en-US)<small></small></small></a>.</p>\n</div></div></section><section aria-labelledby="понимание_взаимодействия_этих_концепций"><h2 id="понимание_взаимодействия_этих_концепций"><a>Понимание взаимодействия этих концепций</a></h2><div class="section-content"><p>Эти три концепции вместе определяют, какая CSS применяется и к какому элементу; в следующих разделах мы увидим, как они взаимодействуют. Это может показаться сложным, но вы начнёте лучше понимать их по мере приобретения опыта работы с CSS, и вы всегда можете обратиться к справочной информации, если что-то забыли. Даже опытные разработчики не помнят всех деталей!</p>\n<p>Видео ниже показывает, как вы можете использовать Firefox DevTools для проверки каскада стилей, спецификации, и т.д. на странице:</p></div></section><section aria-labelledby="понимание_наследования"><h2 id="понимание_наследования"><a>Понимание наследования</a></h2><div class="section-content"><p>Итак, наследование. В примере ниже мы имеем <a><code>&lt;ul&gt;</code></a> с двумя уровнями неупорядоченных списков, вложенных в него. Мы установили для внешнего <code>&lt;ul&gt;</code> стиль границы, внутренние отступы и цвет шрифта.</p>\n<p>Цвет шрифта применён к прямому потомку, но также и к непрямому потомку — к прямому потомку <code>&lt;li&gt;</code> и к элементам внутри первого вложенного списка. Далее мы добавили класс <code>special</code> ко второму вложенному списку и применили к нему другой цвет шрифта. Теперь это свойство наследуется всеми его потомками.</p>\n<p>Такие свойства, как ширина (как в примере выше), внутренние и внешние отступы и стиль границы не наследуются. Если бы потомки нашего списка наследовали бы границу, то каждый отдельный список и каждая позиция в списке получили бы такую же границу — вряд ли мы хотели бы получить такой эффект!</p>\n<p>Какие свойства наследуются по умолчанию, а какие нет, чаще всего определяется здравым смыслом.</p></div></section><section aria-labelledby="контроль_наследования"><h3 id="контроль_наследования"><a>Контроль наследования</a></h3><div class="section-content"><p>CSS предоставляет четыре специальных универсальных значения свойства для контроля наследования. Каждое свойство CSS принимает эти значения.</p>\n<dl>\n  <dt id="inherit"><a><code>inherit</code></a></dt>\n  <dd>\n    <p>Устанавливает значение свойства, применённого к элементу, таким же, как у его родительского элемента. Фактически, это "включает наследование".</p>\n  </dd>\n  <dt id="initial"><a><code>initial</code></a></dt>\n  <dd>\n    <p>Устанавливает значение свойства, применённого к выбранному элементу, равным <a>initial value</a> этого свойства (<em>в соответствии с настройками браузера по умолчанию. Если в таблице стилей браузера отсутствует значение этого свойства, оно наследуется естественным образом.)</em></p>\n  </dd>\n  <dt id="unset_en-us"><a class="only-in-en-us" title="Currently only available in English (US)"><code>unset</code> <small>(en-US)</small></a></dt>\n  <dd>\n    <p>Возвращает свойству его естественное значение, что означает, что если свойство наследуется естественным образом, оно действует как <code>inherit</code>, иначе оно действует как <code>initial</code>.</p>\n  </dd>\n</dl>\n<div class="notecard note" id="sect2">\n  <p><strong>Примечание:</strong> Существует также более новое значение <a><code>revert</code></a>, которое имеет ограниченную поддержку браузерами.</p>\n</div>\n<div class="notecard note" id="sect3">\n  <p><strong>Примечание:</strong> Смотрите <a class="only-in-en-us" title="Currently only available in English (US)">Origin of CSS declarations <small>(en-US)<small></small></small></a> для более подробной информации о каждом из них, и о том, как они работают.</p>\n</div>\n<p>Можно посмотреть список ссылок и изучить, как работают универсальные значения. Пример, следующий ниже, позволяет вам поиграть с CSS и увидеть, что происходит, когда вы вносите изменения. Подобные эксперименты с кодом — лучший способ освоить HTML и CSS.</p>\n<p>Например:</p>\n<ol>\n  <li>Второй элемент списка имеет класс <code>my-class-1</code>. Таким образом, цвет для следующего вложенного элемента <code>a</code> устанавливается по наследству. Как изменится цвет, если это правило будет удалено?</li>\n  <li>Понятно ли, почему третий и четвёртый элементы <code>a</code> имеют именно такой цвет? Если нет, перечитайте описание значений, представленное выше.</li>\n  <li>Какая из ссылок изменит цвет, если вы зададите новый цвет для элемента <code>&lt;a&gt;</code> — например: <code>a { color: red; }</code>?</li>\n</ol></div></section><section aria-labelledby="возврат_всех_исходных_значений_свойств"><h3 id="возврат_всех_исходных_значений_свойств"><a>Возврат всех исходных значений свойств</a></h3><div class="section-content"><p>Стенографическое свойство CSS <code>all</code> можно использовать для того, чтобы присвоить одно из значений наследования к (почти) всем свойствам одновременно. Это одно из четырёх значений (<code>inherit</code>, <code>initial</code>, <code>unset</code>, или <code>revert</code>). Это удобный способ для отмены изменений, внесённых в стили, для того, чтобы вы могли вернуться к стартовой точке перед внесением новых изменений.</p>\n<p>В примере ниже имеются два блока <code>&lt;blockquote&gt;</code>. Первый имеет стиль, который применён к самому элементу <code>blockquote</code>, второй имеет класс <code>fix-this</code>, который устанавливает значение <code>all</code> в <code>unset</code>.</p>\n<p>Попробуйте установить для <code>all</code> ещё одно из доступных значений и исследуйте, в чём заключается разница.</p></div></section><section aria-labelledby="понимание_каскада"><h2 id="понимание_каскада"><a>Понимание каскада</a></h2><div class="section-content"><p>Теперь мы понимаем, почему параграф, следующий по глубине в структуре HTML документа, имеет тот же цвет, что CSS применяет к body, а вводные уроки дали понимание того, как изменить применение CSS к чему-либо в любой точке документа — или назначить CSS элементу, или создать класс. Теперь рассмотрим подробнее то, как каскад определяет выбор CSS-правил, применяемых в случае влияния на стиль элемента нескольких объектов.</p>\n<p>Вот три фактора, перечисленные в порядке возрастания важности. Следующий отменяет предыдущий.</p>\n<ol>\n  <li><strong>Порядок следования</strong></li>\n  <li><strong>Специфичность</strong></li>\n  <li><strong>Важность</strong></li>\n</ol>\n<p>Мы внимательно изучим их, чтобы увидеть, как именно браузеры определяют, какой CSS следует применить.</p></div></section><section aria-labelledby="порядок_следования"><h3 id="порядок_следования"><a>Порядок следования</a></h3><div class="section-content"><p>Мы уже видели, какое значение для каскада имеет порядок следования. Если у вас несколько правил, которые имеют одинаковую важность, то побеждает правило, которое идёт последним в CSS. Другими словами, правила, более близкие к самому элементу, переписывают более ранние, пока последнее не победит, оно и стилизует элемент.</p></div></section><section aria-labelledby="специфичность_2"><h3 id="специфичность_2"><a>Специфичность</a></h3><div class="section-content"><p>Понимая, что порядок следования правил имеет значение, в какой-то момент вы окажетесь в ситуации, когда вы знаете, что правило появляется позже в таблице стилей, но применяется более раннее, конфликтующее правило. Это связано с тем, что более раннее правило имеет более <strong>высокую специфичность</strong> — оно более специфично и поэтому выбирается браузером как правило, которое должно стилизовать элемент.</p>\n<p>Как мы видели ранее в этом уроке, селектор класса имеет больший вес, чем селектор элемента, поэтому свойства, определённые в классе, будут переопределять свойства, применённые непосредственно к элементу.</p>\n<p>Здесь следует отметить, что, хотя мы думаем о селекторах и правилах, применяемых к объекту, который они выбирают, переписывается не всё правило, а только свойства, которые являются одинаковыми.</p>\n<p>Такое поведение помогает избежать повторения в вашем CSS. Обычной практикой является определение общих стилей для базовых элементов, а затем создание классов для тех, которые отличаются. Например, в таблице стилей ниже мы определяем общие стили для заголовков второго уровня, а затем создаём несколько классов, которые изменяют только некоторые свойства и значения. Определённые вначале значения применяются ко всем заголовкам, затем к заголовкам с классами применяются более конкретные значения.</p>\n<p>Давайте теперь посмотрим, как браузер будет вычислять специфичность. Мы уже знаем, что селектор элемента имеет низкую специфичность и может быть перезаписан классом. По существу, значение в баллах присуждается различным типам селекторов, и их сложение даёт вам вес этого конкретного селектора, который затем может быть оценён в сравнении с другими потенциальными соперниками.</p>\n<p>Степень специфичности, которой обладает селектор, измеряется с использованием четырёх различных значений (или компонентов), которые можно представить как тысячи, сотни, десятки и единицы — четыре однозначные цифры в четырёх столбцах:</p>\n<ol>\n  <li><strong>Тысячи</strong>: поставьте единицу в эту колонку, если объявление стиля находится внутри атрибута <a><code>style</code></a> (встроенные стили). Такие объявления не имеют селекторов, поэтому их специфичность всегда просто 1000.</li>\n  <li><strong>Сотни</strong>: поставьте единицу в эту колонку за каждый селектор ID, содержащийся в общем селекторе.</li>\n  <li><strong>Десятки</strong>: поставьте единицу в эту колонку за каждый селектор класса, селектор атрибута или псевдокласс, содержащийся в общем селекторе.</li>\n  <li><strong>Единицы</strong>: поставьте общее число единиц в эту колонку за каждый селектор элемента или псевдоэлемент, содержащийся в общем селекторе.</li>\n</ol>\n<div class="notecard note" id="sect4">\n  <p><strong>Примечание:</strong> Универсальный селектор (*), комбинаторы (+, &gt;, ~, \'\') и псевдокласс отрицания (:not) не влияют на специфичность.</p>\n</div>\n<p>Следующая таблица показывает несколько несвязанных примеров, которые помогут вам разобраться. Посмотрите их все и убедитесь, что вы понимаете, почему они обладают той специфичностью, которую мы им дали. Мы ещё не рассмотрели селекторы детально, но вы можете найти подробную информацию о каждом селекторе в <a>справочнике селекторов</a> MDN.</p>\n\n<p>Прежде чем мы продолжим, давайте посмотрим на пример в действии.</p>\n<p>Так что здесь происходит? Прежде всего, нас интересуют только первые семь правил этого примера, и, как вы заметите, мы включили их значения специфичности в комментарий перед каждым правилом.</p>\n<ul>\n  <li>Первые два правила конкурируют за стилизацию цвета фона ссылки — второе выигрывает и делает фоновый цвет синим, потому что у него есть дополнительный селектор ID в цепочке: его специфичность 201 против 101.</li>\n  <li>Третье и четвёртое правило конкурируют за стилизацию цвета текста ссылки — второе выигрывает и делает текст белым, потому что, хотя у него на один селектор элемента меньше, отсутствующий селектор заменяется на селектор класса, который оценивается в десять вместо единицы. Таким образом, приоритетная специфичность составляет 113 против 104.</li>\n  <li>Правила 5–7 соревнуются за определение стиля границы ссылки при наведении курсора. Шестой селектор со специфичностью 23 явно проигрывает пятому со специфичностью 24 — у него в цепочке на один селектор элемента меньше. Седьмой селектор, однако, превосходит как пятый, так и шестой — он имеет то же количество подселекторов в цепочке, что и пятый, но один элемент заменён селектором класса. Таким образом, приоритетная специфичность 33 против 23 и 24.</li>\n</ul>\n<div class="notecard note" id="sect5">\n  <p><strong>Примечание:</strong> Это был условный пример для более простого усвоения. В действительности, каждый тип селектора имеет собственный уровень специфичности, который не может быть замещён селекторами с более низким уровнем специфичности. Например, <em>миллион</em> соединённых селекторов <strong>класса</strong> не способны переписать правила <em>одного</em> селектора <strong>id</strong>.</p>\n  <p>Более правильный способ вычисления специфичности состоит в индивидуальной оценке уровней специфичности, начиная с наивысшего и продвигаясь к самому нижнему, когда это необходимо. Только когда оценки уровня специфичности совпадают, следует вычислять следующий нижний уровень; в противном случае, вы можете пренебречь селекторами с меньшим уровнем специфичности, поскольку они никогда не смогут преодолеть уровни более высокой специфичности.</p>\n</div></div></section><section aria-labelledby="!important"><h3 id="!important"><a>!important</a></h3><div class="section-content"><p>Существует специальный элемент CSS, который вы можете использовать для отмены всех вышеперечисленных вычислений, однако вы должны быть очень осторожны с его использованием — <code>!important</code>. Он используется, чтобы сделать конкретное свойство и значение самыми специфичными, таким образом переопределяя нормальные правила каскада.</p>\n<p>Взгляните на этот пример, где у нас есть два абзаца, один из которых имеет ID.</p>\n<p>Давайте пройдёмся по этому примеру, чтобы увидеть, что происходит — попробуйте удалить некоторые свойства, чтобы увидеть, что получится, если вам трудно понять:</p>\n<ol>\n  <li>Вы увидите, что применены значения <a class="only-in-en-us" title="Currently only available in English (US)"><code>color</code> <small>(en-US)</small></a> и <a><code>padding</code></a> третьего правила, но <a><code>background-color</code></a> — нет. Почему? Действительно, все три безусловно должны применяться, потому что правила, более поздние в порядке следования, обычно переопределяют более ранние правила.</li>\n  <li>Однако вышеприведённые правила выигрывают, потому что селекторы классов имеют более высокую специфичность, чем селекторы элементов.</li>\n  <li>Оба элемента имеют <a><code>class</code></a> с названием <code>better</code>, но у второго также есть <a><code>id</code></a> с названием <code>winning</code>. Поскольку ID имеют <em>ещё более высокую</em> специфичность, чем классы (у вас может быть только один элемент с каждым уникальным ID на странице, но много элементов с одним и тем же классом — селекторы ID <em>очень специфичны</em>, на что они и нацелены), красный цвет фона и однопиксельная чёрная граница должны быть применены ко 2-му элементу, причём первый элемент получает серый фоновый цвет и отсутствие границы, как определено классом.</li>\n  <li>2-й элемент получил красный цвет фона и отсутствие границы. Почему? Из-за объявления <code>!important</code> во втором правиле — размещение которого после <code>border: none</code> означает, что это объявление перевесит значение границы в предыдущем правиле, даже если ID имеет более высокую специфичность.</li>\n</ol>\n<div class="notecard note" id="sect6">\n  <p><strong>Примечание:</strong> Единственный способ переопределить объявление <code>!important</code> – это включить другое объявление <code>!important</code> в правило <em>с такой же специфичностью</em> позже или в правило с более высокой специфичностью.</p>\n</div>\n<p>Полезно знать о существовании <code>!important</code>, чтобы вы понимали, что это такое, когда встретите в чужом коде. <strong>Тем не менее, мы настоятельно рекомендуем вам никогда не использовать его, если в этом нет острой необходимости.</strong> <code>!important</code> меняет обычный порядок работы каскада, поэтому он может серьёзно затруднить отладку проблем CSS, особенно в большой таблице стилей.</p>\n<p>Одна из ситуаций, в которой вам, возможно, придётся это использовать, — это когда вы работаете с CMS, где вы не можете редактировать модули CSS ядра, и вы действительно хотите переопределить стиль, который нельзя переопределить другим способом. Но, вообще говоря, не стоит использовать этот элемент, если можно этого избежать.</p></div></section><section aria-labelledby="влияние_расположения_css"><h2 id="влияние_расположения_css"><a>Влияние расположения CSS</a></h2><div class="section-content"><p>Наконец, также полезно отметить, что важность объявления CSS зависит от того, в какой таблице стилей оно указано — у пользователя есть возможность установить индивидуальные таблицы стилей для переопределения стилей разработчика, например, пользователь может иметь проблемы со зрением и захочет установить размер шрифта на всех посещаемых им веб-страницах в два раза больше нормального размера, чтобы облегчить чтение.</p></div></section><section aria-labelledby="подведение_итогов"><h2 id="подведение_итогов"><a>Подведение итогов</a></h2><div class="section-content"><p>Конфликтующие объявления будут применяться в следующем порядке, с учётом замены более ранних более поздними:</p>\n<ol>\n  <li>Объявления в таблицах стилей клиентского приложения (например, стили браузера по умолчанию, используемые, когда не заданы другие стили).</li>\n  <li>Обычные объявления в пользовательских таблицах стилей (индивидуальные стили устанавливаются пользователем).</li>\n  <li>Обычные объявления в авторских таблицах стилей (это стили, установленные нами, веб-разработчиками).</li>\n  <li>Важные объявления в авторских таблицах стилей.</li>\n  <li>Важные объявления в пользовательских таблицах стилей.</li>\n</ol>\n<p>Для таблиц стилей веб-разработчиков имеет смысл переопределить пользовательские таблицы стилей так, чтобы можно было сохранить запланированный дизайн, но иногда у пользователей есть веские причины для переопределения стилей веб-разработчика, как упомянуто выше — это может быть достигнуто с помощью использования <code>!important</code> в их правилах.</p></div></section><section aria-labelledby="проверьте_ваши_навыки"><h2 id="проверьте_ваши_навыки"><a>Проверьте ваши навыки</a></h2><div class="section-content"><p>Мы охватили много тем в этой статье. А вы смогли запомнить наиболее важную информацию? Можете пройти несколько дополнительных тестов для того чтобы убедиться в том, что вы усвоили эту информацию, прежде чем пойдёте дальше — смотрите <a>Test your skills: the Cascade</a>.</p></div></section><section aria-labelledby="что_дальше"><h2 id="что_дальше"><a>Что дальше?</a></h2><div class="section-content"><p>Если вы поняли большую часть этой статьи, отлично — вы начали знакомиться с фундаментальными механизмами CSS. Далее мы рассмотрим селекторы подробно.</p>\n<p>Если вы не до конца поняли каскад, специфичность и наследование, не волнуйтесь! Это, безусловно, самая сложная вещь из тех, что мы до сих пор изучали в курсе, и даже профессиональные веб-разработчики иногда считают её коварной. Мы советуем вам вернуться к этой статье несколько раз в ходе изучения курса и продолжать обдумывать эту тему.</p>\n<p>Обратитесь сюда, если вы столкнётесь со странными проблемами, когда стили применяются не так, как вы ожидаете. Это может быть проблемой специфичности.</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Блочная модель',
		
		content:
			'<header><h1>Блочная модель</h1></header><div class="section-content"><p></p>Каждый элемент в CSS заключён в блок, и понимание поведения этих блоков — это ключ к умению задавать раскладку с помощью CSS, то есть выстраивать одни элементы относительно других элементов. В этом уроке мы надлежащим образом рассмотрим <em>блочную модель</em> CSS, чтобы вы могли создавать более сложные раскладки, понимая принцип ее работы и терминологию, которая к ней относится.<p></p>\n</div><section aria-labelledby="блочные_и_строчные_элементы"><h2 id="блочные_и_строчные_элементы"><a>Блочные и строчные элементы</a></h2><div class="section-content"><p>В CSS мы, говоря упрощённо, имеем два типа элементов — <strong>блочные</strong> и <strong>строчные</strong>. Эти характеристики относятся к поведению блоков в контексте потока страницы и относительно других блоков на странице.</p>\n<p>Если элемент определён как блочный, то он будет вести себя следующим образом:</p>\n<ul>\n  <li>Начнётся с новой строки.</li>\n  <li>Будет расширяться вдоль строки таким образом, чтобы заполнить всё пространство, доступное в её контейнере. В большинстве случаев это означает, что блок станет такой же ширины, как и его контейнер, заполняя 100% доступного пространства.</li>\n  <li>Будут применяться свойства <a><code>width</code></a> и <a><code>height</code></a>.</li>\n  <li>Внешние и внутренние отступы, рамка будут отодвигать от него другие элементы.</li>\n</ul>\n<p>Если не изменить намеренно тип отображения на строчный, то такие элементы, как заголовки (например, <code>&lt;h1&gt;</code>) и <code>&lt;p&gt;</code>, все используют <code>block</code> как свой внешний тип отображения по умолчанию.</p>\n<p>Если элемент имеет тип отображения <code>inline</code> (строчный), то:</p>\n<ul>\n  <li>Он не будет начинаться с новой строки.</li>\n  <li>Свойства <a><code>width</code></a> и <a><code>height</code></a> не будут применяться.</li>\n  <li>Вертикальные внешние и внутренние отступы, рамки будут применяться, но не будут отодвигать другие строчные элементы.</li>\n  <li>Горизонтальные внешние и внутренние отступы, рамки будут применяться и будут отодвигать другие строчные элементы.</li>\n</ul>\n<p>Элемент <code>&lt;a&gt;</code>, используемый для ссылок, <code>&lt;span&gt;</code>, <code>&lt;em&gt;</code> и <code>&lt;strong&gt;</code> — всё это примеры по умолчанию строчных элементов.</p>\n<p>Тип отображения, применяемый к элементу, определяется значениями свойства <a><code>display</code></a>, такими как <code>block</code> и <code>inline</code>, и относится к <strong>внешнему</strong> значению <code>display</code>.</p></div></section><section aria-labelledby="экскурс_внутренний_и_внешний_типы_отображения"><h2 id="экскурс_внутренний_и_внешний_типы_отображения"><a>Экскурс: внутренний и внешний типы отображения</a></h2><div class="section-content"><p>Здесь следует объяснить, что такое <strong>внутренние</strong> и <strong>внешние</strong> типы отображения. Как уже говорилось выше, каждый блок в CSS имеет <em>внешний</em> тип отображения, который определяет, блочный он или строчный.</p>\n<p>Элементы также имеют <em>внутренний</em> тип отображения, который определяет расположение элементов внутри них. По умолчанию элементы внутри блока располагаются в <strong><a>нормальном потоке</a></strong>: они ведут себя так же, как и любые другие блочные или строчные элементы (как описано выше).</p>\n<p>Однако мы можем изменить внутренний тип отображения, используя такие значения <code>display</code> как <code>flex</code>. Если мы установим <code>display: flex;</code> для элемента, внешний тип отображения примет значение <code>block</code>, но внутренний тип изменится на <code>flex</code>. Любые прямые дочерние элементы этого блока станут <em>flex</em>-объектами и будут размещены в соответствии с правилами, изложенными в спецификации <a>Flexbox</a>, о которой вы узнаете позже.</p>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> Чтобы узнать больше о значениях display, и о том, как работают элементы при блочном или строчном расположении, посмотрите руководство MDN <a class="only-in-en-us" title="Currently only available in English (US)">Блочное и строчное расположение <small>(en-US)<small></small></small></a>.</p>\n</div>\n<p>Когда вы перейдёте к более подробному изучению CSS вёрстки, вы встретите <code>flex</code> и другие внутренние значения, которые могут быть у ваших элементов, например <a><code>grid</code></a>.</p>\n<p>Тем не менее, блочное и строчное расположение — это поведение web-элементов по умолчанию. Как было сказано выше, это иногда называют <em>нормальным потоком (normal flow)</em>, потому что при отсутствии какой-либо другой инструкции элементы имеют блочное или строчное расположение.</p></div></section><section aria-labelledby="примеры_разных_типов_отображения"><h2 id="примеры_разных_типов_отображения"><a>Примеры разных типов отображения</a></h2><div class="section-content"><p>Давайте продолжим и рассмотрим некоторые примеры. Ниже мы имеем три разных элемента HTML с внешним типом отображения <code>block</code>. Первый — это абзац, который имеет обрамление, указанное в CSS. Браузер отображает его как блочный элемент, поэтому абзац начинается с новой строки и расширяется на всю доступную ему ширину.</p>\n<p>Второй — это список, который свёрстан с использованием <code>display: flex</code>. Это устанавливает flex-расположение для элементов внутри контейнера, однако сам список — блочный элемент и — как и абзац — расширяется на всю ширину контейнера и начинается с новой строки.</p>\n<p>Ниже у нас есть абзац блочного типа, внутри которого есть два элемента <code>&lt;span&gt;</code>. Эти элементы по умолчанию имеют тип <code>inline</code>, однако у одного из них задан класс block, для которого мы установили <code>display: block</code>.</p>\n<p>Мы можем видеть, как строчные элементы (<code>inline</code>) ведут себя в следующем примере. Элементы <code>&lt;span&gt;</code> в первом абзаце строчные по умолчанию и поэтому не приводят к переносу строки.</p>\n<p>У нас также есть элемент <code>&lt;ul&gt;</code>, для которого установлено <code>display: inline-flex</code>, что создаёт строчный элемент вокруг нескольких flex-объектов.</p>\n<p>Наконец, у нас есть два абзаца, для которых установлено <code>display: inline</code>. И строчный flex-контейнер, и абзацы располагаются вместе на одной строке, а не начинаются каждый с новой строки, как они отображались бы, будучи блочными элементами.</p>\n<p><strong>В примере вы можете заменить <code>display: inline</code> на <code>display: block</code> или <code>display: inline-flex</code> на <code>display: flex</code> для переключения между этими двумя режимами отображения.</strong></p>\n<p>Позже в этих уроках вы встретите такое понятие как flex-раскладка; главное, что нужно запомнить сейчас, это то, что изменение значения свойства <code>display</code> может изменить внешний тип отображения элемента на блочный или строчный, что меняет способ его отображения относительно других элементов в раскладке страницы.</p>\n<p>В оставшейся части урока мы сосредоточимся на внешнем типе отображения.</p></div></section><section aria-labelledby="что_такое_блочная_модель_css"><h2 id="что_такое_блочная_модель_css"><a>Что такое блочная модель CSS?</a></h2><div class="section-content"><p>Полностью блочная модель в CSS применяется к блочным элементам, строчные элементы используют не все свойства, определённые блочной моделью. Модель определяет, как разные части элемента — поля, рамки, отступы и содержимое — работают вместе, чтобы создать объект, который вы можете увидеть на странице. Дополнительная сложность заключается в том, что существуют стандартная и альтернативная блочные модели.</p></div></section><section aria-labelledby="составляющие_элемента"><h3 id="составляющие_элемента"><a>Составляющие элемента</a></h3><div class="section-content"><p>Составляя блочный элемент в CSS мы имеем:</p>\n<ul>\n  <li><strong>Содержимое</strong>: область, где отображается ваш контент, размер которой можно изменить с помощью таких свойств, как <a><code>width</code></a> и <a><code>height</code></a>.</li>\n  <li><strong>Внутренний отступ</strong>: отступы располагаются вокруг содержимого в виде пустого пространства; их размер контролируется с помощью <a><code>padding</code></a> и связанных свойств.</li>\n  <li><strong>Рамка</strong>: рамка оборачивает содержимое и внутренние отступы. Её размер и стиль можно контролировать с помощью <a><code>border</code></a> и связанных свойств.</li>\n  <li><strong>Внешний отступ</strong>: внешний слой, заключающий в себе содержимое, внутренний отступ и рамки, представляет собой пространство между текущим и другими элементами. Его размер контролируется с помощью <a><code>margin</code></a> и связанных свойств.</li>\n</ul>\n<p>Рисунок ниже показывает эти слои:</p>\n<p>\n  \n</p></div></section><section aria-labelledby="стандартная_блочная_модель_css"><h3 id="стандартная_блочная_модель_css"><a>Стандартная блочная модель CSS</a></h3><div class="section-content"><p>В стандартной блочной модели, если указать элементу атрибуты <code>width</code> и <code>height</code>, это определит ширину и высоту <em>содержимого</em>. Любые отступы и рамки затем добавляются к этой ширине и высоте для получения общего размера элемента. Это показано на изображении ниже.</p>\n<p>Предположим, что в элементе есть следующий CSS определяющий <code>width</code>, <code>height</code>, <code>margin</code>, <code>border</code>, и <code>padding</code>:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.box {\n  width: 350px;\n  height: 150px;\n  margin: 10px;\n  padding: 25px;\n  border: 5px solid black;\n}\n</pre></div>\n<p>Пространство, занимаемое нашим объектом с использованием стандартной блочной модели, на самом деле будет равно 410px в ширину (350 + 25 + 25 + 5 + 5) и 210px в высоту (150 + 25 + 25 + 5 + 5), поскольку отступы и рамки добавляются к размерам поля содержимого.</p>\n<p>\n  \n</p>\n<div class="notecard note" id="sect2">\n  <p><strong>Примечание:</strong> Внешний отступ не считается в фактическом размере объекта. Конечно, он влияет на общее пространство, занимаемое объектом на странице, но только на внешнюю часть. Область элемента заканчивается на рамке — она не распространяется за нее.</p>\n</div></div></section><section aria-labelledby="альтернативная_блочная_модель_css"><h3 id="альтернативная_блочная_модель_css"><a>Альтернативная блочная модель CSS</a></h3><div class="section-content"><p>Вы можете подумать, что довольно неудобно добавлять рамки и отступы, чтобы получить реальный размер элемента, и окажетесь правы! По этой причине, спустя некоторое время после стандартной блочной модели, в CSS была введена альтернативная блочная модель. При использовании альтернативной модели любая ширина — это ширина видимой части элемента на странице, поэтому ширина области содержимого будет равна общей ширине минус ширина рамки и внутреннего отступа. Тот же CSS, который использовался выше, даст следующий результат (ширина = 350px, высота = 150px).</p>\n<p>\n  \n</p>\n<p>По умолчанию браузеры используют стандартную блочную модель. Если вы хотите использовать альтернативную блочную модель для элемента, установите для него свойство <code>box-sizing: border-box</code>. С помощью этого вы говорите браузеру о том, что рамка элемента определяется любыми размерами, которые вы устанавливаете.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.box {\n  box-sizing: border-box;\n}\n</pre></div>\n<p>Если вы хотите, чтобы все ваши элементы использовали альтернативную блочную модель, что является распространённым выбором среди разработчиков, установите свойство <code>box-sizing</code> для элемента <code>&lt;html&gt;</code>, затем задайте всем элементам наследование этого значения (inherit), как показано в примере ниже. Если вы хотите понять ход мыслей, стоящий за этим решением, читайте статью <a class="external" target="_blank">the CSS Tricks article on box-sizing</a>.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">html {\n  box-sizing: border-box;\n}\n*,\n*::before,\n*::after {\n  box-sizing: inherit;\n}\n</pre></div>\n<div class="notecard note" id="sect3">\n  <p><strong>Примечание:</strong> Интересный факт — Internet Explorer по умолчанию использовал альтернативную блочную модель без доступного механизма для переключения.</p>\n</div></div></section><section aria-labelledby="играем_с_блочными_моделями"><h2 id="играем_с_блочными_моделями"><a>Играем с блочными моделями</a></h2><div class="section-content"><p>В примере ниже, вы можете видеть 2 объекта. Оба имеют класс <code>.box</code>, который даёт им одинаковые параметры <code>width</code>, <code>height</code>, <code>margin</code>, <code>border</code>, и <code>padding</code>. Единственное различие в том, что второй объект объявлен по альтернативной блочной модели.</p>\n<p><strong>Можете ли вы изменить размер второго объекта (добавляя CSS в класс <code>.alternate)</code> чтобы ширина и высота совпали с первым блоком?</strong></p>\n<div class="notecard note" id="sect4">\n  <p><strong>Примечание:</strong> вы можете найти решение этой задачи <a class="external" target="_blank">здесь</a>.</p>\n</div></div></section><section aria-labelledby="использование_инструментов_разработчика_в_браузере_для_просмотра_блочных_моделей"><h3 id="использование_инструментов_разработчика_в_браузере_для_просмотра_блочных_моделей"><a>Использование инструментов разработчика в браузере для просмотра блочных моделей</a></h3><div class="section-content"><p><a>Инструменты разработчика</a> вашего браузера могут значительно облегчить понимание блочной модели. Если вы проверите элемент в инструментах разработчика Firefox, вы можете увидеть его размер, а также внешний и внутренний отступы и рамку. Проверка элемента таким способом — отличный способ выяснить, действительно ли размер вашего блока такой, какой вы думаете!</p>\n<p>\n  \n</p></div></section><section aria-labelledby="внешние_внутренние_отступы_и_рамки"><h2 id="внешние_внутренние_отступы_и_рамки"><a>Внешние, внутренние отступы и рамки</a></h2><div class="section-content"><p>Вы уже видели свойства <a><code>margin</code></a>, <a><code>padding</code></a> и <a><code>border</code></a> в работе в приведённом выше примере. Используемые в этом примере свойства — <strong>сокращённые</strong> и позволяют нам устанавливать все четыре стороны блока одновременно. У них также есть эквивалентные полные свойства, которые позволяют индивидуально управлять разными сторонами блока.</p>\n<p>Давайте рассмотрим эти свойства более подробно.</p></div></section><section aria-labelledby="внешний_отступ_margin"><h3 id="внешний_отступ_margin"><a>Внешний отступ (margin)</a></h3><div class="section-content"><p>Внешний отступ — это невидимое пространство вокруг вашего элемента. Оно отталкивает другие элементы от него. Внешний отступ может быть как положительным, так и отрицательным. Негативное значение может привести к перекрытию некоторых элементов страницы. Независимо от того, используете ли вы стандартную или альтернативную блочную модель, внешний отступ всегда добавляется после расчёта размера видимого блока.</p>\n<p>Мы можем контролировать все поля элемента сразу, используя свойство <a><code>margin</code></a>, или каждую сторону индивидуально, используя эквивалентные полные свойства:</p>\n<ul>\n  <li><a><code>margin-top</code></a></li>\n  <li><a><code>margin-right</code></a></li>\n  <li><a><code>margin-bottom</code></a></li>\n  <li><a><code>margin-left</code></a></li>\n</ul>\n<p><strong>В примере ниже, попробуйте изменить значение margin чтобы увидеть как блок смещается, создавая или удаляя пространство (если вводить отрицательные значения margin) между этим элементом и элементом его содержащим.</strong></p>\n<h4 id="схлопывание_внешних_отступов">Схлопывание внешних отступов</h4>\n<p>Ключевой момент, который нужно понимать в отношении внешних отступов (margin), это концепция схлопывания. Если у вас есть два элемента, внешние отступы которых соприкасаются, и оба значения margin положительные, то эти значения будут объединены в одно, равное большему из двух значений. А если одно или оба значения отрицательны, то сумма отрицательных значений будет вычтена из общей суммы.</p>\n<p>В примере ниже есть два абзаца. Первому абзацу задан <code>margin-bottom</code> 50 пикселей. У второго абзаца <code>margin-top</code> 30 пикселей. Отступы схлопываются так, что в результате margin между двумя блоками составляет 50 пикселей, а не сумму отдельных значений margin.</p>\n<p><strong>Вы можете проверить это, установив второму абзацу <code>margin-top</code> равный 0. Видимое расстояние между двумя абзацами не изменится — отступ остаётся равен 50 пикселям, заданным в <code>margin-bottom</code> первого абзаца. Если вы установите значение -10px, то увидите, что margin становится 40px — происходит вычитание из положительного значения 50px у первого абзаца.</strong></p>\n<p>Существует ряд правил, которые определяют, когда внешние отступы схлопываются, а когда нет. Для получения подробной информации см. <a>margin collapsing</a>. Главное, что нужно сейчас помнить, — это то, что схлопывание отступов существует. Если вы создаёте пространство с внешними отступами и не получаете ожидаемого результата, вероятно, именно это и происходит.</p></div></section><section aria-labelledby="рамка"><h3 id="рамка"><a>Рамка</a></h3><div class="section-content"><p>Рамка располагается между margin и padding блочного элемента. Если вы используете стандартную блочную модель, размер рамки прибавляется к значениям <code>width</code> и <code>height</code> элемента. Если вы используете альтернативную блочную модель, то размер рамки уменьшает поле контента своего блока, так как значения рамки входят в заданные ему <code>width</code> и <code>height</code>.</p>\n<p>Для стилизации рамок существует большое количество различных свойств: четыре рамки, и каждая из них имеет свой стиль, ширину и цвет, которыми мы можем манипулировать.</p>\n<p>Вы можете установить ширину, стиль или цвет всех четырёх рамок сразу, используя свойство <a><code>border</code></a>.</p>\n<p>Чтобы установить индивидуальные свойства для каждой из четырёх сторон, вы можете использовать:</p>\n<ul>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>border-top</code> <small>(en-US)</small></a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>border-right</code> <small>(en-US)</small></a></li>\n  <li><a><code>border-bottom</code></a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>border-left</code> <small>(en-US)</small></a></li>\n</ul>\n<p>Для установки ширины, стиля или цвета всех рамок используйте:</p>\n<ul>\n  <li><a><code>border-width</code></a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>border-style</code> <small>(en-US)</small></a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>border-color</code> <small>(en-US)</small></a></li>\n</ul>\n<p>Чтобы установить ширину, стиль или цвет для каждой рамки индивидуально, вы можете использовать следующие свойства:</p>\n<ul>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>border-top-width</code> <small>(en-US)</small></a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>border-top-style</code> <small>(en-US)</small></a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>border-top-color</code> <small>(en-US)</small></a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>border-right-width</code> <small>(en-US)</small></a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>border-right-style</code> <small>(en-US)</small></a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>border-right-color</code> <small>(en-US)</small></a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>border-bottom-width</code> <small>(en-US)</small></a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>border-bottom-style</code> <small>(en-US)</small></a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>border-bottom-color</code> <small>(en-US)</small></a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>border-left-width</code> <small>(en-US)</small></a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>border-left-style</code> <small>(en-US)</small></a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>border-left-color</code> <small>(en-US)</small></a></li>\n</ul>\n<p><strong>В примере ниже мы использовали различные сокращённые и полные способы создания рамок. Поиграйте с различными свойствами, чтобы проверить, как вы поняли принципы их работы. Информацию о различных стилях, которые вы можете использовать, можно найти на страницах MDN о свойствах рамок.</strong></p></div></section><section aria-labelledby="внутренний_отступ_padding"><h3 id="внутренний_отступ_padding"><a>Внутренний отступ (padding)</a></h3><div class="section-content"><p>Внутренний отступ расположен между рамкой и областью контента блока. В отличии от внешних отступов (margin), вы не можете использовать отрицательные значения для padding: они должны быть положительными или равными 0. Любой применённый к вашим элементам фон будет отображаться под областью padding, поэтому внутренний отступ обычно используется, чтобы отодвинуть контент от рамок.</p>\n<p>Вы можете контролировать значение padding для всех сторон элемента, используя свойство <a><code>padding</code></a>, или для каждой стороны индивидуально, используя следующие полные свойства:</p>\n<ul>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>padding-top</code> <small>(en-US)</small></a></li>\n  <li><a><code>padding-right</code></a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>padding-bottom</code> <small>(en-US)</small></a></li>\n  <li><a><code>padding-left</code></a></li>\n</ul>\n<p><strong>Если вы измените значения padding для класса <code>.box</code> в примере ниже, то увидите, что это изменяет положение текста внутри элемента.</strong></p>\n<p><strong>Вы также можете изменить padding для класса <code>.container</code>, который задаёт отступ между контейнером и блоком. Внутренний отступ может быть изменён для любого элемента и создаст пространство между его рамкой и содержимым.</strong></p></div></section><section aria-labelledby="блочная_модель_и_строчные_элементы"><h2 id="блочная_модель_и_строчные_элементы"><a>Блочная модель и строчные элементы</a></h2><div class="section-content"><p>Всё, сказанное ранее, полностью применимо к блочным элементам. Некоторые из свойств могут быть также применены и к строчным (inline) элементам, например к <code>&lt;span&gt;</code>.</p>\n<p>В приведённом ниже примере у нас есть <code>&lt;span&gt;</code> внутри абзаца, и мы применили к нему <code>width</code>, <code>height</code>, <code>margin</code>, <code>border</code> и <code>padding</code>. Вы можете видеть, что ширина и высота игнорируются. Вертикальные внешние и внутренние отступы и рамки применены, но они не изменяют положение других элементов относительно нашего строчного элемента, и поэтому отступы и рамка перекрывают другие слова в абзаце. Горизонтальные внешние и внутренние отступы и рамки применены и заставляют другие элементы отодвинуться от нашего.</p></div></section><section aria-labelledby="использование_display_inline-block"><h2 id="использование_display_inline-block"><a>Использование display: inline-block</a></h2><div class="section-content"><p>Существует особое значение <code>display</code>, которое представляет собой золотую середину между <code>inline</code> и <code>block</code>. Это полезно в ситуациях, когда вы не хотите, чтобы элемент переносился на новую строку, но нужно, чтобы он применял <code>width</code> и <code>height</code> и избегал перекрытия, показанного выше.</p>\n<p>Элемент с <code>display: inline-block</code> применяет ряд свойств блочного элемента, о которых мы уже знаем:</p>\n<ul>\n  <li>Применяются свойства <code>width</code> и <code>height</code>.</li>\n  <li>Использование <code>padding</code>, <code>margin</code> и <code>border</code> приведёт к тому, что другие элементы будут отодвинуты от нашего элемента.</li>\n</ul>\n<p>Он не перенесётся на новую строку и станет больше, чем его содержимое, только если вы явно зададите свойства <code>width</code> и <code>height</code>.</p>\n<p><strong>В следующем примере мы добавили <code>display: inline-block</code> к нашему элементу <code>&lt;span&gt;</code>. Попробуйте изменить значение свойства на <code>display: block</code> или полностью удалить строку, чтобы увидеть разницу.</strong></p>\n<p>Это может быть полезно, когда вы хотите создать ссылку с большой областью попадания, добавив <code>padding</code>. <code>&lt;a&gt;</code> — это строчный элемент, такой же как <code>&lt;span&gt;</code>; вы можете использовать <code>display: inline-block</code>, чтобы разрешить применение отступов, что упростит пользователю переход по ссылке.</p>\n<p>Довольно часто это можно увидеть в панелях навигации. Приведённая ниже навигация отображается в виде строки с использованием flexbox, и мы добавили отступы к элементу <code>&lt;a&gt;</code>, потому что хотим, чтобы <code>background-color</code> изменялся при наведении курсора на <code>&lt;a&gt;</code>. Отступы перекрывают рамку элемента <code>&lt;ul&gt;</code>. Это происходит потому, что <code>&lt;a&gt;</code> — строчный элемент.</p>\n<p><strong>Добавьте в правило <code>display: inline-block</code> с помощью селектора <code>.links-list a</code>, и вы увидите, как он решает эту проблему, заставляя другие элементы соблюдать отступы.</strong></p></div></section><section aria-labelledby="проверьте_свои_навыки!"><h2 id="проверьте_свои_навыки!"><a>Проверьте свои навыки!</a></h2><div class="section-content"><p>В этой статье мы многое рассмотрели, но получится ли у вас вспомнить самую важную информацию? Вы можете пройти дополнительные тесты, чтобы убедиться, что вы всё усвоили, прежде чем двигаться дальше — см. <a class="only-in-en-us" title="Currently only available in English (US)">Проверка своих навыков: блочная модель <small>(en-US)<small></small></small></a>.</p></div></section><section aria-labelledby="заключение"><h2 id="заключение"><a>Заключение</a></h2><div class="section-content"><p>Это большая часть того, что вам нужно знать о блочной модели. Возможно, вы захотите вернуться к этому уроку в будущем, если когда-нибудь обнаружите, что не понимаете, насколько велики блоки в вашей раскладке на странице.</p>\n<p>В следующем уроке мы рассмотрим, как можно использовать <a>фон и рамки</a>, чтобы сделать ваши простые блоки более интересными.</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Фон и границы',
		
		content:
			'<header><h1>Фон и границы</h1></header><div class="section-content">\n<p>В этом уроке мы рассмотрим некоторые интересные возможности, которые вы можете сделать с помощью CSS-свойств фона и границ . Благодаря добавлению градиентов, фоновых изображений и закруглённых углов свойства фона и границ ответят на многие вопросы стилизации в CSS.</p>\n</div><section aria-labelledby="стилизация_фона_в_css"><h2 id="стилизация_фона_в_css"><a>Стилизация фона в CSS</a></h2><div class="section-content"><p>CSS-свойство <a><code>background</code></a> является сокращением для ряда полных свойств фона, с которыми мы познакомимся в этом уроке. Если вы обнаружите сложное свойство <code>background</code> в таблице стилей, это может показаться трудным для понимания, так как одновременно может быть передано так много значений.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.box {\n  background:\n    linear-gradient(\n        105deg,\n        rgba(255, 255, 255, 0.2) 39%,\n        rgba(51, 56, 57, 1) 96%\n      ) center center / 400px 200px no-repeat,\n    url(big-star.png) center no-repeat,\n    rebeccapurple;\n}\n</pre></div>\n<p>Мы вернёмся к тому, как работает сокращение позже, а пока давайте взглянем на различные вещи, которые вы можете делать с фоном в CSS, посмотрев на отдельные свойства <code>background</code>.</p></div></section><section aria-labelledby="фоновый_цвет"><h3 id="фоновый_цвет"><a>Фоновый цвет</a></h3><div class="section-content"><p>Свойство <a><code>background-color</code></a> определяет цвет фона для любого элемента в CSS. Свойство принимает любой допустимый цвет <a><code>&lt;color&gt;</code></a>. <code>background-color</code> распространяется на сам контент и отступы от него (padding).</p>\n<p>В приведённом ниже примере мы использовали различные значения цвета, чтобы добавить цвет фона к блоку, заголовку и элементу <a><code>&lt;span&gt;</code></a>.</p>\n<p><strong>Поиграйте с ними, используя любое доступное значение</strong> <strong><a>&lt;color&gt;</a>.</strong></p></div></section><section aria-labelledby="фоновое_изображение"><h3 id="фоновое_изображение"><a>Фоновое изображение</a></h3><div class="section-content"><p>Свойство <a><code>background-image</code></a> позволяет отображать изображение в качестве фона элемента. В приведённом ниже примере у нас есть два блока — в одном фоновое изображение больше, чем размеры блока, а в другом - маленькое изображение звезды.</p>\n<p>Этот пример демонстрирует две особенности фоновых изображений. По умолчанию большое изображение не масштабируется до размера блока, поэтому мы видим только его небольшой угол, в то время как маленькое изображение повторяется, чтобы заполнить весь блок. В нашем случае фактически было использовано изображение одной маленькой звезды.</p>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> <strong>Если кроме фонового изображения вы добавили фоновый цвет, то изображение будет отображаться над цветом.</strong> Попробуйте добавить свойство <code>background-color</code> в приведённый выше пример, чтобы увидеть это в действии.</p>\n</div>\n<h4 id="свойство_background-repeat">Свойство background-repeat</h4>\n<p>Свойство <a><code>background-repeat</code></a> используется для управления повторениями фонового изображения. Доступные значения:</p>\n<ul>\n  <li><code>no-repeat</code> — останавливает повторение фонового изображения во всех направлениях.</li>\n  <li><code>repeat-x</code> — повторение фонового изображения по горизонтали.</li>\n  <li><code>repeat-y</code> — повторение фонового изображения по вертикали.</li>\n  <li><code>repeat</code> — повторение фонового изображения в обоих направлениях. Установлено по умолчанию.</li>\n</ul>\n<p><strong>Попробуйте эти значения в примере ниже. Мы установили значение <code>no-repeat</code>, поэтому вы видите только одну звезду. Попробуйте разные значения -</strong> <strong><code>repeat-x</code></strong> <strong>и</strong> <strong><code>repeat-y</code></strong> <strong>—</strong> <strong>чтобы увидеть, какие эффекты они оказывают.</strong></p>\n<h4 id="изменение_размеров_фонового_изображения">Изменение размеров фонового изображения</h4>\n<p>В приведённом выше примере у нас есть большое изображение, которое в конечном итоге было обрезано, так как оно больше, чем элемент, фоном которого оно является. В этом случае мы могли бы использовать свойство <a><code>background-size</code></a>, которое может принимать значения <a>длины</a> или в <a>процентах</a>, чтобы размер изображения соответствовал размеру фона.</p>\n<p>Вы также можете использовать ключевые слова:</p>\n<ul>\n  <li><code>cover</code> — браузер сделает изображение достаточно большим, чтобы оно полностью заполнило блок, сохраняя при этом соотношение сторон. В этом случае часть изображения, скорее всего, окажется за пределами блока.</li>\n  <li><code>contain</code> — браузер сделает изображение нужного размера, чтобы поместиться в блоке. В этом случае могут появиться пробелы с обеих сторон или сверху и снизу изображения, если соотношение сторон изображения отличается от соотношения сторон блока.</li>\n</ul>\n<p>Ниже я применил значения длины к размерам изображения. Глядите, как это исказило изображение.</p>\n<p>В приведённом ниже примере я использовал большое изображение из ранее рассмотренного примера и указал значения длины, чтобы определить его размер внутри блока. Вы можете посмотреть, как это исказило изображение.</p>\n<p>Попробуйте следующее.</p>\n<ul>\n  <li>Измените значения длины, используемые для изменения размера фона.</li>\n  <li>Измените значение длины на <code>background-size: cover</code> или <code>background-size: contain</code>.</li>\n  <li>Если ваше изображение меньше размеров блока, вы можете изменить значение свойства <code>background-repeat</code>, чтобы повторить изображение.</li>\n</ul>\n<h4 id="позиционирование_фонового_изображения">Позиционирование фонового изображения</h4>\n<p>Свойство <a><code>background-position</code></a> позволяет вам изменять позицию, в которой фоновое изображение появляется в блоке. При этом используется система координат, в которой <em>левый верхний угол</em> блока равен <code>(0,0)</code>, а сам блок располагается вдоль горизонтальной (<code>x</code>) и вертикальной (<code>y</code>) осей.</p>\n<div class="notecard note" id="sect2">\n  <p><strong>Примечание:</strong> По умолчанию значение <code>background-position</code> равно <code>(0,0)</code>.</p>\n</div>\n<p>Обычно свойство <code>background-position</code> задают в виде двух последовательных значений — значение по горизонтали, за которым следует значение по вертикали.</p>\n<p>Вы можете использовать такие ключевые слова, как <code>top</code> и <code>right</code> (с остальными можете ознакомиться на странице <a><code>background-position</code></a>):</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.box {\n  background-image: url(star.png);\n  background-repeat: no-repeat;\n  background-position: top center;\n}\n</pre></div>\n<p>Допустимы значения <a>длины</a> и <a>процентные</a>:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.box {\n  background-image: url(star.png);\n  background-repeat: no-repeat;\n  background-position: 20px 10%;\n}\n</pre></div>\n<p>Вы также можете смешивать значения ключевых слов с длинами или процентами, например:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.box {\n  background-image: url(star.png);\n  background-repeat: no-repeat;\n  background-position: top 20px;\n}\n</pre></div>\n<p>И наконец, вы также можете использовать синтаксис с четырьмя значениями, чтобы указать расстояние от определённых краёв блока - единица длины в данном случае представляет собой смещение от значения ключевого слова. Итак, в CSS ниже мы сместили фон на 20 пикселей сверху и на 10 пикселей справа:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.box {\n  background-image: url(star.png);\n  background-repeat: no-repeat;\n  background-position: top 20px right 10px;\n}\n</pre></div>\n<p><strong>Используйте приведённый ниже пример, чтобы поэкспериментировать с этими значениями и переместить звезду внутри блока.</strong></p>\n<div class="notecard note" id="sect3">\n  <p><strong>Примечание:</strong> <code>background-position</code> — это сокращение для <a><code>background-position-x</code></a> и <a class="only-in-en-us" title="Currently only available in English (US)"><code>background-position-y</code> <small>(en-US)</small></a>, которые позволяют вам устанавливать различные значения положения по оси индивидуально.</p>\n</div></div></section><section aria-labelledby="градиент_в_качестве_фона"><h3 id="градиент_в_качестве_фона"><a>Градиент в качестве фона</a></h3><div class="section-content"><p>Градиент - при использовании для фона - действует так же, как изображение, и поэтому задаётся свойством <a><code>background-image</code></a>.</p>\n<p>Вы можете прочитать больше о различных типах градиентов и о том, что вы можете с ними делать на странице MDN для типа данных <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;gradient&gt;</code> <small>(en-US)<small></small></small></a>. Поиграть с градиентами вы можете используя один из многих генераторов градиентов CSS, доступных в Интернете, например <a class="external" target="_blank">этот</a>. Вы можете создать градиент, а затем скопировать и вставить его в свой код.</p>\n<p>Попробуйте использовать разные градиенты в примере ниже. В двух блоках соответственно у нас есть линейный градиент, растянутый на весь блок, и радиальный градиент с заданным размером, который поэтому повторяется.</p></div></section><section aria-labelledby="несколько_фоновых_изображений"><h3 id="несколько_фоновых_изображений"><a>Несколько фоновых изображений</a></h3><div class="section-content"><p>Также возможно создавать несколько фоновых изображений — просто разделив значения свойства <code>background-image</code> запятыми.</p>\n<p>Когда вы сделаете это, произойдёт наложение фоновых изображений друг на друга. Фоновые изображения будут наложены слоями, где каждое новое фоновое изображение, перечисленное в коде, будет накладываться поверх ранее указанного изображения.</p>\n<div class="notecard note" id="sect4">\n  <p><strong>Примечание:</strong> Градиенты можно легко смешивать с обычными фоновыми изображениями.</p>\n</div>\n<p>Другие свойства <code>background- *</code> также могут иметь значения, разделённые запятыми, как и <code>background-image</code>:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">background-image: url(image1.png), url(image2.png), url(image3.png),\n  url(image1.png);\nbackground-repeat: no-repeat, repeat-x, repeat;\nbackground-position:\n  10px 20px,\n  top right;\n</pre></div>\n<p>Каждое значение различных свойств будет соответствовать значениям в той же позиции в других свойствах. Выше, например, значение <code>background-repeat</code> для <code>image1</code> будет <code>no-repeat</code>. Однако, что происходит, когда разные свойства имеют разное количество значений? Ответ заключается в том, что меньшее количество значений будет циклически повторяться - в приведённом выше примере есть четыре фоновых изображения, и только два значения <code>background-position</code>. Первые два значения позиции будут применены к первым двум изображениям, затем они снова будут циклически повторяться - <code>image3</code> будет присвоено первое значение позиции, а <code>image4</code> будет присвоено второе значение позиции.</p>\n<p><strong>Поиграем? В приведённом ниже примере я добавил два изображения. Чтобы продемонстрировать порядок наложения, попробуйте поменять порядок фоновых изображений в списке. Или поиграйте с другими свойствами, чтобы изменить положение, размер или повторяемость значений.</strong></p></div></section><section aria-labelledby="закрепление_фона"><h3 id="закрепление_фона"><a>Закрепление фона</a></h3><div class="section-content"><p>Другая опция, которую можно применить к фону, - это указать, как он будет прокручиваться при прокрутке содержимого. Это контролируется с помощью свойства <a><code>background-attachment</code></a>, которое может принимать следующие значения:</p>\n<ul>\n  <li><code>scroll</code>: Заставляет элементы фона прокручиваться при прокрутке страницы. Если содержимое элемента прокручивается, фон не перемещается. Фактически, фон фиксируется в той же позиции на странице, поэтому он прокручивается по мере прокрутки страницы.</li>\n  <li><code>fixed</code>: Фиксирует элементы фона в области просмотра, чтобы он не прокручивался при прокрутке страницы или содержимого элемента. Фон всегда будет оставаться на одном и том же месте на экране.</li>\n  <li><code>local</code>: Это значение было добавлено позже (оно поддерживается только в Internet Explorer 9+, тогда как другие поддерживаются в IE4+), потому что значение <code>scroll</code> довольно запутанно и во многих случаях действительно не делает то, что вы хотите. Значение <code>local</code> фиксирует фон для элемента, к которому он применён, поэтому, когда вы прокручиваете элемент, фон прокручивается вместе с ним.</li>\n</ul>\n<p>Свойство <a><code>background-attachment</code></a> действует только тогда, когда есть контент для прокрутки, поэтому мы сделали пример, чтобы продемонстрировать различия между тремя значениями - взгляните на <a class="external" target="_blank">background-attachment.html</a> (также смотри <a class="external" target="_blank">исходный код</a> здесь).</p></div></section><section aria-labelledby="использование_сокращённого_свойства_background"><h3 id="использование_сокращённого_свойства_background"><a>Использование сокращённого свойства background</a></h3><div class="section-content"><p>Как я упоминал в начале этого урока, вы часто будете видеть фон, заданный с помощью свойства <a><code>background</code></a>. Это сокращение позволяет вам одновременно устанавливать все различные свойства.</p>\n<p>При использовании нескольких фонов необходимо указать все свойства для первого фона, а затем добавить следующий фон после запятой. В приведённом ниже примере у нас есть градиент с размером и положением, затем фоновое изображение со значением <code>no-repeat</code> и положением, затем цвет.</p>\n<p>При записи сокращённых значений фонового изображения необходимо соблюдать несколько правил, например:</p>\n<ul>\n  <li><code>background-color</code> можно указывать только после последней запятой.</li>\n  <li>Значения <code>background-size</code> могут быть включены только сразу после <code>background-position</code>, разделённые символом \'/\', например: <code>center/80%</code>.</li>\n</ul>\n<p>Посетите страницу MDN свойства <a><code>background</code></a>, чтобы увидеть полное описание.</p></div></section><section aria-labelledby="доступность_просмотра"><h3 id="доступность_просмотра"><a>Доступность просмотра</a></h3><div class="section-content"><p>Помещая текст поверх фонового изображения или цвета, вы должны позаботиться о том, чтобы у вас было достаточно контраста, чтобы текст был читаемым для посетителей вашего сайта. Если указывается изображение, и текст будет помещён поверх этого изображения, вы также должны указать <code>background-color</code>, который позволит тексту быть разборчивым, если изображение не загружается.</p>\n<p>Программы чтения с экрана не могут анализировать фоновые изображения, поэтому они должны быть чисто декоративными; любой важный контент должен быть частью HTML-страницы, а не находиться в фоне.</p></div></section><section aria-labelledby="границы"><h2 id="границы"><a>Границы</a></h2><div class="section-content"><p>Изучая Блочную модель, мы обнаружили, как границы влияют на размер нашего блока. В этом уроке мы рассмотрим, как творчески использовать границы. Обычно, когда мы добавляем границы к элементу с помощью CSS, мы используем сокращённое свойство, которое устанавливает цвет, ширину и стиль границы в одной строке CSS.</p>\n<p>Мы можем установить границу для всех четырёх сторон блока с помощью <a><code>border</code></a>:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.box {\n  border: 1px solid black;\n}\n</pre></div>\n<p>Или мы можем нацеливаться на один край блока, например:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.box {\n  border-top: 1px solid black;\n}\n</pre></div>\n<p>Индивидуальные свойства этих сокращений будут следующими:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.box {\n  border-width: 1px;\n  border-style: solid;\n  border-color: black;\n}\n</pre></div>\n<p>И более детально:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.box {\n  border-top-width: 1px;\n  border-top-style: solid;\n  border-top-color: black;\n}\n</pre></div>\n<div class="notecard note" id="sect5">\n  <p><strong>Примечание:</strong> Свойства границ top, right, bottom, и left также имеют сопоставленные <em>логические</em> свойства, которые относятся к режиму написания документа (например, текст слева направо, справа налево или сверху вниз). Мы рассмотрим их в следующем уроке, который касается <a class="page-not-created" title="This is a link to an unwritten page">работы с разными направлениями текста</a>.</p>\n</div>\n<p><strong>Есть множество стилей, которые вы можете использовать для границ. В приведённом ниже примере мы использовали разные стили границ для четырёх сторон моего блока. Поиграйте со стилем, шириной и цветом границы, чтобы увидеть, как они работают.</strong></p></div></section><section aria-labelledby="закруглённые_углы"><h3 id="закруглённые_углы"><a>Закруглённые углы</a></h3><div class="section-content"><p>Закругление углов блока достигается с помощью свойства <a><code>border-radius</code></a> и связанных свойств, которые относятся к каждому углу блока. В качестве значения могут использоваться два значения длины или процента: первое значение определяет горизонтальный радиус, а второе - вертикальный радиус. Чаще задают только одно значение, которое используется для обоих.</p>\n<p>Например, чтобы сделать все четыре угла блока радиусом 10px:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.box {\n  border-radius: 10px;\n}\n</pre></div>\n<p>Или, чтобы верхний правый угол имел горизонтальный радиус 1em и вертикальный радиус 10%:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.box {\n  border-top-right-radius: 1em 10%;\n}\n</pre></div>\n<p>В примере ниже мы установили все четыре угла, а затем изменили значения для верхнего правого угла, чтобы сделать его другим. Вы можете поиграть со значениями, чтобы изменить углы. Взгляните на страницу свойств для <a><code>border-radius</code></a> чтобы увидеть доступные варианты синтаксиса.</p></div></section><section aria-labelledby="упражнение_с_границами_и_фоном"><h2 id="упражнение_с_границами_и_фоном"><a>Упражнение с границами и фоном</a></h2><div class="section-content"><p>Чтобы проверить свои новые знания, попробуйте создать следующее, используя фон и границы, используя приведённый ниже пример в качестве отправной точки:</p>\n<ol>\n  <li>Задайте рамку равную 5px black solid, с закруглёнными углами 10px.</li>\n  <li>Добавить фоновое изображение (используйте URL <code>balloons.jpg</code>) и установите размер таким образом, чтобы он покрыл весь блок.</li>\n  <li>Задайте для <code>&lt;h2&gt;</code> полупрозрачный чёрный цвет фона и сделайте текст белым.</li>\n</ol>\n<div class="notecard note" id="sect6">\n  <p><strong>Примечание:</strong> вы можете посмотреть <a class="external" target="_blank">решение</a> здесь — но сначала попробуйте сделать это сами!</p>\n</div></div></section><section aria-labelledby="итоги"><h2 id="итоги"><a>Итоги</a></h2><div class="section-content"><p>В этой теме мы рассмотрели довольно много, но как вы можете увидеть, возможностей по стилизации фона или границ блока намного больше. Изучите различные страницы свойств, если хотите узнать больше о каких-либо функциях, которые мы обсуждали. На каждой странице MDN есть много примеров использования свойств, с которыми вы можете поиграть и расширить свои знания.</p>\n<p>В следующем уроке мы узнаем, как Режим написания вашего документа взаимодействует с вашим CSS. Что происходит, если текст не перетекает слева направо?</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Изменение направления текста',
		
		content:
			'<header><h1>Изменение направления текста</h1></header><div class="section-content">\n<p>Многие свойства и значения, с которыми мы столкнулись до сих пор при изучении CSS, были привязаны к физическим размерам нашего экрана. Мы создаём границы, например, сверху, справа, снизу и слева от коробки.Эти физические размеры очень точно соответствуют контенту, который просматривается по горизонтали, и по умолчанию Интернет имеет тенденцию поддерживать языки с письмом слева направо (например, английский или французский) лучше, чем языки с письмом справа налево (например, арабский).</p>\n<p>Однако в последние годы CSS развивался чтобы лучше поддерживать разную направленность контента, включая контент с направлением справа налево, а также контент сверху вниз (например, в японском языке) - эти разные направления называются режимами письма. По мере того, как вы продвигаетесь в обучении и начинаете работать с макетом, понимание режимов письма будет вам очень полезно, поэтому мы сейчас и познакомимся с ними.</p>\n</div><section aria-labelledby="какие_бывают_режимы_письма"><h2 id="какие_бывают_режимы_письма"><a>Какие бывают режимы письма?</a></h2><div class="section-content"><p>Режим письма в CSS определяет, идёт ли текст по горизонтали или по вертикали. Свойство <a><code>writing-mode</code></a> позволяет нам переключаться из одного режима письма в другой. Для этого вам не обязательно работать на языке, который использует режим вертикального письма - вы также можете изменить режим письма частей вашего макета для творческих целей.</p>\n<p>В приведённом ниже примере заголовок отображается с использованием <code>writing-mode: vertical-rl</code>. Теперь текст идёт вертикально. Вертикальный текст часто используется в графическом дизайне и может быть способом добавить более интересный вид вашему веб-дизайну.</p>\n<p>Три возможных значения свойства <a><code>writing-mode</code></a>:</p>\n<ul>\n  <li><code>horizontal-tb</code>: Направление потока блока сверху вниз. Предложения идут горизонтально.</li>\n  <li><code>vertical-rl</code>: Направление потока блоков справа налево. Предложения идут вертикально.</li>\n  <li><code>vertical-lr</code>: Направление потока блока слева направо. Предложения идут вертикально.</li>\n</ul>\n<p>Таким образом, свойство <code>writing-mode</code> на самом деле устанавливает направление, в котором элементы уровня блока отображаются на странице - сверху вниз, справа налево или слева направо. Это затем определяет направление движения текста в предложениях.</p></div></section><section aria-labelledby="writing_modes_and_block_and_inline_layout"><h2 id="writing_modes_and_block_and_inline_layout"><a>Writing modes and block and inline layout</a></h2><div class="section-content"><p>We have already discussed <a>block and inline layout</a>, and the fact that some things display as block elements and others as inline elements. As we have seen described above, block and inline is tied to the writing mode of the document, and not the physical screen. Blocks are only displayed from the top to the bottom of the page if you are using a writing mode that displays text horizontally, such as English.</p>\n<p>If we look at an example this will become clearer. In this next example I have two boxes that contain a heading and a paragraph. The first uses <code>writing-mode: horizontal-tb</code>, a writing mode that is written horizontally and from the top of the page to the bottom. The second uses <code>writing-mode: vertical-rl</code>; this is a writing mode that is written vertically and from right to left.</p>\n<p>When we switch the writing mode, we are changing which direction is block and which is inline. In a <code>horizontal-tb</code> writing mode the block direction runs from top to bottom; in a <code>vertical-rl</code> writing mode the block direction runs right-to-left horizontally. So the <strong>block dimension</strong> is always the direction blocks are displayed on the page in the writing mode in use. The <strong>inline dimension</strong> is always the direction a sentence flows.</p>\n<p>This figure shows the two dimensions when in a horizontal writing mode.\n  \n</p>\n<p>This figure shows the two dimensions in a vertical writing mode.</p>\n<p>\n  \n</p>\n<p>Once you start to look at CSS layout, and in particular the newer layout methods, this idea of block and inline becomes very important. We will revisit it later on.</p></div></section><section aria-labelledby="direction"><h3 id="direction"><a>Direction</a></h3><div class="section-content"><p>In addition to writing mode we also have text direction. As mentioned above, some languages such as Arabic are written horizontally, but right-to-left. This is not something you are likely to use in a creative sense — if you simply want to line something up on the right there are other ways to do so — however it is important to understand this as part of the nature of CSS. The web is not just for languages that are displayed left-to-right!</p>\n<p>Due to the fact that writing mode and direction of text can change, newer CSS layout methods do not refer to left and right, and top and bottom. Instead they will talk about <em>start</em> and <em>end</em> along with this idea of inline and block. Don\'t worry too much about that right now, but keep these ideas in mind as you start to look at layout; you will find it really helpful in your understanding of CSS.</p></div></section><section aria-labelledby="logical_properties_and_values"><h2 id="logical_properties_and_values"><a>Logical properties and values</a></h2><div class="section-content"><p>The reason to talk about writing modes and direction at this point in your learning however, is because of the fact we have already looked at a lot of properties which are tied to the physical dimensions of the screen, and make most sense when in a horizontal writing mode.</p>\n<p>Let\'s take a look at our two boxes again — one with a <code>horizontal-tb</code> writing mode and one with <code>vertical-rl</code>. I have given both of these boxes a <a><code>width</code></a>. You can see that when the box is in the vertical writing mode, it still has a width, and this is causing the text to overflow.</p>\n<p>What we really want in this scenario, is to essentially swap height and width along with the writing mode. When we\'re in a vertical writing mode we want the box to expand in the block dimension just like it does in the horizontal mode.</p>\n<p>To make this easier, CSS has recently developed a set of mapped properties. These essentially replace physical properties — things like <code>width</code> and <code>height</code> — with <strong>logical</strong>, or <strong>flow relative</strong> versions.</p>\n<p>The property mapped to <code>width</code> when in a horizontal writing mode is called <a><code>inline-size</code></a> — it refers to the size in the inline dimension. The property for <code>height</code> is named <a><code>block-size</code></a> and is the size in the block dimension. You can see how this works in the example below where we have replaced <code>width</code> with <code>inline-size</code>.</p></div></section><section aria-labelledby="logical_margin_border_and_padding_properties"><h3 id="logical_margin_border_and_padding_properties"><a>Logical margin, border, and padding properties</a></h3><div class="section-content"><p>In the last two lessons we have learned about the CSS box model, and CSS borders. In the margin, border, and padding properties you will find many instances of physical properties, for example <a><code>margin-top</code></a>, <a><code>padding-left</code></a>, and <a><code>border-bottom</code></a>. In the same way that we have mappings for width and height there are mappings for these properties.</p>\n<p>The <code>margin-top</code> property is mapped to <a class="only-in-en-us" title="Currently only available in English (US)"><code>margin-block-start</code> <small>(en-US)</small></a> — this will always refer to the margin at the start of the block dimension.</p>\n<p>The <a><code>padding-left</code></a> property maps to <a class="only-in-en-us" title="Currently only available in English (US)"><code>padding-inline-start</code> <small>(en-US)</small></a>, the padding that is applied to the start of the inline direction. This will be where sentences start in that writing mode. The <a><code>border-bottom</code></a> property maps to <a class="only-in-en-us" title="Currently only available in English (US)"><code>border-block-end</code> <small>(en-US)</small></a>, which is the border at the end of the block dimension.</p>\n<p>You can see a comparison between physical and logical properties below.</p>\n<p><strong>If you change the writing mode of the boxes by switching the <code>writing-mode</code> property on <code>.box</code> to <code>vertical-rl</code>, you will see how the physical properties stay tied to their physical direction, whereas the logical properties switch with the writing mode.</strong></p>\n<p><strong>You can also see that the <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;h2&gt;</code> <small>(en-US)</small></a> has a black <code>border-bottom</code>. Can you work out how to make that bottom border always go below the text in both writing modes?</strong></p>\n<p>There are a huge number of properties when you consider all of the individual border longhands, and you can see all of the mapped properties on the MDN page for <a class="only-in-en-us" title="Currently only available in English (US)">Logical Properties and Values <small>(en-US)<small></small></small></a>.</p></div></section><section aria-labelledby="logical_values"><h3 id="logical_values"><a>Logical values</a></h3><div class="section-content"><p>We have so far looked at logical property names. There are also some properties that take physical values of <code>top</code>, <code>right</code>, <code>bottom</code>, and <code>left</code>. These values also have mappings, to logical values — <code>block-start</code>, <code>inline-end</code>, <code>block-end</code>, and <code>inline-start</code>.</p>\n<p>For example, you can float an image left to cause text to wrap round the image. You could replace <code>left</code> with <code>inline-start</code> as shown in the example below.</p>\n<p><strong>Change the writing mode on this example to <code>vertical-rl</code> to see what happens to the image. Change <code>inline-start</code> to <code>inline-end</code> to change the float.</strong></p>\n<p>Here we are also using logical margin values to ensure the margin is in the correct place no matter what the writing mode is.</p></div></section><section aria-labelledby="should_you_use_physical_or_logical_properties"><h3 id="should_you_use_physical_or_logical_properties"><a>Should you use physical or logical properties?</a></h3><div class="section-content"><p>The logical properties and values are newer than their physical equivalents, and therefore have only recently been implemented in browsers. You can check any property page on MDN to see how far back the browser support goes. If you are not using multiple writing modes then for now you might prefer to use the physical versions. However, ultimately we expect that people will transition to the logical versions for most things, as they make a lot of sense once you start also dealing with layout methods such as flexbox and grid.</p></div></section><section aria-labelledby="summary"><h2 id="summary"><a>Summary</a></h2><div class="section-content"><p>The concepts explained in this lesson are becoming increasingly important in CSS. An understanding of the block and inline direction — and how text flow changes with a change in writing mode — will be very useful going forward. It will help you in understanding CSS even if you never use a writing mode other than a horizontal one.</p>\n<p>In the next module we will take a good look at overflow in CSS.</p></div></section><section aria-labelledby="in_this_module"><h2 id="in_this_module"><a>In this module</a></h2><div class="section-content"><ol>\n  <li><a>Cascade and inheritance</a></li>\n  <li><a>CSS selectors</a>\n    <ul>\n      <li><a>Type, class, and ID selectors</a></li>\n      <li><a>Attribute selectors</a></li>\n      <li><a>Pseudo-classes and pseudo-elements</a></li>\n      <li><a>Combinators</a></li>\n    </ul>\n  </li>\n  <li><a>The box model</a></li>\n  <li><a>Backgrounds and borders</a></li>\n  <li><a aria-current="page">Handling different text directions</a></li>\n  <li><a>Overflowing content</a></li>\n  <li><a>Values and units</a></li>\n  <li><a>Sizing items in CSS</a></li>\n  <li><a>Images, media, and form elements</a></li>\n  <li><a>Styling tables</a></li>\n  <li><a>Debugging CSS</a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)">Organizing your CSS <small>(en-US)<small></small></small></a></li>\n</ol></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Переполнение содержимого',
		
		content:
			'<header><h1>Переполнение содержимого</h1></header><div class="section-content">\n<p>В этом уроке мы рассмотрим другую важную концепцию в CSS — <strong>переполнение</strong>. Переполнение это то, что случается когда слишком много контента содержится внутри блока. В этом гайде вы изучите что это и как этим управлять.</p>\n</div><section aria-labelledby="что_такое_переполнение"><h2 id="что_такое_переполнение"><a>Что такое переполнение?</a></h2><div class="section-content"><p>Мы уже знаем, что всё в CSS — блоки, и что мы можем ограничивать размер этих блоков, присваивая им определённое значение посредством <a><code>width</code></a> и <a><code>height</code></a> (или <a><code>inline-size</code></a> и <a><code>block-size</code></a>). Переполнение — это то, что случается, когда у вас слишком много контента в блоке, так что он не помещается в данный ограниченный размер. CSS даёт нам различные инструменты для управления переполнением, и это также полезная концепция для понимания на этой ранней стадии. Вы будете встречаться с переполнением достаточно часто, когда пишите CSS, особенно когда глубже погрузитесь в CSS раскладку.</p></div></section><section aria-labelledby="css_пытается_избежать_потери_данных"><h2 id="css_пытается_избежать_потери_данных"><a>CSS пытается избежать "потери данных"</a></h2><div class="section-content"><p>Рассмотрим два примера, демонстрирующих поведение CSS по умолчанию при возникновении переполнения.</p>\n<p>Первый пример — это блок, который был ограничен установленным параметром <code>height</code>. Затем мы добавили контент, превышающий выделенное пространство. Контент вышел за пределы поля и попал в абзац ниже.</p>\n<p>Второй пример — слово в блоке. Блок оказался слишком маленьким для этого слова, и поэтому оно выходит за его пределы.</p>\n<p>Вы можете задаться вопросом, почему CSS работает так неаккуратно, отображая контент за пределами предназначенного для него блока. Почему бы не скрывать выходящий за пределы контент? Почему бы не масштабировать размер блока, чтобы он соответствовал размеру содержимого?</p>\n<p>По возможности, CSS не скрывает контент, потому что это может привести к потере данных. Проблема состоит в том, что вы можете не заметить исчезновение данных. Посетители сайта тоже могут не заметить этого. Если кнопка отправки формы исчезнет и никто не может заполнить форму, это может стать большой проблемой! Поэтому, вместо того, чтобы скрывать выходящий за границы блока контент, CSS явно его отображает. Так вы с большей вероятностью увидите проблему при разработке. В худшем случае это заметит посетитель сайта и сообщит вам об этом.</p>\n<p>Если вы ограничиваете поле с помощью параметров <code>width</code> или <code>height</code>, CSS доверяет вам и считает, что вы знаете, что делаете. CSS предполагает, что вы управляете ситуацией и предусматриваете возможность возникновения переполнения. В общем случае, ограничение размера блока проблематично, если он содержит текст. В этом месте может быть больше текста, чем вы ожидали или его размер может быть больше (например, если пользователь увеличил размер шрифта).</p>\n<p>В следующих двух уроках объясняются различные подходы управления размерами, которые позволяют уменьшить вероятность возникновения переполнения. Однако, если вам нужен фиксированный размер блока, вы также можете контролировать поведение переполнения.</p></div></section><section aria-labelledby="свойство_overflow"><h2 id="свойство_overflow"><a>Свойство overflow</a></h2><div class="section-content"><p>Свойство <a><code>overflow</code></a> позволяет взять под контроль переполнение элемента и подсказать браузеру, как он должен себя вести. Значение overflow по умолчанию – <code>visible</code>, что означает - «показывать контент, когда он выходит за границы блока».</p>\n<p>Чтобы обрезать контент выходящий за пределы блока, вы можете установить <code>overflow: hidden</code>. Это свойство делает именно то, о чём говорит: скрывает выходящий за пределы контент. Помните, что это может сделать часть содержимого невидимым. Используйте данное значение только в том случае, если скрытие содержимого не вызовет проблем.</p>\n<p>Возможно, что при возникновении переполнения вместо скрытия вы захотите отобразить полосы прокрутки. При использовании <code>overflow: scroll</code> браузеры с видимыми полосами прокрутки всегда будут отображать их, даже если содержимого недостаточно для возникновения перекрытия. Это позволяет сохранить целостность раскладки, так как полосы прокрутки не будут появляться и пропадать в зависимости от количества содержимого в контейнере.</p>\n<p><strong>Удалите часть содержимого из поля ниже. Обратите внимание, что полосы прокрутки остаются, даже если прокрутка не требуется.</strong></p>\n<p>В приведённом выше примере нам нужно прокручивать содержимое только по оси <code>y</code>, однако мы получаем полосы прокрутки по обеим осям. Вы можете использовать свойство <a class="only-in-en-us" title="Currently only available in English (US)"><code>overflow-y</code> <small>(en-US)</small></a>, которое позволяет прокручивать содержимое только по оси <code>y</code>.</p>\n<p>Вы также можете установить прокрутку по оси x с помощью <a class="only-in-en-us" title="Currently only available in English (US)"><code>overflow-x</code> <small>(en-US)</small></a>, но это не рекомендуемый способ отображения длинных слов! Если у вас есть длинное слово в маленьком поле, вы можете использовать свойства <a><code>word-break</code></a> или <a><code>overflow-wrap</code></a>. Кроме того, некоторые методы, описанные в разделе <a>Изменение размеров в CSS</a>, могут помочь вам создавать блоки, которые лучше масштабируются с различным объемом содержимого.</p>\n<p>Как и в случае со <code>scroll</code>, вы получаете полосу прокрутки независимо от того, достаточно ли содержимого для её появления.</p>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> вы можете точно задать прокрутку по осям x и y, используя свойство <code>overflow</code>, передав два значения. Первое значение будет относиться к <code>overflow-x</code>, а второе — к <code>overflow-y</code>. Если передать одно значение, то <code>overflow-x</code> и <code>overflow-y</code> получат одинаковые значения. Например, <code>overflow: scroll hidden</code> устанавливает <code>overflow-x</code> в <code>scroll</code> и <code>overflow-y</code> в <code>hidden</code>.</p>\n</div>\n<p>Если вы хотите, чтобы полосы прокрутки отображались только тогда, когда содержимого больше, чем может поместиться в поле, используйте <code>overflow: auto</code>. Это позволяет браузеру автоматически определять, следует ли отображать полосы прокрутки.</p>\n<p><strong>В приведённом ниже примере уменьшите количество содержимого так, чтобы оно поместилось в поле. Вы должны увидеть, что полосы прокрутки исчезнут.</strong></p></div></section><section aria-labelledby="overflow_устанавливает_контекст_форматирования_блока"><h2 id="overflow_устанавливает_контекст_форматирования_блока"><a>Overflow устанавливает контекст форматирования блока</a></h2><div class="section-content"><p>Когда вы используете значение overflow, такое как <code>scroll</code> или <code>auto</code>, вы создаете <strong>контекст форматирования блока</strong> (BFC). Содержимое блока, для которого вы установили параметр <code>overflow</code> приобретает автономную раскладку. Контент вне блока не может проникнуть в блок, и ничто не может вылезти из этого блока в окружающее его пространство. Это дает возможность прокручивать содержимое, так чтобы оно не выходило за пределы блока.</p></div></section><section aria-labelledby="нежелательное_переполнение_в_веб-разработке"><h2 id="нежелательное_переполнение_в_веб-разработке"><a>Нежелательное переполнение в веб-разработке</a></h2><div class="section-content"><p>Современные методы раскладки (описанные в разделе <a>CSS раскладка</a>) справляются с переполнением очень хорошо вне зависимости от того, сколько контента будет на веб-странице.</p>\n<p>Это не всегда было нормой. В прошлом некоторые сайты были построены с блоками фиксированной высоты для выравнивания нижних границ блоков. Тем не менее эти блоки могли не иметь ничего общего между собой. Это была хрупкая конструкция. В устаревших приложениях вы можете встретить блок, в котором содержимое перекрывает другое содержимое на странице. Теперь вы понимаете, что это происходит из-за переполнения. В идеале вы должны провести рефакторинг разметки, чтобы не полагаться на блоки с фиксированной высотой.</p>\n<p>При разработке сайта всегда помните о переполнении. Тестируйте дизайны как с большим, так и с малым количеством контента. Проверяйте различные размеры шрифта текстов. Убедитесь, что ваш CSS работает надёжно. Изменение значения overflow для скрытия содержимого или добавления полос прокрутки, должно использоваться только при необходимости (например там, где вы хотите использовать прокручиваемый блок).</p></div></section><section aria-labelledby="проверьте_свои_навыки!"><h2 id="проверьте_свои_навыки!"><a>Проверьте свои навыки!</a></h2><div class="section-content"><p>В этой статье мы рассмотрели многое, но можете ли вы вспомнить самую важную информацию? Вы можете найти дополнительные тесты, чтобы убедиться, что вы усвоили эту информацию, прежде чем двигаться дальше – см. <a class="only-in-en-us" title="Currently only available in English (US)">Проверь свои навыки: переполнение <small>(en-US)<small></small></small></a>.</p></div></section><section aria-labelledby="заключение"><h2 id="заключение"><a>Заключение</a></h2><div class="section-content"><p>В этом уроке была представлена концепция переполнения. Важно понимать, что CSS по умолчанию старается избежать обрезания выходящего за границы блока содержимого. Мы изучили, как можно справиться с возникшим переполнением, а также рассмотрели важность тестирования поведения веб-страниц как с малым количеством контента, так и с большим.</p></div></section><section aria-labelledby="in_this_module"><h2 id="in_this_module"><a>In this module</a></h2><div class="section-content"><ol>\n  <li><a>Каскад и наследование</a></li>\n  <li><a>Селекторы CSS</a>\n    <ul>\n      <li><a>Селекторы типа, класса и ID</a></li>\n      <li><a>Селекторы атрибута</a></li>\n      <li><a>Псевдоклассы и псевдоэлементы</a></li>\n      <li><a>Комбинаторы</a></li>\n    </ul>\n  </li>\n  <li><a>Блочная модель(The box model)</a></li>\n  <li><a>Фон и границы</a></li>\n  <li><a>Обработка разных направлений текста</a></li>\n  <li><a aria-current="page">Переполнение содержимого</a></li>\n  <li><a>Значения и единицы измерения</a></li>\n  <li><a>Размеры в CSS</a></li>\n  <li><a>Элементы изображений, форм и медиа-элементы</a></li>\n  <li><a>Стилизация таблиц</a></li>\n  <li><a>Отладка CSS</a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)">Организация вашей CSS <small>(en-US)<small></small></small></a></li>\n</ol></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Значения свойств CSS',
		
		content:
			'<header><h1>Значения свойств CSS</h1></header><div class="section-content">\n<p>Каждое свойство используемое в CSS имеет значение или набор значений которые допустимы для этого свойства, и изучение страниц MDN со свойствами поможет вам понять какие значения валидны для того или иного свойства. В этом уроке мы рассмотрим некоторые наиболее общие значения и единицы в использовании.</p>\n</div><section aria-labelledby="что_такое_значение_css"><h2 id="что_такое_значение_css"><a>Что такое значение CSS?</a></h2><div class="section-content"><p>В спецификациях CSS и на страницах свойств здесь в MDN вы сможете определять (узнавать) значения, потому как они будут заключены в угловые скобки, например <a><code>&lt;color&gt;</code></a> или <a><code>&lt;length&gt;</code></a>. Если вы видите значение <code>&lt;color&gt;</code> как действительное для определённого свойства это значит что вы можете использовать любой валидный цвет в качестве значение для этого свойства, как перечислено на странице <a><code>&lt;color&gt;</code></a><a>.</a></p>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> You\'ll also see CSS values referred to as <em>data types</em>. The terms are basically interchangeable — when you see something in CSS referred to as a data type, it is really just a fancy way of saying value.</p>\n</div>\n<div class="notecard note" id="sect2">\n  <p><strong>Примечание:</strong> Yes, CSS values tend to be denoted using angle brackets, to differentiate them from CSS properties (e.g. the <a class="only-in-en-us" title="Currently only available in English (US)"><code>color</code> <small>(en-US)</small></a> property, versus the <a>&lt;color&gt;</a> data type). You might get confused between CSS data types and HTML elements too, as they both use angle brackets, but this is unlikely — they are used in very different contexts.</p>\n</div>\n<p>В следующем примере мы установили цвет нашего заголовка используя ключевое слово и фон используя функцию <code>rgb()</code>:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">h1 {\n  color: black;\n  background-color: rgb(197, 93, 161);\n}\n</pre></div>\n<p>Значение в CSS это путь определения коллекции допустимых под-значений. То есть если вы видите <code>&lt;color&gt;</code> как применённый, то вам не надо озадачиваться какой из разных типов значения цвета может быть использован — ключевое слово, hex значение, функция <code>rgb()</code> и т.д. Вы можете воспользоваться <em>любым</em> доступным значением <code>&lt;color&gt;</code> при условии, что они поддерживаются вашим браузером. Страницы для всех значений на MDN дадут вам информацию о поддержке браузеров. Например, если вы посмотрите на страницу <a><code>&lt;color&gt;</code></a> то вы увидите раздел совместимости браузеров в котором перечислены различные типы значений цвета и их поддержка.</p>\n<p>Давайте посмотрим на некоторые типы значений и единиц с примерами чтобы вы могли опробовать различные возможные значения, с которыми вы можете часто сталкиваться.</p></div></section><section aria-labelledby="числа_длины_и_проценты"><h2 id="числа_длины_и_проценты"><a>Числа, длины и проценты</a></h2><div class="section-content"><p>Существуют различные типы числовых данных, которые вы можете использовать в CSS. Следующие типы классифицируются как числовые:</p>\n</div></section><section aria-labelledby="длины"><h3 id="длины"><a>Длины</a></h3><div class="section-content"><p>Числовой тип, с которым вы будете сталкиваться чаще всего это <code>&lt;length&gt;</code> (длина), например <code>10px</code> (пиксели) или <code>30em</code>. Существует два типа длин используемых в CSS — относительные и абсолютные. Важно знать разницу для того, чтобы понимать, насколько большими станут вещи.</p>\n<h4 id="абсолютные_единицы_длины">Абсолютные единицы длины</h4>\n<p>Ниже приведены все единицы абсолютной длины — они не являются относительными к чему-либо и обычно считаются всегда одинакового размера.</p>\n\n<p>Большинство из этих значений больше полезны при использовании печати, чем для вывода на экран. Например, мы обычно не используем <code>cm</code> (сантиметры) на экране. Единственное значение которое вы в основном будете использовать это <code>px</code> (пиксели).</p>\n<h4 id="единицы_относительной_длины">Единицы относительной длины</h4>\n<p>Относительные единицы длин являются относительными к чему-то ещё, возможно к размеру родительского шрифта или к размеру окна просмотра. Преимущество использования относительных единиц состоит в том, что при тщательном планировании вы можете сделать так, чтобы размер текста или других элементов масштабировался относительно всего остального на странице. Некоторые наиболее используемые единицы веб-разработки перечислены в таблице ниже.</p>\n\n<h4 id="изучение_на_примере">Изучение на примере</h4>\n<p>В примере ниже вы можете увидеть, как некоторые относительные и абсолютные единицы длин ведут себя. Первый блок имеет <a><code>width</code></a> (ширину) установленную в пикселях. Как абсолютная единица эта ширина будет оставаться такой же неважно что ещё измениться.</p>\n<p>Второй блок имеет ширину, установленную в единицах <code>vw</code> (ширина окна просмотра). Это значение относительно к ширине окна просмотра и таким образом 10vw это 10 процентов от ширины окна просмотра. Если вы измените ширину окна вашего браузера, размер блока должен измениться, однако этот пример встроен в страницу с использованием <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;iframe&gt;</code> <small>(en-US)<small></small></small></a>, поэтому это не сработает. Для того чтобы увидеть это в действии вы должны <a class="external" target="_blank">открыть этот пример в отдельной вкладке браузера</a>.</p>\n<p>Третий блок использует единицы <code>em</code>. Они относительны к размеру шрифта. Я установил размер шрифта <code>1em</code> для содержимого <a><code>&lt;div&gt;</code></a>, который имеет класс <code>.wrapper</code>. Измените это значение на <code>1.5em</code> и вы увидите что, размер шрифта всех этих элементов увеличится, но только последний объект станет шире, поскольку его ширина относительна к тому размера шрифта.</p>\n<p>После выполнения инструкция выше, попробуйте поиграть со значениями и посмотрите, что у вас получится.</p>\n<h4 id="em_и_rem">em и rem</h4>\n<p><code>em</code> и <code>rem</code> — две относительные длины, с которыми вы вероятное всего сталкиваетесь чаще при разметке чего-либо от блоков до текста. Стоит понимать как они работают, понимать различия между ними, особенно когда вы начинаете переходить к более сложным темам как <a>стилизация текста</a> или <a>разметка CSS</a>. Приведённый ниже пример показывает это.</p>\n<p>HTML это набор вложенных списков — у нас имеется три списка в общей сложности и оба примера имеют одинаковый HTML. Единственное различие в том, что первый имеет класс <em>ems,</em> а второй класс <em>rems</em>.</p>\n<p>Чтобы начать, мы установили 16px для размера шрифта элемента <code>&lt;html&gt;</code>.</p>\n<p><strong>Повторим, единица em означает "размер шрифта родительского элемента"</strong>. Элементы <a><code>&lt;li&gt;</code></a> внутри <a><code>&lt;ul&gt;</code></a> с классом <code>ems</code> получают свои размеры от своего родителя. Так, каждый последующий уровень вложения становится прогрессивно больше, так как каждый имеет свой размер шрифта установленный на <code>1.3em</code> — 1.3 раза от размера шрифта родителя.</p>\n<p><strong>Повторим, единица rem означает "размер шрифта корневого элемента"</strong> (rem значит "root em". (root - корень)). Элементы <a><code>&lt;li&gt;</code></a> внутри <a><code>&lt;ul&gt;</code></a> с классом <code>rems</code> получают свои размеры от корневого элемента (<code>&lt;html&gt;</code>). Это значит, что каждый последующий уровень вложения не продолжает увеличиваться.</p>\n<p>Однако, если вы измените <code>font-size</code> (размер шрифта) <code>&lt;html&gt;</code> в CSS, вы увидите что все остальное изменится относительно ему — и <code>rem</code>- и <code>em</code>-размеры текста</p></div></section><section aria-labelledby="проценты"><h3 id="проценты"><a>Проценты</a></h3><div class="section-content"><p>Во многих случаях проценты обрабатываются таким же образом, как и длина. С процентами фишка в том, что они всегда устанавливаются относительно некоторого другого значения. Например, если вы установите <code>font-size</code> элемента как проценты, то это будет процент от <code>font-size</code> родительского элемента. Если вы используете процент для значения <code>width</code> (ширина), то это будет процент от <code>width</code> родителя.</p>\n<p>В примере ниже два блока с размерами в процентах и два с размерами в пикселях имеющих одинаковые имена классов. Оба набора имеют ширину 200px и 40% соответственно.</p>\n<p>Различие в том, что второй набор блоков находится внутри обёртки которая имеет ширину 400 пикселей. Второй блок шириной в 200px имеет ту же ширину что и первый, но второй 40 процентный блок теперь имеет 40% от 400px — намного уже чем первый.</p>\n<p><strong>Попробуйте изменить ширину обёртки (.wrapper) или процентное значение чтобы увидеть, как это работает.</strong></p>\n<p>В следующем примере размер шрифта установлен в процентах. Каждый <code>&lt;li&gt;</code> имеет <code>font-size</code> 80%, поэтому элементы вложенного списка становятся прогрессивно меньше так как они наследуют свои размеры от родителя.</p>\n<p>Обратите внимание, в то время как многие значения принимают как длину, так и проценты, существуют те, которые принимают только длину. Вы можете посмотреть какие значения допустимы на справочной странице свойств MDN. Если допустимые значения включают <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;length-percentage&gt;</code> <small>(en-US)<small></small></small></a>, тогда вы можете использовать и длину, и проценты. Если же допустимые значения включают только <code>&lt;length&gt;</code>, то использование процентов невозможно.</p></div></section><section aria-labelledby="числа"><h3 id="числа"><a>Числа</a></h3><div class="section-content"><p>Некоторые значения принимают числа без каких-либо единиц измерения. Примером свойства принимающего числа без единиц измерения может служить свойство <code>opacity</code>, которое контролирует мутность элемента (настолько он прозрачен). Это свойство принимает числа между <code>0</code> (полностью прозрачное) и <code>1</code> (полностью мутное).</p>\n<p><strong>В примере ниже, попробуйте изменить значение</strong> <strong><code>opacity</code></strong> <strong>на различные десятичные значения между</strong> <strong><code>0</code></strong> <strong>и</strong> <strong><code>1</code></strong> <strong>и посмотрите, как блок и его содержимое становится более и/или менее мутными.</strong></p>\n<div class="notecard note" id="sect3">\n  <p><strong>Примечание:</strong> Когда вы используете числа в CSS в качестве значений, они не должны быть заключены в кавычки.</p>\n</div></div></section><section aria-labelledby="цвет"><h2 id="цвет"><a>Цвет</a></h2><div class="section-content"><p>Существует много способов определения цвета в CSS, некоторые из которых реализованы довольно-таки недавно по сравнению с другими. Одинаковые значения цвета могут использоваться везде в CSS, определяете ли вы при этом цвет текста, цвет фона или цвет чего-либо ещё.</p>\n<p>Стандартная система цветов доступная в современных компьютерах — это 24-битная система, которая позволяет отображать около 16.7 миллионов отдельных цветов через комбинацию различных красных, зелёных и синих каналов с 256 различными значениями каждого канала (256 x 256 x 256 = 16,777,216). Давайте взглянем на некоторые способы, с помощью которых мы можем определять цвет в CSS.</p>\n<div class="notecard note" id="sect4">\n  <p><strong>Примечание:</strong> В этом руководстве мы рассмотрим общие методы определения цвета, которые имеют хорошую поддержку браузерами; существуют и другие методы, но они не имеют столь же хорошей поддержки и являются менее общими.</p>\n</div></div></section><section aria-labelledby="ключевые_слова_цвета"><h3 id="ключевые_слова_цвета"><a>Ключевые слова цвета</a></h3><div class="section-content"><p>Довольно часто в примерах как здесь, так и на других страницах в MDN вы будете видеть использование ключевых слов цвета, поскольку это простой и понятный способ определения цвета. Существует определённое количество этих ключевых слов и некоторые их них имеют довольно занимательные имена! Полный список вы можете посмотреть на странице значений <a><code>&lt;color&gt;</code></a> .</p>\n<p><strong>Попробуйте поиграть с разными значениями цвета на живом примере ниже, чтобы понять больше об идее как они работают.</strong></p></div></section><section aria-labelledby="шестнадцатеричные_rgb_значения"><h3 id="шестнадцатеричные_rgb_значения"><a>Шестнадцатеричные RGB значения</a></h3><div class="section-content"><p>Следующий тип значения цвета, с которым вы сталкиваетесь вероятнее всего — это шестнадцатеричные коды. Каждое hex-значение состоит из символа решётки (#) за которым следуют 6 шестнадцатеричных чисел, каждое из которых может принимать одно из 16 значений от 0 до f (представляющая 15) — то есть <code>0123456789abcdef</code>. Каждая пара значений представляет один из каналов — красного, зелёного или синего цветов — и позволяет нам определять любой из 256 доступных значений для каждого (16 x 16 = 256).</p>\n<p>Эти значения являются немного более сложными и менее простыми для понимания, но они намного более универсальны чем ключевые слова — вы можете использовать hex-значения чтобы отобразить любой цвет, который вы хотите использовать в своей цветовой схеме.</p>\n<p><strong>И снова, попробуйте изменить значения, чтобы посмотреть, как варьируют цвета.</strong></p></div></section><section aria-labelledby="rgb_и_rgba_значения"><h3 id="rgb_и_rgba_значения"><a>RGB и RGBA значения</a></h3><div class="section-content"><p>Третья схема, о которой мы здесь поговорим это RGB. Значения RGB это функция — <code>rgb()</code> — которой даётся три параметра представляющих каналы красного, зелёного и синего значений цветов, во многом так же, как hex-значения. Отличие с RGB является то, что каждый канал представлен не двумя hex-цифрами, а десятичным числом между 0 и 255 — что отчасти проще в понимании.</p>\n<p>Давайте перепишем наш последний пример используя RGB цвета:</p>\n<p>А также вы можете использовать цвета RGBA — что работает в точности, как и цвета RGB и то есть вы можете использовать любое значение RGB, однако существует четвёртое значение, которое представляет альфа канал цвета, которое контролирует мутность. Если вы установите это значение на <code>0</code>, то это сделает цвет полностью прозрачным, тогда как <code>1</code> сделает его полностью мутным. Значения между дают вам разные уровни прозрачности.</p>\n<div class="notecard note" id="sect5">\n  <p><strong>Примечание:</strong> Настройка альфа канала в цвете имеет одно ключевое различие в использовании свойства <a><code>opacity</code></a> которое мы рассматривали ранее. когда вы используете мутность вы делаете элемент и все внутри него мутным, тогда как при использовании цвета RGBA вы делаете мутным только тот цвет который вы специфицируете.</p>\n</div>\n<p>In the example below I have added a background image to the containing block of our colored boxes. I have then set the boxes to have different opacity values — notice how the background shows through more when the alpha channel value is smaller.</p>\n<p><strong>In this example, try changing the alpha channel values to see how it affects the color output.</strong></p>\n<div class="notecard note" id="sect6">\n  <p><strong>Примечание:</strong> At some point modern browsers were updated so that <code>rgba()</code> and <code>rgb()</code>, and <code>hsl()</code> and <code>hsla()</code> (see below), became pure aliases of each other and started to behave exactly the same. So for example both <code>rgba()</code> and <code>rgb()</code> accept colors with and without alpha channel values. Try changing the above example\'s <code>rgba()</code> functions to <code>rgb()</code> and see if the colors still work! Which style you use is up to you, but separating out non-transparent and transparent color definitions to use the different functions gives (very) slightly better browser support and can act as a visual indicator of where transparent colors are being defined in your code.</p>\n</div></div></section><section aria-labelledby="hsl_and_hsla_values"><h3 id="hsl_and_hsla_values"><a>HSL and HSLA values</a></h3><div class="section-content"><p>Slightly less well-supported than RGB is the HSL color model (not supported on old versions of IE), which was implemented after much interest from designers. Instead of red, green, and blue values, the <code>hsl()</code> function accepts hue, saturation, and lightness values, which are used to distinguish between the 16.7 million colors, but in a different way:</p>\n<ul>\n  <li><strong>Hue</strong>: The base shade of the color. This takes a value between 0 and 360, representing the angles round a color wheel.</li>\n  <li><strong>Saturation</strong>: How saturated is the color? This takes a value from 0–100%, where 0 is no color (it will appear as a shade of grey), and 100% is full color saturation</li>\n  <li><strong>Lightness</strong>: How light or bright is the color? This takes a value from 0–100%, where 0 is no light (it will appear completely black) and 100% is full light (it will appear completely white)</li>\n</ul>\n<p>We can update the RGB example to use HSL colors like this:</p>\n<p>Just as RGB has RGBA, HSL has an HSLA equivalent, which gives you the same ability to specify the alpha channel. I\'ve demonstrated this below by changing my RGBA example to use HSLA colors.</p>\n<p>You can use any of these color values in your projects. It is likely that for most projects you will decide on a color palette and then use those colors — and your chosen method of specifying color — throughout the whole project. You can mix and match color models, however for consistency it is usually best if your entire project uses the same one!</p></div></section><section aria-labelledby="images"><h2 id="images"><a>Images</a></h2><div class="section-content"><p>The <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;image&gt;</code> <small>(en-US)<small></small></small></a> data type is used wherever an image is a valid value. This can be an actual image file pointed to via a <code>url()</code> function, or a gradient.</p>\n<p>In the example below we have demonstrated an image and a gradient in use as a value for the CSS <code>background-image</code> property.</p>\n<div class="notecard note" id="sect7">\n  <p><strong>Примечание:</strong> there are some other possible values for <code>&lt;image&gt;</code>, however these are newer and currently have poor browser support. Check out the page on MDN for the <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;image&gt;</code> <small>(en-US)<small></small></small></a> data type if you want to read about them.</p>\n</div></div></section><section aria-labelledby="position"><h2 id="position"><a>Position</a></h2><div class="section-content"><p>The <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;position&gt;</code> <small>(en-US)<small></small></small></a> data type represents a set of 2D coordinates, used to position an item such as a background image (via <a><code>background-position</code></a>). It can take keywords such as <code>top</code>, <code>left</code>, <code>bottom</code>, <code>right</code>, and <code>center</code> to align items with specific bounds of a 2D box, along with lengths, which represent offsets from the top and left-hand edges of the box.</p>\n<p>A typical position value consists of two values — the first sets the position horizontally, the second vertically. If you only specify values for one axis the other will default to <code>center</code>.</p>\n<p>In the following example we have positioned a background image 40px from the top and to the right of the container using a keyword.</p>\n<p><strong>Play around with these values to see how you can push the image around.</strong></p></div></section><section aria-labelledby="strings_and_identifiers"><h2 id="strings_and_identifiers"><a>Strings and identifiers</a></h2><div class="section-content"><p>Throughout the examples above, we\'ve seen places where keywords are used as a value (for example <code>&lt;color&gt;</code> keywords like <code>red</code>, <code>black</code>, <code>rebeccapurple</code>, and <code>goldenrod</code>). These keywords are more accurately described as <em>identifiers</em>, a special value that CSS understands. As such they are not quoted — they are not treated as strings.</p>\n<p>There are places where you use strings in CSS, for example <a>when specifying generated content</a>. In this case the value is quoted to demonstrate that it is a string. In the below example we use unquoted color keywords along with a quoted generated content string.</p></div></section><section aria-labelledby="functions"><h2 id="functions"><a>Functions</a></h2><div class="section-content"><p>The final type of value we will take a look at is the group of values known as functions. In programming, a function is a reusable section of code that can be run multiple times to complete a repetitive task with minimum effort on the part of both the developer and the computer. Functions are usually associated with languages like JavaScript, Python, or C++, but they do exist in CSS too, as property values. We\'ve already seen functions in action in the Colors section — <code>rgb()</code>, <code>hsl()</code>, etc. The value used to return an image from a file — <code>url()</code> — is also a function.</p>\n<p>A value that behaves more like something you might find in a traditional programming language is the <code>calc()</code> CSS function. This function gives you the ability to do simple calculations inside your CSS. It\'s particularly useful if you want to work out values that you can\'t define when writing the CSS for your project, and need the browser to work out for you at runtime.</p>\n<p>For example, below we are using <code>calc()</code> to make the box <code>20% + 100px</code> wide. The 20% is calculated from the width of the parent container <code>.wrapper</code> and so will change if that width changes. We can\'t do this calculation beforehand because we don\'t know what 20% of the parent will be, so we use <code>calc()</code> to tell the browser to do it for us.</p></div></section><section aria-labelledby="summary"><h2 id="summary"><a>Summary</a></h2><div class="section-content"><p>This has been a quick run through of the most common types of values and units you might encounter. You can have a look at all of the different types on the <a class="only-in-en-us" title="Currently only available in English (US)">CSS Values and units <small>(en-US)<small></small></small></a> reference page; you will encounter many of these in use as you work through these lessons.</p>\n<p>The key thing to remember is that each property has a defined list of allowed values, and each value has a definition explaining what the sub-values are. You can then look up the specifics here on MDN.</p>\n<p>For example, understanding that <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;image&gt;</code> <small>(en-US)<small></small></small></a> also allows you to create a color gradient is useful but perhaps non-obvious knowledge to have!</p></div></section><section aria-labelledby="in_this_module"><h2 id="in_this_module"><a>In this module</a></h2><div class="section-content"><ol>\n  <li><a>Cascade and inheritance</a></li>\n  <li><a>CSS selectors</a>\n    <ul>\n      <li><a>Type, class, and ID selectors</a></li>\n      <li><a>Attribute selectors</a></li>\n      <li><a>Pseudo-classes and pseudo-elements</a></li>\n      <li><a>Combinators</a></li>\n    </ul>\n  </li>\n  <li><a>The box model</a></li>\n  <li><a>Backgrounds and borders</a></li>\n  <li><a>Handling different text directions</a></li>\n  <li><a>Overflowing content</a></li>\n  <li><a aria-current="page">Values and units</a></li>\n  <li><a>Sizing items in CSS</a></li>\n  <li><a>Images, media, and form elements</a></li>\n  <li><a>Styling tables</a></li>\n  <li><a>Debugging CSS</a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)">Organizing your CSS <small>(en-US)<small></small></small></a></li>\n</ol></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Изменение размеров в CSS',
		
		content:
			'<header><h1>Изменение размеров в CSS</h1></header><div class="section-content">\n<p>В предыдущих уроках вы познакомились с некоторыми способами изменения размеров элементов на веб-странице с помощью CSS. Понимание того, насколько велики будут различные элементы в вашем дизайне — важно, и в этом уроке мы подведем итог по различным способам задания размеров элементов с помощью CSS и расскажем о некоторых терминах, связанных с размерами, которые помогут вам в будущем.</p>\n</div><section aria-labelledby="размер_по_умолчанию_или_внутренний_размер"><h2 id="размер_по_умолчанию_или_внутренний_размер"><a>Размер по умолчанию или внутренний размер</a></h2><div class="section-content"><p>Элементы HTML имеют размеры по умолчанию, заданные до того, как на них повлияет какое-либо правило CSS. Простой пример — изображение. Изображение имеет ширину и высоту, определенные в файле изображения. Этот размер называется — <strong>внутренний размер</strong>, он исходит из самого изображения.</p>\n<p>Если вы разместите изображение на странице и не измените его высоту и ширину, используя атрибуты тега <code>&lt;img&gt;</code> или CSS, оно будет отображаться с использованием этого внутреннего размера. В примере ниже, мы установили для изображения рамку, чтобы вы могли видеть размер файла.</p>\n<p>С другой стороны, пустой <a><code>&lt;div&gt;</code></a> не имеет собственного размера. Если вы добавите <a><code>&lt;div&gt;</code></a> в свой HTML-код без содержимого, а затем установите для него рамку, как мы это делали с изображением, вы увидите линию на странице. Это схлопнувшиеся границы элемента — содержимое, которое могло бы удерживать ее в открытом состоянии, отсутствует. В нашем примере ниже эта граница растягивается на всю ширину контейнера, потому что это элемент блочный, поведение которого должно быть вам знакомо. У него нет высоты, потому что нет содержимого.</p>\n<p>В приведенном выше примере попробуйте добавить текст внутри пустого элемента. Этот текст теперь становится охваченным границами, потому что высота элемента определяется содержимым. Следовательно, размер этого <code>&lt;div&gt;</code> устанавливается размером содержимого. Как и в предыдущем примере, этот размер является внутренним размером — размер элемента определяется размером его содержимого.</p></div></section><section aria-labelledby="присваивание_определенного_размера"><h2 id="присваивание_определенного_размера"><a>Присваивание определенного размера</a></h2><div class="section-content"><p>Конечно, мы можем задать элементам нашей страницы определенный размер. Размер, который присваивается элементу (содержимое, которого затем должно соответствовать этому размеру), называется <strong>внешним размером</strong>. Возьмите наш <code>&lt;div&gt;</code> из примера выше и установите ему специальные значения <a><code>width</code></a> и <a><code>height</code></a> и теперь он будет иметь эти размеры, независимо от того, какого размера содержимое в него помещается. Как мы узнали в <a>нашем предыдущем уроке о переполнении</a>, заданная высота блока может вызвать переполнение содержимого, если размер содержимого больше, чем внутреннее пространство элемента.</p>\n<p>Из-за этой проблемы перекрытия, жестко задавать высоту элементов с помощью длины или процентного соотношения — это то, что нужно делать с большой осторожностью.</p></div></section><section aria-labelledby="использование_процентного_соотношения"><h3 id="использование_процентного_соотношения"><a>Использование процентного соотношения</a></h3><div class="section-content"><p>Во многих отношениях проценты действуют как единицы длины, и, как мы <a>обсуждали в уроке, посвященном значениям и единицам</a>, они часто могут использоваться как взаимозаменяемые с длиной. При использовании процентов вы должны знать, <em>от чего этот процент рассчитывается</em>. В случае блока внутри другого блока, если вы зададите дочернему блоку процентную ширину, это будет процент от ширины родительского контейнера.</p>\n<p>Это потому, что проценты рассчитываются в зависимости от размера содержащего элемент блока. Если процентное соотношение не применяется, наш <code>&lt;div&gt;</code> будет занимать 100% доступного пространства, так как это элемент блочного типа. Если мы зададим ему ширину в процентах, он займет процент от пространства, которое он обычно заполняет.</p></div></section><section aria-labelledby="margins_и_paddings_в_процентах"><h3 id="margins_и_paddings_в_процентах"><a>Margins и paddings в процентах</a></h3><div class="section-content"><p>Если вы установите <code>margins</code> и <code>padding</code> в процентах, вы можете заметить странное поведение. В приведенном ниже примере у нас есть блок. Мы присвоили внутреннему блоку <a><code>margin</code></a> 10% и <a><code>padding</code></a> 10%. Padding и margin сверху и снизу имеют тот же размер, что и margins слева и справа.</p>\n<p>Например, вы можете ожидать, что процентное значение верхнего и нижнего margins будет в процентах от высоты элемента, а процентное левое и правое margins — в процентах от ширины элемента. Тем не менее, это не так!</p>\n<p>При использовании margins и padding, заданных в процентах, значение рассчитывается на основе <strong>inline размера</strong> блока — следовательно, ширины при работе с горизонтальным языком. В нашем примере все поля и отступы составляют 10% width. Это означает, что вы будете иметь margins и padding одинакового размера по всему полю. Этот факт стоит запомнить, если вы действительно пользуетесь процентами.</p></div></section><section aria-labelledby="минимальные_и_максимальные_размеры"><h2 id="минимальные_и_максимальные_размеры"><a>Минимальные и максимальные размеры</a></h2><div class="section-content"><p>Помимо возможности установить фиксированный размер, мы можем использовать CSS чтобы задать элементу минимальный или максимальный размер. Если у вас есть блок, который может содержать разное количество содержимого, и вы хотите, чтобы он всегда был определенной минимальной высоты, вы можете установить для него свойство <a><code>min-height</code></a>. Блок всегда будет минимальной заданной высоты, пока содержимого не станет больше, чем места в блоке.</p>\n<p>В приведенном ниже примере вы можете увидеть два блока, обоим задали минимальную высоту в 150 пикселей. Блок слева имеет высоту 150 пикселей несмотря на то что в нем нет текста. В блоке справа есть контент, которому нужно больше места, чем минимальная заданная высота, поэтому он увеличился.</p>\n<p>Это очень полезно при работе с переменным объемом контента, избегая при этом переполнения.</p>\n<p>Часто <a><code>max-width</code></a> применяют для уменьшения масштаба изображений, если недостаточно места для их отображения.</p>\n<p>Например, если бы вы установили <code>width: 100%</code> для изображения, а его внутренняя ширина была меньше, чем его контейнер, изображение было бы вынуждено растягиваться и становиться больше, в результате чего оно выглядело бы пикселизированным.</p>\n<p>Если бы вы вместо этого применили <code>max-width: 100%</code>, и внутренняя ширина изображения была бы меньше, чем его контейнер, изображение не будет принудительно растягиваться и становиться больше, что предотвращает пикселизацию.</p>\n<p>В приведенном ниже примере мы использовали одно и то же изображение трижды. Первому изображению было задано <code>width: 100%</code> и оно находится в контейнере, который больше его ширины, поэтому он растягивается до ширины контейнера. Второму изображению задано <code>max-width: 100%</code>, изображение достигло 100% своей ширины не растягивается, чтобы заполнить контейнер. Третье поле снова содержит то же изображение, также с <code>max-width: 100%</code> в этом случае вы можете увидеть, как он уменьшилось, чтобы поместиться в контейнер.</p>\n<p>Этот метод используется для создания <em>отзывчивых</em> изображений, чтобы при просмотре на меньшем устройстве они соответствующим образом уменьшались. Однако вам не следует использовать эту технику для загрузки действительно больших изображений с последующим их уменьшением в браузере. Изображения должны иметь соответствующий размер, чтобы быть не больше, чем они должны быть для самого большого размера, отображаемого в дизайне. Загрузка слишком больших изображений замедлит работу вашего сайта и может стоить пользователям больше денег, если они используют лимитированное соединение.</p>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> Узнайте больше о <a>методах создания адаптивных изображений</a>.</p>\n</div></div></section><section aria-labelledby="единицы_вьюпорта"><h2 id="единицы_вьюпорта"><a>Единицы вьюпорта</a></h2><div class="section-content"><p>Вьюпо́рт — это видимая область вашей страницы в браузере, который вы используете для просмотра сайта. В CSS у нас есть единицы измерения, которые относятся к размеру вьюпорта — <code>vw</code> единицы ширины вьюпорта и <code>vh</code> высоты вьюпорта. Используя эти единицы измерения, вы можете изменять размер чего-либо относительно вьюпорта пользователя.</p>\n<p><code>1vh</code> равен 1% от высоты вьюпорта и <code>1vw</code> равен 1% ширины вьюпорта. Вы можете использовать эти единицы измерения для размеров блоков, а также текста. В приведенном ниже примере у нас есть блок размером 20vh и 20vw. В блоке есть буква <code>A</code>, которой присвоено значение <a><code>font-size</code></a> 10vh.</p>\n<p><strong>Если вы измените величину <code>vh</code> и <code>vw</code> — это изменит размер блока или шрифт; изменение размера вьюпорта также изменит их размеры, поскольку они имеют размер заданный относительно вьюпорта. Чтобы увидеть изменение примера при изменении размера вьюпорта, вам нужно будет загрузить пример в новое окно браузера, размер которого можно изменить (поскольку встроенное приложение <code>&lt;iframe&gt;</code>, содержащее показанный выше пример, является его окном просмотра). <a class="external" target="_blank">Откройте пример</a>, измените размер окна браузера и посмотрите, что происходит с размером поля и текста.</strong></p>\n<p>Размеры объектов задаваемые в соответствии с вьюпортом могут быть полезны в ваших проектах. Например, если вы хотите, чтобы основная секция отображалась перед остальным контентом, установите для этой части страницы высоту 100vh, это приведет к выталкиванию остального контента ниже видимой области, что означает, что он появится только после того, как страницу прокрутят вниз.</p></div></section><section aria-labelledby="проверьте_свои_навыки!"><h2 id="проверьте_свои_навыки!"><a>Проверьте свои навыки!</a></h2><div class="section-content"><p>В этой статье мы рассмотрели многое, но можете ли вы вспомнить самую важную информацию? Вы можете найти дополнительные тесты, чтобы убедиться, что вы сохранили эту информацию, прежде чем двигаться дальше - см. <a class="only-in-en-us" title="Currently only available in English (US)">Проверка своих навыков: задание размеров <small>(en-US)<small></small></small></a>.</p></div></section><section aria-labelledby="заключение"><h2 id="заключение"><a>Заключение</a></h2><div class="section-content"><p>Этот урок дал вам краткое изложение некоторых ключевых проблем, с которыми вы можете столкнуться при определении размеров объектов в Интернете. Когда вы перейдете к <a>CSS раскладке</a>, изменение размеров станет очень важным для освоения различных методов раскладки, поэтому перед тем, как двигаться дальше, стоит разобраться в концепциях.</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Элементы изображений, медиа и форм',
		
		content:
			'<header><h1>Элементы изображений, медиа и форм</h1></header><div class="section-content">\n<p>В этом уроке мы рассмотрим, как обрабатываются определённые специальные элементы в CSS. Элементы изображений, других медиа и форм ведут себя иначе при их стилизации в CSS чем обычные блоки. Понимание того, что возможно, а что нет спасут вас от лишних разочарований и этот урок прольёт свет на некоторые из этих основных вещей, которые вам нужно знать.</p>\n</div><section aria-labelledby="замещаемые_элементы"><h2 id="замещаемые_элементы"><a>Замещаемые элементы</a></h2><div class="section-content"><p>Изображения и видео описываются как <strong><a>Замещаемые элементы</a></strong>. Это значит, что CSS не может влиять на внутреннюю планировку этих элементов — только на их позицию на странице среди других элементов. Однако, как мы увидим, существуют различные вещи, которые CSS может сделать с изображением.</p>\n<p>Конкретные замещаемые элементы, такие как изображения и видео, можно также описать, как элементы имеющие <strong>соотношение сторон</strong>. Это значит, что такой элемент имеет размер как по горизонтали (x) так и по вертикали (y) и будет отображаться используя "родные" размеры файла по умолчанию.</p></div></section><section aria-labelledby="размер_изображений_калибровка"><h2 id="размер_изображений_калибровка"><a>Размер изображений (калибровка)</a></h2><div class="section-content"><p>Как вы уже знаете из этих уроков, всё в CSS генерирует блоки. Если вы поместите файл изображения внутрь блока, который больше или меньше исходного размера файла изображения в обоих направлениях, то он отобразиться либо в меньшем размере чем блок, либо перекроет его. Вам нужно принять решение с тем, что произойдёт с перекрытием.</p>\n<p>В примере ниже у нас два блока, оба имеют размер по 200px:</p>\n<ul>\n  <li>Один содержит изображение, которое 200px — оно меньше, чем блок и не растягивается что бы заполнить его.</li>\n  <li>Второй больше 200px и перекрывает блок.</li>\n</ul>\n<p>Так что же мы можем сделать с проблемой перекрывания?</p>\n<p>Как мы учили в <a>нашем предыдущем уроке</a>, распространённая техника — это сделать <a><code>max-width</code></a> изображения - 100%. Это позволит уменьшить размер изображения по отношению к блоку, но не увеличит его. Такой метод будет работать и с другими замещаемыми элементами такими как <a><code>&lt;video&gt;</code></a> или <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;iframe&gt;</code> <small>(en-US)<small></small></small></a>.</p>\n<p><strong>Попробуйте добавить <code>max-width: 100%</code> к элементу <code>&lt;img&gt;</code> в примере выше. Вы увидите, что меньшее изображение останется неизмененным, а большее изображение станет меньше, чтобы заполнить блок.</strong></p>\n<p>Вы можете сделать другие варианты изображений внутри контейнеров. Например, вы можете захотеть дать изображению такие размеры, чтоб оно полностью покрывало блок.</p>\n<p>Здесь вам может помочь свойство <a><code>object-fit</code></a>. Используя <code>object-fit</code>, можно определять размеры замещаемого элемента для заполнения блока различными способами.</p>\n<p>Ниже мы использовали значение <code>cover</code>, которое уменьшает изображение, сохраняя соотношение сторон так, что он аккуратно заполняет блок. Поскольку соотношения сторон сохраняются, некоторые части изображения будут обрезаны блоком.</p>\n<p>Если мы используем <code>contain</code> в качестве значения, изображение будет уменьшаться до тех пор, пока не станет достаточно маленьким чтобы заполнить блок. Это приведёт к "почтовой упаковке", если оно не будет иметь такого же соотношения сторон, как блок.</p>\n<p>Вы также можете попробовать значение <code>fill</code>, которое будет заполнять блок, но при этом не сохранять соотношение сторон.</p></div></section><section aria-labelledby="замещаемые_элементы_в_вёрстке"><h2 id="замещаемые_элементы_в_вёрстке"><a>Замещаемые элементы в вёрстке</a></h2><div class="section-content"><p>При использовании различных методов вёрстки CSS на замещаемых элементах, вы можете обнаружить, что они ведут себя немного иначе, чем другие элементы. Например, во flex или grid layout элементы растягиваются по умолчанию чтобы заполнить всю площадь. Изображения растягиваться не будут, вместо этого они будут выравнены на начало площади flex- или grig-контейнера.</p>\n<p>Вы можете увидеть, как это происходит в примере ниже, где мы имеем grid-контейнер из двух столбцов и двух строк, который содержит 4 объекта. Все <code>&lt;div&gt;</code> элементы имеют цвет фона и растягиваются чтобы заполнить строки и столбцы. Однако, изображение не растягивается.</p>\n<p>Если вы изучаете эти уроки по порядку, тогда вы, возможно, ещё не рассматривали layout. Просто держите в уме, что замещаемые элементы, становясь частью grid- или flex-разметки, ведут себя иначе по умолчанию, главным образом, чтобы избежать их странного растяжения по разметке.</p>\n<p>Для того чтобы заставить изображение растянуться чтобы заполнить grid-ячейку, вы должны сделать что-то наподобие следующего:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">img {\n  width: 100%;\n  height: 100%;\n}\n</pre></div>\n<p>Это, однако, растянет изображение, и скорее всего это не то чего бы вам хотелось делать.</p></div></section><section aria-labelledby="элементы_форм"><h2 id="элементы_форм"><a>Элементы форм</a></h2><div class="section-content"><p>Элементы форм могут быть сложной проблемой когда дело касается их стилизации в CSS, и <a>Web Forms module</a> содержит детальные руководства по хитрым аспектам стилизации элементов форм, которые я не буду представлять здесь в полном объёме. В этом разделе статьи стоит выделить несколько ключевых моментов.</p>\n<p>Многие элементы управления форм добавляются на вашу страницу с помощью элемента <a><code>&lt;input&gt;</code></a> — он определяет простые поля формы, такие как ввод текста, и более сложные поля, добавленные в HTML5, такие как средства выбора цвета и даты. Существуют некоторые дополнительные элементы, такие как <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;textarea&gt;</code> <small>(en-US)<small></small></small></a> для ввода многострочного текста, а также элементы которые содержали части маркировки форм, такие как <a><code>&lt;fieldset&gt;</code></a> и <a><code>&lt;legend&gt;</code></a>.</p>\n<p>HTML5 также содержит атрибуты, которые позволяют веб-разработчикам указывать какие поля являются обязательными и даже тип контента, который необходимо вводить. Если пользователь вводит неожидаемые данные или оставляет обязательные поля пустыми, браузер может выдать сообщение об ошибке. Разные браузеры несовместимы в том, сколько стилей и настроек они допускают для таких элементов.</p></div></section><section aria-labelledby="стилизация_элементов_ввода_текста"><h3 id="стилизация_элементов_ввода_текста"><a>Стилизация элементов ввода текста</a></h3><div class="section-content"><p>Элементы, позволяющие вводить текст, такие как <code>&lt;input type="text"&gt;</code>, конкретные типы вроде <code>&lt;input type="email"&gt;</code>, и элемент <code>&lt;textarea&gt;</code>, являются довольно простыми в стилизации и как правило ведут себя также, как и другие блоки на вашей странице. Однако, стилизация по умолчанию таких элементов будет отличаться в зависимости от операционной системы и браузера которые использует пользователь, посещая сайт.</p>\n<p>В примере ниже мы стилизовали несколько вводов текста используя CSS — вы можете увидеть, что такие вещи как borders, margins и padding, все применяются так как вы бы ожидали. Мы используем селекторы атрибутов для выборов различных типов ввода. Попробуйте изменить то, как эти формы выглядят, регулируя границы, добавляя цвет фона полям и изменяя шрифты padding.</p>\n<div class="notecard warning" id="sect1">\n  <p><strong>Предупреждение:</strong> <strong>Важно:</strong> При изменении стиля элементов формы следует соблюдать осторожность, чтобы убедиться, что для пользователя все ещё очевидно, что они являются элементами форм. Вы можете создать форму ввода без границ и фона, которая практически неотличима от окружающего контента и это может сделать очень сложно распознаваемой, чтобы заполнить её.</p>\n</div>\n<p>Как объяснено в уроке <a>стилизация форм</a> в части HTML этого курса, многие из более сложных типов ввода определяются операционной системой и не доступны для стилизации. Поэтому вы всегда должны предполагать, что формы будут выглядеть по-разному для разных пользователей и тестировать сложные формы во многих браузерах.</p></div></section><section aria-labelledby="наследование_и_элементы_форм"><h3 id="наследование_и_элементы_форм"><a>Наследование и элементы форм</a></h3><div class="section-content"><p>В некоторых браузерах, элементы форм не наследуют стиль шрифтов по умолчанию. Поэтому если вы хотите быть уверенными что ваши поля форм используют шрифт определённый в body или родительском элементе, вы должны добавить это правило в ваш CSS.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">button,\ninput,\nselect,\ntextarea {\n  font-family: inherit;\n  font-size: 100%;\n}\n</pre></div></div></section><section aria-labelledby="элементы_форм_и_box-sizing"><h3 id="элементы_форм_и_box-sizing"><a>Элементы форм и box-sizing</a></h3><div class="section-content"><p>В разных браузерах элементы формы используют разные правила определения размеров блоков для разных виджетов. вы изучали свойство <code>box-sizing</code> в <a>нашем уроке Блоки в CSS</a> и можете использовать эти знания при стилизации форм для обеспечения единообразия при настройке ширины и высоты элементов форм.</p>\n<p>Для единообразия рекомендуется устанавливать margin и padding на <code>0</code> для всех элементов, а затем добавлять их (margin и padding) при стилизации отдельных элементов.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">button,\ninput,\nselect,\ntextarea {\n  box-sizing: border-box;\n  padding: 0;\n  margin: 0;\n}\n</pre></div></div></section><section aria-labelledby="другие_полезные_настройки"><h3 id="другие_полезные_настройки"><a>Другие полезные настройки</a></h3><div class="section-content"><p>В дополнение к правилам отмеченных выше, вы должны также установить <code>overflow: auto</code> для <code>&lt;textarea&gt;</code> чтобы IE не отображал полосу прокрутки, когда в этом нет необходимости:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">textarea {\n  overflow: auto;\n}\n</pre></div></div></section><section aria-labelledby="собираем_все_вместе_в_перезагрузку"><h3 id="собираем_все_вместе_в_перезагрузку"><a>Собираем все вместе в "перезагрузку"</a></h3><div class="section-content"><p>В качестве последнего шага, мы можем обернуть различные свойства, обсуждаемые выше, в следующую «форму перезагрузки», чтобы обеспечить согласованную основу для работы. Это включает все элементы упомянутые в последних трёх разделах:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">button,\ninput,\nselect,\ntextarea {\n  font-family: inherit;\n  font-size: 100%;\n  box-sizing: border-box;\n  padding: 0;\n  margin: 0;\n}\n\ntextarea {\n  overflow: auto;\n}\n</pre></div>\n<div class="notecard note" id="sect2">\n  <p><strong>Примечание:</strong> Normalizing stylesheets are used by many developers to create a set of baseline styles to use on all projects. Typically these do similar things to those described above, making sure that anything different across browsers is set to a consistent default before you do your own work on the CSS. They are not as important as they once were, as browsers are typically more consistent than in the past. However if you want to take a look at one example, check out <a class="external" target="_blank">Normalize.css</a>, which is a very popular stylesheet used as a base by many projects.</p>\n</div>\n<p>Для дополнительной информации по стилизации форм, посмотрите две статьи в разделе HTML этого руководства.</p>\n<ul>\n  <li><a>Styling web forms</a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)">Advanced form styling <small>(en-US)<small></small></small></a></li>\n</ul></div></section><section aria-labelledby="summary"><h2 id="summary"><a>Summary</a></h2><div class="section-content"><p>This lesson has highlighted some of the differences you will encounter when working with images, media, and other unusual elements in CSS. In the next article we\'ll look over a few tips you\'ll find useful when you have to style HTML tables.</p></div></section><section aria-labelledby="in_this_module"><h2 id="in_this_module"><a>In this module</a></h2><div class="section-content"><ol>\n  <li><a>Cascade and inheritance</a></li>\n  <li><a>CSS selectors</a>\n    <ul>\n      <li><a>Type, class, and ID selectors</a></li>\n      <li><a>Attribute selectors</a></li>\n      <li><a>Pseudo-classes and pseudo-elements</a></li>\n      <li><a>Combinators</a></li>\n    </ul>\n  </li>\n  <li><a>The box model</a></li>\n  <li><a>Backgrounds and borders</a></li>\n  <li><a>Handling different text directions</a></li>\n  <li><a>Overflowing content</a></li>\n  <li><a>Values and units</a></li>\n  <li><a>Sizing items in CSS</a></li>\n  <li><a aria-current="page">Images, media, and form elements</a></li>\n  <li><a>Styling tables</a></li>\n  <li><a>Debugging CSS</a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)">Organizing your CSS <small>(en-US)<small></small></small></a></li>\n</ol></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Стилизация таблиц',
		
		content:
			'<header><h1>Стилизация таблиц</h1></header><div class="section-content">\n<p>Стилизация HTML таблиц это не самая гламурная работа в мире, но иногда нам нужно это делать. Эта статья руководство как сделать, чтобы ваши HTML таблицы выглядели хорошо, с некоторыми свойствами подробно рассмотренными в предыдущих статьях.</p>\n</div><section aria-labelledby="типичная_html_таблица"><h2 id="типичная_html_таблица"><a>Типичная HTML таблица</a></h2><div class="section-content"><p>Давайте начнём с рассмотрения типичной HTML таблицы. Когда мы говорим о примерах типичных HTML таблиц обычно речь идёт о обуви, погоде или сотрудниках; мы решили сделать это более интересным создав таблицу о знаменитых панк группах Великобритании. Разметка выглядит следующим образом:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><table>\n  <caption>\n    A summary of the UK\'s most famous punk bands\n  </caption>\n  <thead>\n    <tr>\n      <th scope="col">Band</th>\n      <th scope="col">Year formed</th>\n      <th scope="col">No. of Albums</th>\n      <th scope="col">Most famous song</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th scope="row">Buzzcocks</th>\n      <td>1976</td>\n      <td>9</td>\n      <td>Ever fallen in love (with someone you shouldn\'t\'ve)</td>\n    </tr>\n    <tr>\n      <th scope="row">The Clash</th>\n      <td>1976</td>\n      <td>6</td>\n      <td>London Calling</td>\n    </tr><tr>\n      <th scope="row">The Stranglers</th>\n      <td>1974</td>\n      <td>17</td>\n      <td>No More Heroes</td>\n    </tr>\n  </tbody>\n  <tfoot>\n    <tr>\n      <th scope="row" colspan="2">Total albums</th>\n      <td colspan="2">77</td>\n    </tr>\n  </tfoot>\n</table>\n\n    ... some rows removed for brevity\n\n    \n</pre></div>\n<p>Таблица размечена, немного стилизована и понятна, благодаря использованию таких свойств как <a class="only-in-en-us" title="Currently only available in English (US)"><code>scope</code> <small>(en-US)<small></small></small></a>, <a><code>&lt;caption&gt;</code></a>, <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;thead&gt;</code> <small>(en-US)</small></a>, <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;tbody&gt;</code> <small>(en-US)</small></a> и т.д. К сожалению при просмотре в браузере она не очень хорошо выглядит (посмотреть можно здесь <a class="external" target="_blank">punk-bands-unstyled.html</a>):</p>\n<p>\n  \n</p>\n<p>Это выглядит достаточно грубо, трудно читаемо и скучно. Нам нужно использовать немного CSS чтобы все исправить.</p></div></section><section aria-labelledby="активное_обучение_стилизация_таблицы"><h2 id="активное_обучение_стилизация_таблицы"><a>Активное обучение: Стилизация таблицы</a></h2><div class="section-content"><p>В этой части обучения мы будем работать над тем чтобы стилизовать наш пример таблицы.</p>\n<ol>\n  <li>В начале необходимо сделать копию <a class="external" target="_blank">sample markup</a>, загрузить оба изображения (<a class="external" target="_blank">noise</a> и <a class="external" target="_blank">leopardskin</a>), и вставить эти файлы в отдельную папку на вашем компьютере.</li>\n  <li>Следующее, это создать новый файл <code>style.css</code> и сохранить его в той же папке вместе с другими файлами.</li>\n  <li>Подключить CSS в HTML для этого разместить следующую строку в HTML внутри <a><code>&lt;head&gt;</code></a>:\n    <div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><link href="style.css" rel="stylesheet" type="text/css">\n</pre></div>\n  </li>\n</ol></div></section><section aria-labelledby="отступы_и_разметка"><h3 id="отступы_и_разметка"><a>Отступы и разметка</a></h3><div class="section-content"><p>Первое что нам нужно это разобраться с отступами/разметкой, так как по умолчанию стилизация таблцы выглядит неразборчиво! Сделаем это, добавив CSS в ваш <code>style.css</code> файл:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">/* Отступы */\n\ntable {\n  table-layout: fixed;\n  width: 100%;\n  border-collapse: collapse;\n  border: 3px solid purple;\n}\n\nthead th:nth-child(1) {\n  width: 30%;\n}\n\nthead th:nth-child(2) {\n  width: 20%;\n}\n\nthead th:nth-child(3) {\n  width: 15%;\n}\n\nthead th:nth-child(4) {\n  width: 35%;\n}\n\nth,\ntd {\n  padding: 20px;\n}\n</pre></div>\n<p>Наиболее важные части следующие:</p>\n<ul>\n  <li>\n    Свойство <a class="only-in-en-us" title="Currently only available in English (US)"><code>table-layout</code> <small>(en-US)</small></a> со значением <code>fixed</code> как правило полезно использовать для вашей таблицы, это делает поведение таблицы немного более предсказуемым, чем значение по умолчанию. Обычно столбцы таблицы имеют размер в зависимости от того сколько в них контента, что приводит иногда к некоторым странным результатам. Когда <code>table-layout: fixed</code>, размер ваших столбцов определяется шириной их заголовков и делает их контент соответствующего размера. Вот почему вы выбрали четыре разных заголовка с помощью селектора <code>thead th:nth-child(n)</code> (<a><code>:nth-child</code></a>) ("Выберите <em>n-ый</em> дочерний элемент <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;th&gt;</code> <small>(en-US)</small></a> в последовательности, внутри элемента <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;thead&gt;</code> <small>(en-US)</small></a>") и задать им заданную в процентах ширину. Ширина колонки соответствует ширине её заголовка, это правильное решение при определении размеров колонок таблицы. Крис Койер (Chris Coyier) более подробно рассматривает эту технику в статье <a class="external" target="_blank">Fixed Table Layouts</a>.\n    Мы также использовали <a><code>width</code></a> 100%, что означает, что таблица заполнит любой контейнер и будет отзывчивой (хотя для этого потребуется ещё некоторая работа для правильного отображения на экранах небольших размеров).\n  </li>\n  <li>Свойство <a class="only-in-en-us" title="Currently only available in English (US)"><code>border-collapse</code> <small>(en-US)</small></a> со значением <code>collapse</code> это стандартная практика при стилизации любой таблицы. По умолчанию, когда вы задали рамки для элементов таблицы, все они будут иметь пробелы между собой, как показано на рисунке ниже: \n    Это не очень хорошо выглядит (хотя может это то что вам нужно, кто знает?). Если установить <code>border-collapse: collapse;</code> рамки схлопываются в одну и так выглядит намного лучше: \n    \n  </li>\n  <li>Мы установили <a><code>border</code></a> вокруг всей таблицы, это понадобится когда чуть позже мы будет устанавливать рамки вокруг header и footer таблицы — когда по периметру всей таблицы нет рамки и граница заканчивается просто отступом, таблица выглядит странно и разрозненно.</li>\n  <li>Мы установили <a><code>padding</code></a> на элементах <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;th&gt;</code> <small>(en-US)</small></a> и <a><code>&lt;td&gt;</code></a> — это создаёт в талице воздух, который позволяет ей дышать, делая её более понятной.</li>\n</ul>\n<p>На этом этапе наша таблица выглядит уже гораздо лучше:</p>\n<p>\n  \n</p></div></section><section aria-labelledby="немного_простой_типографики"><h3 id="немного_простой_типографики"><a>Немного простой типографики</a></h3><div class="section-content"><p>Теперь мы ещё кое-что изменим.</p>\n<p>Во-первых, мы пойдём и найдём на <a class="external" target="_blank">Google Fonts</a> шрифт который подходит в нашей ситуации с таблицей о панк группах. Вы можете можете выбрать для себя другой шрифт если захотят, тогда вам понадобится заменить представленный <a><code>&lt;link&gt;</code></a> элемент и изменить объявление <a><code>font-family</code></a> на выбранный вами Google Fonts шрифт.</p>\n<p>Добавьте элемент <a><code>&lt;link&gt;</code></a> в блок head вашего HTML, на строчку выше существующего элемента <code>&lt;link&gt;</code>:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><link href="https://fonts.googleapis.com/css?family=Rock+Salt" rel="stylesheet" type="text/css">\n</pre></div>\n<p>Затем добавьте следующий CSS в ваш <code>style.css</code> файл, ниже предыдущего кода:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">/* Типографика */\n\nhtml {\n  font-family: "helvetica neue", helvetica, arial, sans-serif;\n}\n\nthead th,\ntfoot th {\n  font-family: "Rock Salt", cursive;\n}\n\nth {\n  letter-spacing: 2px;\n}\n\ntd {\n  letter-spacing: 1px;\n}\n\ntbody td {\n  text-align: center;\n}\n\ntfoot th {\n  text-align: right;\n}\n</pre></div>\n<p>Здесь нет ничего специально для таблиц, мы просто настраиваем стилизацию шрифтов, чтобы упростить чтение:</p>\n<ul>\n  <li>Мы установили доступный глобально шрифт sans-serif; это вполне стандартный стилистический выбор. Мы установили выбранный нами шрифт для заголовков внутри элементов <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;thead&gt;</code> <small>(en-US)</small></a> и <a><code>&lt;tfoot&gt;</code></a>, который подходит нам по тематике панков.</li>\n  <li>Мы добавили немного <a><code>letter-spacing</code></a> в заголовках и ячейках которым необходимо добавить читаемости. Опять же это основной стилистический приём.</li>\n  <li>Мы выравниваем по центру текст ячейках внутри <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;tbody&gt;</code> <small>(en-US)</small></a> чтобы они совпадали с заголовками. По умолчанию у ячеек свойство <a><code>text-align</code></a> имеет значение <code>left</code>, а заголовки значение <code>center</code>, но обычно выглядит лучше если они выравниваются в одном стиле. По умолчанию, чтобы внешний вид заголовков отличался у них задан жирный шрифт.</li>\n  <li>Мы выровняли заголовок справа внутри <a><code>&lt;tfoot&gt;</code></a> так чтобы он визуально ассоциировался с соответствующими ему данными.</li>\n</ul>\n<p>В результате таблица выглядит немного аккуратнее:</p>\n<p>\n  \n</p></div></section><section aria-labelledby="графика_и_цвета"><h3 id="графика_и_цвета"><a>Графика и цвета</a></h3><div class="section-content"><p>И наконец-то графика и цвета! Наша таблица заполнена тем что имеет отношение к панкам, поэтому нам нужно придать ей яркий впечатляющий вид. Не беспокойтесь, вам не обязательно делать таблицу слишком кричащей — вы можете выбрать что-то более утончённое и со вкусом.</p>\n<p>Начнём с добавления в конец файла <code>style.css</code> следующего CSS:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">/* Графика и цвета */\n\nthead,\ntfoot {\n  background: url(leopardskin.jpg);\n  color: white;\n  text-shadow: 1px 1px 1px black;\n}\n\nthead th,\ntfoot th,\ntfoot td {\n  background: linear-gradient(to bottom, rgb(0 0 0 / 10%), rgb(0 0 0 / 50%));\n  border: 3px solid purple;\n}\n</pre></div>\n<p>Опять же здесь нет ничего конкретно для таблиц, но стоит отметить несколько вещей.</p>\n<p>Мы добавили <a><code>background-image</code></a> в <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;thead&gt;</code> <small>(en-US)</small></a>, <a><code>&lt;tfoot&gt;</code></a> и изменили <a class="only-in-en-us" title="Currently only available in English (US)"><code>color</code> <small>(en-US)</small></a> для всего текста внутри header и footer на белый (и ещё <a><code>text-shadow</code></a>) для лучшей читаемости. Вы должны всегда быть уверены что ваш текст хорошо контрастирует с фоном, для обеспечения читаемости.</p>\n<p>Также мы добавили линейный градиент для <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;th&gt;</code> <small>(en-US)</small></a> и <a><code>&lt;td&gt;</code></a> элементов внутри header и footer для придания лёгкой приятной текстуры, а также установили этим элементам яркие пурпурные границы. Полезно иметь несколько вложенных элементов, это позволяет накладывать несколько стилей друг на друга. Да, мы могли бы установить и фоновое изображение, и линейный градиент на <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;thead&gt;</code> <small>(en-US)</small></a> и <a><code>&lt;tfoot&gt;</code></a> элементы используя множественные фоновые изображения, но мы решили сделать это отдельно для старых браузеров, которые не поддерживают <a>несколько фоновых изображений</a> и <a class="only-in-en-us" title="Currently only available in English (US)">линейные градиенты <small>(en-US)<small></small></small></a>.</p>\n<h4 id="полосатая_зебра">Полосатая зебра</h4>\n<p>Мы хотели бы посвятить целый раздел, чтобы показать вам как реализовать <strong>полосы зебры</strong> — чередующиеся цветные строки которые упрощают чтение разных строк в вашей таблице. Добавим следующий CSS в ваш <code>style.css</code> файл:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">/* Полосатая зебра */\n\ntbody tr:nth-child(odd) {\n  background-color: #ff33cc;\n}\n\ntbody tr:nth-child(even) {\n  background-color: #e495e4;\n}\n\ntbody tr {\n  background-image: url(noise.png);\n}\n\ntable {\n  background-color: #ff33cc;\n}\n</pre></div>\n<ul>\n  <li>Ранее вы видели как <a><code>:nth-child</code></a> селектор использовался для выбора специфичных дочерних элементов. В качестве параметра также может быть передана формула, тогда он будет выбирать последовательность элементов. Так формула <code>2n-1</code> выберет все нечётные дочерние элементы (1, 3, 5 и т.д.), а формула <code>2n</code> выберет все чётные (2, 4, 6 и т.д.). Мы использовали в нашем коде ключевые слова <code>odd</code> и <code>even</code>, которые делают тоже самое что и формулы выше. В данном случае мы устанавливаем чётным и нечётным строкам разные (яркие) цвета.</li>\n  <li>Ещё мы добавили повторяющийся плиткой фон ко всем строкам тела таблицы, который добавляет немного шума (полупрозрачный <code>.png</code> с небольшим количеством визуальных искажений на нем), чтобы получилась некоторая текстура.</li>\n  <li>И наконец мы установили для таблицы сплошной цвет фона, который обеспечит фон строкам таблицы в том случае если браузер не поддерживает селектор <code>:nth-child</code>.</li>\n</ul>\n<p>Этот взрыв цвета выглядит следующим образом:</p>\n<p>\n  \n</p>\n<p>То что получилось может быть не в вашем вкусе, но основная идея была в том, что мы попытались сделать таблицу которая не будет скучной и академической.</p></div></section><section aria-labelledby="стилизация_заголовка"><h3 id="стилизация_заголовка"><a>Стилизация заголовка</a></h3><div class="section-content"><p>Последнее что мы сделаем с нашей таблицей это стилизация заголовка. Для этого добавим следующие строки в наш файл <code>style.css</code>:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">/* Заголовок */\n\ncaption {\n  font-family: "Rock Salt", cursive;\n  padding: 20px;\n  font-style: italic;\n  caption-side: bottom;\n  color: #666;\n  text-align: right;\n  letter-spacing: 1px;\n}\n</pre></div>\n<p>Здесь нет ничего особенного, кроме свойства <a class="only-in-en-us" title="Currently only available in English (US)"><code>caption-side</code> <small>(en-US)</small></a>, которое имеет значение <code>bottom</code>. В этом случае заголовок будет размещён внизу таблицы и это вместе со всем остальным обеспечивает нашей таблице окончательный вид (можно посмотреть по ссылке <a class="external" target="_blank">punk-bands-complete.html</a>):</p>\n<p>\n  \n</p></div></section><section aria-labelledby="активное_обучение_стилизация_вашей_собственной_таблицы"><h2 id="активное_обучение_стилизация_вашей_собственной_таблицы"><a>Активное обучение: Стилизация вашей собственной таблицы</a></h2><div class="section-content"><p>Теперь мы хотим, чтобы вы взяли наш пример таблицы (или использовали собственный!) и сделали что-то значительно более стильное и менее безвкусное чем наша таблица.</p></div></section><section aria-labelledby="стилизация_таблицы_быстрые_советы"><h2 id="стилизация_таблицы_быстрые_советы"><a>Стилизация таблицы быстрые советы</a></h2><div class="section-content"><p>Короткий список наиболее полезных вещей рассмотренных выше:</p>\n<ul>\n  <li>Сделайте свою разметку простой и гибкой, например, используя для этого проценты, что сделает дизайн более отзывчивым.</li>\n  <li>Используйте <a class="only-in-en-us" title="Currently only available in English (US)"><code>table-layout</code> <small>(en-US)</small></a><code>: fixed</code> для более понятного поведения разметки, при этом легко установить ширину столбцов, установив ширину <a><code>width</code></a> для заголовков таблицы (<a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;th&gt;</code> <small>(en-US)</small></a>).</li>\n  <li>Используйте <a class="only-in-en-us" title="Currently only available in English (US)"><code>border-collapse</code> <small>(en-US)</small></a><code>: collapse</code>, которое схлопнет границы элементов таблицы, что обеспечит аккуратный внешний вид.</li>\n  <li>Используйте <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;thead&gt;</code> <small>(en-US)</small></a>, <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;tbody&gt;</code> <small>(en-US)</small></a> и <a><code>&lt;tfoot&gt;</code></a> чтобы разбить вашу таблицу на логические фрагменты и предоставив таким образом дополнительные точки для применения CSS, это даёт возможность накладывать стили друг на друга, если это необходимо.</li>\n  <li>Используйте полоски зебры, чтобы облегчить чтение между строк.</li>\n  <li>Используйте <a><code>text-align</code></a> чтобы выровнять текст в <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;th&gt;</code> <small>(en-US)</small></a> и <a><code>&lt;td&gt;</code></a> для более аккуратного и удобного оформления.</li>\n</ul></div></section><section aria-labelledby="заключение"><h2 id="заключение"><a>Заключение</a></h2><div class="section-content"><p>Несмотря на головокружительные успехи достигнутые в стилизации таблиц, у нас есть ещё кое-что чем мы можем занять наше время. В следующей главе мы рассмотрим некоторые продвинутые эффекты, уже устоявшиеся (например, тени box shadows) и те которые только недавно появились в браузерах, такие как режимы наложения blend-mode и фильтры.</p></div></section><section aria-labelledby="в_этом_блоке"><h2 id="в_этом_блоке"><a>В этом блоке</a></h2><div class="section-content"><ul>\n  <li><a>Box model recap</a></li>\n  <li><a>Backgrounds</a></li>\n  <li><a>Borders</a></li>\n  <li><a aria-current="page">Стилизация таблиц</a></li>\n  <li><a>Advanced box effects</a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)">Creating fancy letterheaded paper <small>(en-US)<small></small></small></a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)">A cool looking box <small>(en-US)<small></small></small></a></li>\n</ul></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Отладка CSS',
		
		content:
			'<header><h1>Отладка CSS</h1></header><div class="section-content">\n<p>Порой, при написании CSS, вы будете сталкиваться с проблемой, при которой будет казаться, что CSS не делает того, чего вы ожидаете от него. Возможно, вы считаете, что определённый селектор должен соответствовать элементу, но ничего не происходит, или поле имеет размер, отличный от ожидаемого. Эта статья поможет вам с тем, как отладить CSS проблемы и покажет вам как DevTools (инструменты разработчика), включённые во все современные браузеры, могут помочь разобраться с тем, что происходит.</p>\n</div><section aria-labelledby="как_получить_доступ_к_devtools_браузера"><h2 id="как_получить_доступ_к_devtools_браузера"><a>Как получить доступ к DevTools браузера</a></h2><div class="section-content"><p>Статья <a>What are browser developer tools</a> это обновлённое руководство объясняющее как получить доступ к инструментам разных браузеров и платформ. Хотя вы можете выбрать в основном разрабатывать в конкретном браузере и поэтому инструменты, включённые в этот браузер, будут вам знакомы больше всего, стоит знать, как получать доступ к инструментам и в других браузерах. Это поможет вам если вы наблюдаете разное отображение среди разных браузеров.</p>\n<p>Вы также обнаружите, что браузеры фокусировались на различных областях при создании своих DevTools. Например в Firefox существует несколько замечательных инструментов для визуальной работы с CSS Layout (разметкой), позволяющих вам проводить инспекцию и править <a class="only-in-en-us external" title="Currently only available in English (US)" target="_blank">Grid Layouts <small>(en-US)<small></small></small></a>, <a class="only-in-en-us external" title="Currently only available in English (US)" target="_blank">Flexbox <small>(en-US)<small></small></small></a>, и <a class="external" target="_blank">Shapes</a>. Тем не менее, все другие браузеры имеют схожие фундаментальные инструменты, например для инспекции свойств и значений применённых к элементам на вашей странице и для выполнения изменений к ним в редакторе.</p>\n<p>В этом уроке мы рассмотрим некоторые полезные функции Firefox DevTools для работы с CSS. Для того чтобы сделать это я буду использовать <a class="external" target="_blank">файл примера</a>. Загрузите его в новой вкладке если хотите следовать и откройте ваш DevTools как описано в статье, ссылка на которую дана выше.</p></div></section><section aria-labelledby="dom_vs_view_source"><h2 id="dom_vs_view_source"><a>DOM vs View Source</a></h2><div class="section-content"><p>То, что может сбить с толку новичков в DevTools, — это разница между тем, что вы видите когда <a class="only-in-en-us external" title="Currently only available in English (US)" target="_blank">просматриваете источник <small>(en-US)<small></small></small></a> веб-страницы или смотрите на HTML файл который поместили на сервер и то что вы видите на <a class="external" target="_blank">HTML панели</a> DevTools. Хотя это выглядит примерно так же, как то, что вы видите через View Source, существуют некоторые отличия.</p>\n<p>В визуализированном DOM браузер мог скорректировать некоторый плохо-написанный HTML за вас. Если вы неправильно закрыли элемент, например открывали <code>&lt;h2&gt;</code>, но закрыли <code>&lt;/h3&gt;</code>, браузер поймёт, что вы хотели сделать и HTML в DOM будет правильно закрывать <code>&lt;h2&gt;</code> с <code>&lt;/h2&gt;</code>. Браузер также нормализует весь HTML,а DOM также покажет любые изменения сделанные через JavaScript.</p>\n<p>View Source же для сравнения — это просто исходный код HTML, хранящийся на сервере. <a class="external" target="_blank">HTML дерево</a> в вашем DevTools показывает, что именно браузер отображает в любой момент времени, что даёт вам представление от том, что действительно происходит.</p></div></section><section aria-labelledby="инспекция_применённого_css"><h2 id="инспекция_применённого_css"><a>Инспекция применённого CSS</a></h2><div class="section-content"><p>Выбирать элемент на вашей странице можно либо правым/ctrl-кликом по нему и выбрав <em>Inspect</em>, либо выбрав его из дерева HTML в левой панели DevTools. Попробуйте выбрать элемент с классом <code>box1</code>; это первый элемент на странице с блоком, ограниченным рамками вокруг него.</p>\n<p>\n  \n</p>\n<p>Если вы посмотрите на <a class="external" target="_blank">Rules view</a> справа от вашего HTML, вы должны увидеть свойства и значения CSS применённые к элементу. Вы увидите правила, напрямую применённые к классу <code>box1</code> и также CSS который наследуется блоком от предков, в этом случае от <code>&lt;body&gt;</code>. Это полезно в случае, если вы видите, что применяется какой-либо CSS, который вы не ожидали. Вполне возможно, что он наследуется от родительского элемента и вам необходимо добавить правило, чтобы переписать его в контексте этого элемента.</p>\n<p>Также полезна возможность расширения (развёртывания) свойств коротких записей. В нашем примере используется короткая запись <code>margin</code>.</p>\n<p><strong>Кликните по маленькой стрелке для того, чтобы развернуть вид, показывающий полную запись различных свойств и значений.</strong></p>\n<p><strong>Вы можете переключать значения в Rules view в положение включено или выключено если эта панель активна — если навести на неё курсор мыши, появятся флажки. Снимите флажок правила, например, border-radius, и CSS перестанет применяться.</strong></p>\n<p>Вы можете использовать это чтобы делать сравнения по типу A/B, принимая решение если что-то выглядит лучше с применённым правилом или нет, а также это помогает в отладке — например если layout не в порядке и вы пытаетесь разобраться какое свойство является причиной проблемы.</p></div></section><section aria-labelledby="редактирование_значений"><h2 id="редактирование_значений"><a>Редактирование значений</a></h2><div class="section-content"><p>В дополнение к включению и выключению свойств, вы можете редактировать их значения. Возможно, вам захочется посмотреть будет ли другой цвет выглядеть лучше или захотите настроить размер чего-либо. DevTools поможет вам сэкономить кучу времени редактируя таблицу стиля и перезагружая страницу.</p>\n<p><strong>Выбрав <code>box1</code>, кликните на образчик (маленький цветной круг) который показывает цвет, применённый к границе. Откроется панель выбора цвета и сможете попробовать некоторые другие цвета; это действие обновится на странице в режиме реального времени.</strong> <strong>Аналогичным образом вы можете изменить ширину или стиль границ.</strong></p>\n<p>\n  \n</p></div></section><section aria-labelledby="добавление_нового_свойства"><h2 id="добавление_нового_свойства"><a>Добавление нового свойства</a></h2><div class="section-content"><p>Используя DevTools вы можете добавлять новые свойства. Возможно, вы осознали, что не хотите, чтобы ваш блок наследовал размер шрифта элементов <code>&lt;body&gt;</code>, а хотите установить его собственный конкретный размер. Вы можете попробовать это в DevTools до того, как внесёте изменения в ваше CSS файл.</p>\n<p><strong>Вы можете кликнуть по закрывающей фигурной скобке в правиле чтобы начать вводить новое объявление в нем, с этого момента вы можете начинать вводить новое свойство и DevTools покажет список автозаполнения подходящих свойств. Выбрав <code>font-size</code>, вводите значение, которое хотите попробовать. Вы также можете кликнуть на кнопку + чтобы добавить дополнительное правило с тем же селектором и добавить ваши новые правила туда.</strong></p>\n<p>\n  \n</p>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> Также существуют другие полезные функции в Rules view, например объявления с не валидными значениями зачёркнуты. Вы можете узнать больше в <a class="external" target="_blank">Examine and edit CSS</a>.</p>\n</div></div></section><section aria-labelledby="понимание_модели_блоков"><h2 id="понимание_модели_блоков"><a>Понимание модели блоков</a></h2><div class="section-content"><p>В предыдущем уроке мы обсудили <a>модель блоков</a> и тот факт, что у нас есть альтернативная модель блоков, которая изменяет способ расчёта размера элементов основываясь на размере который вы им задаёте, плюс padding и границы. DevTools может действительно помочь вам понять, как вычисляется размер элемента.</p>\n<p><a class="external" target="_blank">Layout view</a> показывает вам диаграмму блочной модели выбранного элемента, вместе с описанием свойств и значений, которые изменяют способ расположения элемента. Это включает описание свойств, которые вы могли и не использовать напрямую к элементу, но которые имеют набор начальных значений.</p>\n<p>В этой панели одним из детальных свойств является свойство <code>box-sizing</code>, которое контролирует какую блочную модель использует элемент.</p>\n<p><strong>Сравните два блока с классами <code>box1</code> и <code>box2</code>. Они оба имеют одинаковую ширину (400px) применённую к ним, однако <code>box1</code> визуально шире. В layout panel вы можете увидеть, что он использует <code>content-box</code>. Это значение, которое принимает размер, который вы даёте элементу и затем добавляет padding</strong> <strong>и ширину границ.</strong></p>\n<p>Элемент с классом <code>box2</code> использует <code>border-box</code>, поэтому здесь padding и граница вычтены из размера, который вы дали элементу. Это означает, что пространство, занимаемое на странице блоком, соответствует указанному вами размеру — в нашем случае <code>width: 400px</code>.</p>\n<p>\n  \n</p>\n<div class="notecard note" id="sect2">\n  <p><strong>Примечание:</strong> Узнать больше на <a class="external" target="_blank">Examining and Inspecting the Box Model</a>.</p>\n</div></div></section><section aria-labelledby="решение_проблем_специфичности"><h2 id="решение_проблем_специфичности"><a>Решение проблем специфичности</a></h2><div class="section-content"><p>Порой во время разработки, в частности когда вам нужно отредактировать CSS на существующем сайте вы, вы столкнётесь с трудностями применения некоторого CSS. Вне зависимости от того, что вы делаете, кажется, что элемент просто не реагирует на CSS. Что же обычно происходит в таких ситуациях - это то, что более специфичный селектор переопределяет ваши изменения и в таких случаях DevTools действительно поможет вам.</p>\n<p>В нашем примере два слова обёрнуты в элемент <code>&lt;em&gt;</code>. Один отображается оранжевым, а второй ярко-розовым. В CSS мы применили:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">em {\n  color: hotpink;\n  font-weight: bold;\n}\n</pre></div>\n<p>Кроме того в таблице стилей есть правило с селектором <code>.special</code>:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.special {\n  color: orange;\n}\n</pre></div>\n<p>Как вы помните из урока <a>каскад и наследование</a> где мы обсуждали специфичность, селекторы классов являются более специфичными чем селекторы элементов, и поэтому это то значение которое применяется. DevTools может помочь вам найти такие проблемы, особенно если информация закопана где-то в дебрях огромной таблицы стилей.</p>\n<p><strong>Проведите инспекцию <code>&lt;em&gt;</code> с классом <code>.special</code> и DevTools покажет вам что оранжевый это цвет который применяется, а также отобразит вам свойство <code>color</code> применённое к em зачёркнутым. Теперь вы можете видеть, что класс переопределяет селектор элемента.</strong></p>\n<p>\n  \n</p></div></section><section aria-labelledby="узнайте_больше_о_firefox_devtools"><h2 id="узнайте_больше_о_firefox_devtools"><a>Узнайте больше о Firefox DevTools</a></h2><div class="section-content"><p>На MDN имеется много информации о Firefox DevTools. Взгляните на основной <a class="external" target="_blank">раздел DevTools</a>, а больше деталей о вещах которые коротко рассмотрели в этом уроке смотрите <a class="external" target="_blank">The How To Guides</a>.</p></div></section><section aria-labelledby="отладка_проблем_в_css"><h2 id="отладка_проблем_в_css"><a>Отладка проблем в CSS</a></h2><div class="section-content"><p>DevTools может помочь при решении проблем CSS, итак, когда вы окажетесь в ситуации, где CSS ведёт себя не так, как вы ожидаете, как же вам следует решать эту проблему? Следующие шаги должны помочь.</p></div></section><section aria-labelledby="сделайте_шаг_назад"><h3 id="сделайте_шаг_назад"><a>Сделайте шаг назад</a></h3><div class="section-content"><p>Любая проблема кодирования может быть неприятной, особенно проблемы CSS, потому что зачастую вы не получаете каких-либо сообщений об ошибках чтобы найти решение в интернете. Если вы начинаете разочаровываться оторвитесь от проблемы на время — прогуляйтесь, попейте, пообщайтесь с коллегами или займите себя чем-нибудь другим на время. Иногда решение появляется магическим образом, когда вы перестаёте думать об этой проблеме, а даже если нет, работать над ней гораздо проще, когда вы чувствуете себя отдохнувшими.</p></div></section><section aria-labelledby="валидны_ли_ваши_html_и_css"><h3 id="валидны_ли_ваши_html_и_css"><a>Валидны ли ваши HTML и CSS?</a></h3><div class="section-content"><p>Браузеры ожидают, что CSS и HTML написаны корректно, однако в это же время браузеры очень снисходительны и сделают всё чтобы отобразить вашу веб-страницу даже если у вас есть ошибки в разметке и таблице стилей. Если у вас есть ошибки в коде, то браузеру нужно угадать что вы имели в виду, и он может принять решение не такое какое было у вас в голове. И дополнительно, два разных браузера могут решать проблему двумя разными способами. Поэтому хорошим первым шагом является запуск вашего HTML и CSS в валидаторе чтобы выявить и исправить ошибки.</p>\n<ul>\n  <li><a class="external" target="_blank">CSS Validator</a></li>\n  <li><a class="external" target="_blank">HTML validator</a></li>\n</ul></div></section><section aria-labelledby="поддерживаются_ли_свойство_и_значение_браузером_в_котором_вы_тестируете"><h3 id="поддерживаются_ли_свойство_и_значение_браузером_в_котором_вы_тестируете"><a>Поддерживаются ли свойство и значение браузером в котором вы тестируете?</a></h3><div class="section-content"><p>Браузеры попросту игнорируют CSS который они не понимают. Если свойство или значение, которое вы используете не поддерживается браузером, в котором вы тестируете, то ничего не "сломается", кроме того, что тот CSS не будет применён. Обычно DevTools выделяет неподдерживаемые свойства и значения каким-либо образом. На скриншоте ниже браузер не поддерживает значение "подсветки" (subgrid) <a><code>grid-template-columns</code></a>.</p>\n<p>\n  \n</p>\n<p>Вы также можете смотреть таблицы совместимости браузеров в конце всех страниц свойств MDN. Они показывают, что браузер поддерживает это свойство, часто "ломается", если есть поддержка только для какого-то использования свойства, и нет для других. Таблица ниже показывает данные совместимости свойства <a class="only-in-en-us" title="Currently only available in English (US)"><code>shape-outside</code> <small>(en-US)</small></a>.</p></div></section><section aria-labelledby="не_переопределяется_ли_ваш_css_чем-нибудь_ещё"><h3 id="не_переопределяется_ли_ваш_css_чем-нибудь_ещё"><a>Не переопределяется ли ваш CSS чем-нибудь ещё?</a></h3><div class="section-content"><p>Это тот момент, когда изученная вами информация о специфичности придёт вам на помощь. Если у вас имеется что-то более специфичное, что может переписывать то, что вы пытаетесь сделать, то вы можете вступить в очень расстраивающую игру пытаясь выяснить что же именно. Однако, как описано выше, DevTools покажет вам какой CSS применяется, и вы сможете решить, как сделать новый селектор достаточно специфичным чтобы переопределить его.</p></div></section><section aria-labelledby="сделайте_сокращённый_контрольный_пример_проблемы"><h3 id="сделайте_сокращённый_контрольный_пример_проблемы"><a>Сделайте сокращённый контрольный пример проблемы</a></h3><div class="section-content"><p>Если проблема не решена шагами, описанными выше, тогда вам надо будет сделать своего рода расследование. Лучшее что можно сделать в этом случае это создать нечто известное как сокращенный контрольный пример. Возможность "уменьшить проблему" — действительно полезный навык. Он поможет вам найти проблемы как в вашем собственном коде, так в коде ваших коллег, а также позволит вам сообщать об ошибках и более эффективно обращаться за помощью.</p>\n<p>Сокращённый контрольный пример — это пример кода, который демонстрирует проблему самым простым способом с удалением несвязанного окружающего контента и стиля. Это часто будет означать удаление проблемного кода из вашего макета (layout), чтобы сделать небольшой пример, который показывает только этот код или функцию.</p>\n<p>Создание сокращённого контрольного примера:</p>\n<ol>\n  <li>Если ваша разметка генерируется динамически — например через CMS — сделайте статичную версию вывода, которая показывает проблему. Сайты обмена кодами как <a class="external" target="_blank">CodePen</a> являются полезными для размещения сокращённых контрольных примеров, так как они доступны онлайн, и вы легко можете поделиться с коллегами. Вы можете начать просматривать страницу во View Source и скопировать HTML в CodePen, затем взять релевантный CSS и JavaScript и включить их тоже. После этого вы можете проверить очевидна ли проблема.</li>\n  <li>Если удаление JavaScript не устраняет проблему, то не включайте JavaScript. Если же удаление JavaScript <em>устраняет</em> проблему, тогда удалите столько JavaScript, сколько сможете, оставляя всё что вызывает проблему.</li>\n  <li>Удалите весь HTML который не влияет на проблему. Удалите компоненты или даже главные элементы макета. Опять же постарайтесь добиться наименьшего количества кода, который все ещё показывает проблему.</li>\n  <li>Удалите весь CSS который не влияет на проблему.</li>\n</ol>\n<p>В процессе вы можете обнаружить что причиняет проблему или, хотя бы, сможете включать или выключать её путём удаления чего-то конкретного. Стоит добавлять какие-то комментарии к вашему коду по ходу изучения вещей. Если вам надо попросить помощи, то они покажут человеку, помогающему вам что вы уже пытались сделать. Это может дать вам достаточно информации для поиска возможных проблем и обходных путей.</p>\n<p>If you are still struggling to fix the problem then having a reduced test case gives you something to ask for help with, by posting to a forum, or showing to a co-worker. You are much more likely to get help if you can show that you have done the work of reducing the problem and identifying exactly where it happens, before asking for help. A more experienced developer might be able to quickly spot the problem and point you in the right direction, and even if not, your reduced test case will enable them to have a quick look and hopefully be able to offer at least some help.</p>\n<p>In the instance that your problem is actually a bug in a browser, then a reduced test case can also be used to file a bug report with the relevant browser vendor (e.g. on Mozilla\'s <a class="external" target="_blank">bugzilla site</a>).</p>\n<p>As you become more experienced with CSS, you will find that you get faster at figuring out issues. However even the most experienced of us sometimes find ourselves wondering what on earth is going on. Taking a methodical approach, making a reduced test case, and explaining the issue to someone else will usually result in a fix being found.</p></div></section><section aria-labelledby="in_this_module"><h2 id="in_this_module"><a>In this module</a></h2><div class="section-content"><ol>\n  <li><a>Cascade and inheritance</a></li>\n  <li><a>CSS selectors</a>\n    <ul>\n      <li><a>Type, class, and ID selectors</a></li>\n      <li><a>Attribute selectors</a></li>\n      <li><a>Pseudo-classes and pseudo-elements</a></li>\n      <li><a>Combinators</a></li>\n    </ul>\n  </li>\n  <li><a>The box model</a></li>\n  <li><a>Backgrounds and borders</a></li>\n  <li><a>Handling different text directions</a></li>\n  <li><a>Overflowing content</a></li>\n  <li><a>Values and units</a></li>\n  <li><a>Sizing items in CSS</a></li>\n  <li><a>Images, media, and form elements</a></li>\n  <li><a>Styling tables</a></li>\n  <li><a aria-current="page">Debugging CSS</a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)">Organizing your CSS <small>(en-US)<small></small></small></a></li>\n</ol></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Понимание основ CSS',
		
		content:
			'<header><h1>Понимание основ CSS</h1></header><div class="section-content">\n<p>Вы многое прошли в этом модуле, и должно быть вас посетило это прекрасное чувство, что дошли до конца! Последний шаг перед тем, как двигаться дальше, это попытка пройти проверку по материалам модуля — это включает в себя ряд соответствующих упражнений, которые должны быть выполнены для того, чтобы создать заключительный проект — визитка, карточка игрока, профиль в социальной сети.</p>\n</div><section aria-labelledby="отправной_пункт"><h2 id="отправной_пункт"><a>Отправной пункт</a></h2><div class="section-content"><p>Чтобы начать проверку, вы должны:</p>\n<ul>\n  <li>Перейти и скачать <a class="external" target="_blank">HTML файл для упражнения</a> и <a class="external" target="_blank">связанный файл изображения</a>, сохранить их в новую директорию на локальном компьютере. Если вы хотите использовать свой собственный файл изображения и вписать своё имя, то пожалуйста — только убедитесь, что изображение квадратное.</li>\n  <li>Скачайте <a class="external" target="_blank">текстовый файл с исходным CSS</a> — в нем содержится набор исходных селекторов и наборов правил, которые вы должны изучить и объединить, чтобы пройти часть этой проверки.</li>\n</ul>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> Вместо этого вы можете использовать для проверки такие сайты как <a class="external" target="_blank">JSBin</a> или <a class="external" target="_blank">Thimble</a>. Вы можете скопировать HTML и заполнить CSS в одном из этих онлайн редакторов и использовать <a class="external" target="_blank">этот URL</a> чтобы указать элементу <code>&lt;img&gt;</code> файл изображения. Если используемый онлайн-редактор не имеет отдельной панели для CSS, вы можете поместить его в элемент <code>&lt;style&gt;</code> в заголовке документа.</p>\n</div></div></section><section aria-labelledby="краткое_описание_проекта"><h2 id="краткое_описание_проекта"><a>Краткое описание проекта</a></h2><div class="section-content"><p>Вам предоставили некоторый исходный HTML и изображение, и нужно написать необходимые CSS-правила, чтобы стилизовать это в маленькую онлайн-визитку, которая может, возможно, стать картой игрока или профилем в социальных сетях. Следующие разделы описывают, что вам нужно сделать.</p>\n<p>Первоначальные настройки:</p>\n<ul>\n  <li>Прежде всего, создайте новый файл в той же директории, что и ваши HTML и файл изображения. Назовите его как-нибудь образно, например <code>style.css</code>.</li>\n  <li>Подключите ваш CSS к вашему файлу HTML с помощью элемента <code>&lt;link&gt;</code>.</li>\n  <li>Первые два набора правил в исходном файле CSS ваши бесплатно! После того, как вы закончите радоваться своей удаче, скопируйте и вставьте их в верхнюю часть вашего нового файла CSS. Используйте их в качестве теста, чтобы убедиться, что ваш CSS правильно применяется к HTML.</li>\n  <li>Над этими двумя правилами добавьте CSS-комментарий, что это набор общих стилей для всей страницы. "Общие стили страницы" подойдут. Также добавьте ещё три комментария в нижней части CSS-файла, чтобы отметить стили, соответствующие для настройки контейнера карты, стили, соответствующие для верхнего и нижнего колонтитулов, а также стили, соответствующие для основного содержимого визитной карточки. Отныне новые стили, добавленные в таблицу стилей, должны быть размещены в соответствующем месте.</li>\n</ul>\n<p>Позаботимся о селекторах и наборах правил, предоставленных в файле CSS:</p>\n<ul>\n  <li>Далее мы хотели бы, чтобы вы посмотрели на четыре селектора и рассчитали специфичность для каждого из них. Запишите их где-нибудь, где они могут быть найдены позже, например, в комментарии в верхней части CSS.</li>\n  <li>Теперь пришло время сопоставить правильный селектор и правильный набор правил! У вас есть четыре пары селекторов и набора правил для сопоставления в ваших ресурсах CSS. Сделайте это сейчас и добавьте их в файл CSS. Вам нужно сделать:\n    <ul>\n      <li>Задайте основному контейнеру карты фиксированную ширину/высоту, сплошной цвет фона, границу и радиус границы (закруглённые углы!), помимо прочего.</li>\n      <li>Задайте заголовку градиент фона, который идёт от тёмного к светлому, плюс закруглённые углы, которые вписываются в закруглённые углы, заданные для главного контейнера карты.</li>\n      <li>Задайте для футера градиент фона, переходящий от светлого к тёмному, а также скруглённые углы, которые вписываются в скруглённые углы контейнера основной карты.</li>\n      <li>Сместите изображение вправо, чтобы оно прилипло к правой стороне основного содержимого визитной карточки, и придайте ему максимальную высоту 100% (хитрый трюк, который гарантирует, что он будет растягиваться/сжиматься, чтобы оставаться на той же высоте, что и его родительский контейнер, независимо от того, какой высоты он становится).</li>\n    </ul>\n  </li>\n  <li>Осторожно! В предоставленных наборах правил есть две ошибки. Используя любую технику, которую вы знаете, отследите их и исправьте, прежде чем двигаться дальше.</li>\n</ul>\n<p>Какие новые наборы правил надо написать:</p>\n<ul>\n  <li>Напишите набор правил, предназначенный как для заголовка, так и для футера карты, задавая им вычисленную общую высоту 50 пикселей (включая высоту содержимого 30 пикселей и внутренние отступы (padding) 10 пикселей со всех сторон.) Но выразите это в <code>em</code>s.</li>\n  <li><code>margin</code> по умолчанию, применяемый браузером к элементам <code>&lt;h2&gt;</code> и <code>&lt;p&gt;</code>, будет мешать нашему дизайну, поэтому напишите правило, которое устанавливает этот параметр для указанных элементов равным 0.</li>\n  <li>Чтобы изображение не вылезало за пределы основного содержимого визитки (элемент <code>&lt;article&gt;</code>), нужно задать ему определённую высоту. Установите высоту <code>&lt;article&gt;</code> в 120px, но выраженную в <code>em</code>s. Также задайте ему полупрозрачный чёрный цвет фона, в результате получится чуть более тёмный оттенок, который позволяет цвету фона немного просвечивать красным цветом.</li>\n  <li>Напишите набор правил, который задаёт тегу <code>&lt;h2&gt;</code> удобный размер шрифта 20px (но выраженный в <code>em</code>s) и соответствующую высоту строки, чтобы поместить её в центр поля содержимого заголовка. Напомним, что высота окна содержимого (content box) должна быть 30px — это даёт вам все числа, необходимые для вычисления высоты строки.</li>\n  <li>Напишите набор правил, который задаёт тегу <code>&lt;p&gt;</code> внутри нижнего колонтитула удобный размер шрифта 15px (но выраженный в <code>em</code>s) и соответствующую высоту строки, чтобы поместить его в центр окна содержимого нижнего колонтитула. Напомним, что высота окна содержимого должна быть 30px — это даёт вам все числа, необходимые для вычисления высоты строки.</li>\n  <li>В качестве последнего штриха задайте параграфу внутри <code>&lt;article&gt;</code> соответствующее значение отступа (padding), чтобы его левый край выровнялся с тегом <code>&lt;h2&gt;</code> и нижним параграфом, и установите его цвет достаточно светлым, чтобы его было легко читать.</li>\n</ul>\n<div class="notecard note" id="sect2">\n  <p><strong>Примечание:</strong> Имейте в виду, что второй набор правил устанавливает <code>font-size: 10px;</code> для элемента <code>&lt;html&gt;</code> — это означает, что для любых потомков <code>&lt;html&gt;</code> <code>em</code> будет равен 10px, а не 16px, как это задано по умолчанию. (Это, конечно, при условии, что у потомков, о которых идёт речь, нет предков, находящихся в иерархии между ними и <code>&lt;html&gt;</code>, на которых установлен другой размер шрифта. Это может повлиять на необходимые значения, хотя в этом простом примере это не проблема).</p>\n</div>\n<p>Другие вещи для размышления:</p>\n<ul>\n  <li>Вы получите бонусные баллы, если напишите объявления своего CSS в отдельных строках, чтобы обеспечить максимальную читаемость.</li>\n  <li>Вы должны включить <code>.card</code> в начале цепочки селекторов во всех ваших правилах, чтобы эти правила не мешали стилизации каких-либо других элементов, в случае если визитная карточка должна быть помещена на страницу с загрузкой другого контента.</li>\n</ul></div></section><section aria-labelledby="советы_и_подсказки"><h2 id="советы_и_подсказки"><a>Советы и подсказки</a></h2><div class="section-content"><ul>\n  <li>Вам не нужно каким-либо образом редактировать HTML, за исключением подключения к нему CSS.</li>\n  <li>При попытке определить значение em вам нужно представить определённую величину в пикселях. Подумайте о том, какой размер базового шрифта имеет корневой элемент (<code>&lt;html&gt;</code>), и на сколько его нужно умножить, чтобы получить желаемое значение. Это даст вам значение <code>em</code>, по крайней мере, в таком простом случае как этот.</li>\n</ul></div></section><section aria-labelledby="образец"><h2 id="образец"><a>Образец</a></h2><div class="section-content"><p>На следующем снимке экрана показан образец того, как должен выглядеть готовый дизайн:</p>\n<p>\n  \n</p></div></section><section aria-labelledby="проверка"><h2 id="проверка"><a>Проверка</a></h2><div class="section-content"><p>Если вы проходите эту проверку в рамках организованного курса, у вас должна быть возможность отдать свою работу своему учителю/наставнику для оценки. Если вы самообучаетесь, то вы можете получить руководство по оценке достаточно простым путём: спросив в <a class="external" target="_blank">теме обсуждения об этом упражнении</a>, или в канале <a>#mdn</a> IRC на <a class="external" target="_blank">Mozilla IRC</a>. Но сначала попробуйте выполнить упражнение — вы ничего не выиграете путём обмана!</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Стилизация текста',
		
		content:
			'<header><h1>Стилизация текста</h1></header><div class="section-content"><p>Разобравшись с основами синтаксиса CSS, следующей темой над которой вам следует сосредоточиться, это стилизация текста — одна из наиболее распространённых вещей, которые вы будете делать с помощью CSS. В этой теме мы рассмотрим основные принципы оформления, включая выбор и определение шрифтов, использование курсива и жирного шрифта, отступов, теней и других средств придания уникальности вашему тексту. В завершение темы мы рассмотрим использование на вашей странице пользовательских шрифтов, а также оформление списков и ссылок</p></div><section aria-labelledby="необходимые_условия"><h2 id="необходимые_условия"><a>Необходимые условия</a></h2><div class="section-content"><p>Перед началом работы с этим модулем, вы должны уже иметь базовые знания HTML, как это описано во <a>Введение в HTML</a>, и с основами CSS, как описано в <a>Введение в CSS</a>.</p>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> В случае, если вы работаете на компьютере, планшете или ином устройстве, на котором у вас нет возможности создавать свои собственные файлы, вы можете попробовать выполнить примеры кода (по крайней мере, большинство из них) в специальных онлайн-программах, таких как <a class="external" target="_blank">JSBin</a> или <a class="external" target="_blank">Thimble</a>.</p>\n</div></div></section><section aria-labelledby="руководство"><h2 id="руководство"><a>Руководство</a></h2><div class="section-content"><p>Данный модуль состоит из следующих далее статей, которые дадут вам всё необходимое для оформления текстового HTML-контента.</p>\n<dl>\n  <dt id="основы_стилизации_текста_и_шрифта"><a>Основы стилизации текста и шрифта</a></dt>\n  <dd>\n    <p>В этой статье мы детально изучим стилизацию текста и шрифтов, включая параметры weight, family, style, font shorthand, text alignment и прочие эффекты, а также line и letter spacing.</p>\n  </dd>\n  <dt id="стилизация_списков"><a>Стилизация списков</a></dt>\n  <dd>\n    <p>\n      Списки, по большей части, ведут себе так же, как и любой другой текст, но они имеют некоторые особые CSS-свойства о которых нужно знать, и\n      некоторые методы которые стоит принять во внимание. Эта статья все разъясняет.\n    </p>\n  </dd>\n  <dt id="стилизация_ссылок"><a>Стилизация ссылок</a></dt>\n  <dd>\n    <p>При стилизации ссылок важно понимать, как эффективно использовать псевдоклассы для стилизации состояний ссылок, и как стилизовать ссылки для использования в общих разнообразных функциях интерфейса, таких как навигационные меню и вкладки. Мы рассмотрим все эти темы в этой статье.</p>\n  </dd>\n  <dt id="веб-шрифты"><a>Веб-шрифты</a></dt>\n  <dd>\n    <p>Здесь мы подробно рассмотрим веб-шрифты — они позволяют загружать пользовательские шрифты вместе с вашей веб-страницей, чтобы обеспечить более разнообразный, индивидуальный стиль текста.</p>\n  </dd>\n</dl></div></section><section aria-labelledby="проверка"><h2 id="проверка"><a>Проверка</a></h2><div class="section-content"><p>Следующие задания проверят ваше понимание методов стилизации текста, описанных в вышеприведённых руководствах.</p>\n<dl>\n  <dt id="вёрстка_домашней_страницы_муниципальной_школы"><a>Вёрстка домашней страницы муниципальной школы</a></dt>\n  <dd>\n    <p>В этом задании мы проверим ваше понимание стилизации текста, заставив вас оформить текст для домашней страницы общеобразовательной школы.</p>\n  </dd>\n</dl></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Основы стилизирования текста и шрифта',
		
		content:
			'<header><h1>Основы стилизирования текста и шрифта</h1></header><div class="section-content">\n<p>В данной статье мы начнём путь к овладению стилизацией текста при помощи <a>CSS</a>. Мы подробно изучим основы стилизации текста и шрифта, такие как толщина, начертание, семейство, стенография, выравнивание текста и другие эффекты, а также рассмотрим междустрочный и межбуквенный интервалы.</p>\n</div><section aria-labelledby="что_участвует_в_стилизации_текста_в_css"><h2 id="что_участвует_в_стилизации_текста_в_css"><a>Что участвует в стилизации текста в CSS?</a></h2><div class="section-content"><p>Как вы уже проверили в своей работе с HTML и CSS, текст внутри элемента выкладывается в поле содержимого элемента. Он начинается в левом верхнем углу области содержимого (или в правом верхнем углу, в случае содержимого языка RTL) и течёт к концу строки. Как только он достигает конца, он переходит к следующей строке и продолжает, затем к следующей строке, пока все содержимое не будет помещено в коробку. Текстовое содержимое эффективно ведёт себя как ряд встроенных элементов, размещённых на соседних строках и не создающих разрывы строк до тех пор, пока не будет достигнут конец строки, или если вы не принудите разрыв строки вручную с помощью элемента <a><code>&lt;br&gt;</code></a>.</p>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> если приведённый выше абзац оставляет вас в замешательстве, то не имеет значения — вернитесь и просмотрите нашу статью о модели коробки, чтобы освежить теорию модели коробки, прежде чем продолжить.</p>\n</div>\n<p>Свойства CSS, используемые для стилизации текста, обычно делятся на две категории, которые мы рассмотрим отдельно в этой статье:</p>\n<ul>\n  <li><strong>Font styles</strong>: Свойства, влияющие на шрифт, применяемый к тексту, влияющие на то, какой шрифт применяется, насколько он велик, является ли он полужирным, курсивным и т. д.</li>\n  <li><strong>Text layout styles</strong>: Свойства, влияющие на интервал и другие особенности компоновки текста, позволяющие манипулировать, например, пространством между строками и буквами, а также тем, как текст выравнивается в поле содержимого.</li>\n</ul>\n<div class="notecard note" id="sect2">\n  <p><strong>Примечание:</strong> имейте в виду, что текст внутри элемента все затронуты как одна единая сущность. Вы не можете выбирать и стилизовать подразделы текста, если вы не обернёте их в соответствующий элемент (например, <a><code>&lt;span&gt;</code></a> или <a><code>&lt;strong&gt;</code></a>), или использовать текстовый псевдоэлемент, такой как ::first-letter (выделяет первую букву текста элемента),:: first-line (выделяет первую строку текста элемента) или ::selection (выделяет текст, выделенный в данный момент курсором.)</p>\n</div></div></section><section aria-labelledby="шрифты"><h2 id="шрифты"><a>Шрифты</a></h2><div class="section-content"><p>Давайте сразу перейдём к рассмотрению свойств для стилизации шрифтов. В этом примере мы применим некоторые различные свойства CSS к одному и тому же образцу HTML, который выглядит следующим образом:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><h1>Tommy the cat</h1>\n\n<p>Well I remember it as though it were a meal ago...</p>\n\n<p>\n  Said Tommy the Cat as he reeled back to clear whatever foreign matter may have\n  nestled its way into his mighty throat. Many a fat alley rat had met its\n  demise while staring point blank down the cavernous barrel of this awesome\n  prowling machine. Truly a wonder of nature this urban predator — Tommy the cat\n  had many a story to tell. But it was a rare occasion such as this that he did.\n</p>\n</pre></div>\n<p>You can find the <a class="external" target="_blank">finished example on GitHub</a> (see also <a class="external" target="_blank">the source code</a>.)</p></div></section><section aria-labelledby="color"><h3 id="color"><a>Color</a></h3><div class="section-content"><p>The <a class="only-in-en-us" title="Currently only available in English (US)"><code>color</code> <small>(en-US)</small></a> property sets the color of the foreground content of the selected elements (which is usually the text, but can also include a couple of other things, such as an underline or overline placed on text using the <a class="only-in-en-us" title="Currently only available in English (US)"><code>text-decoration</code> <small>(en-US)</small></a> property).</p>\n<p><code>color</code> can accept any <a>CSS color unit</a>, for example:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">p {\n  color: red;\n}\n</pre></div>\n<p>This will cause the paragraphs to become red, rather than the standard browser default black, like so:</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Tommy the cat</h1>\n\n<p>Well I remember it as though it were a meal ago...</p>\n\n<p>\n  Said Tommy the Cat as he reeled back to clear whatever foreign matter may have\n  nestled its way into his mighty throat. Many a fat alley rat had met its\n  demise while staring point blank down the cavernous barrel of this awesome\n  prowling machine. Truly a wonder of nature this urban predator — Tommy the cat\n  had many a story to tell. But it was a rare occasion such as this that he did.\n</p>\n</pre></div><div class="code-example" id="sect3"><div class="example-header" id="sect4"></div></div></div></section><section aria-labelledby="font_families"><h3 id="font_families"><a>Font families</a></h3><div class="section-content"><p>To set a different font on your text, you use the <a><code>font-family</code></a> property — this allows you to specify a font (or list of fonts) for the browser to apply to the selected elements. The browser will only apply a font if it is available on the machine the website is being accessed on; if not, it will just use a browser <a>default font</a>. A simple example looks like so:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">p {\n  font-family: arial;\n}\n</pre></div>\n<p>This would make all paragraphs on a page adopt the arial font, which is found on any computer.</p>\n<h4 id="web_safe_fonts">Web safe fonts</h4>\n<p>Speaking of font availability, there are only a certain number of fonts that are generally available across all systems and can therefore be used without much worry. These are the so-called <strong>web safe fonts</strong>.</p>\n<p>Most of the time, as web developers we want to have more specific control over the fonts used to display our text content. The problem is to find a way to know which font is available on the computer used to see our web pages. There is no way to know this in every case, but the web safe fonts are known to be available on nearly all instances of the most used operating systems (Windows, macOS, the most common Linux distributions, Android, and iOS).</p>\n<p>The list of actual web safe fonts will change as operating systems evolve, but it\'s reasonable to consider the following fonts web safe, at least for now (many of them have been popularized thanks to the Microsoft <em><a class="external" target="_blank">Core fonts for the Web</a></em> initiative in the late 90s and early 2000s):</p>\n\n<div class="notecard note" id="sect5">\n  <p><strong>Примечание:</strong> Among various resources, the <a class="external" target="_blank">cssfontstack.com</a> website maintains a list of web safe fonts available on Windows and macOS operating systems, which can help you make your decision about what you consider safe for your usage.</p>\n</div>\n<div class="notecard note" id="sect6">\n  <p><strong>Примечание:</strong> There is a way to download a custom font along with a webpage, to allow you to customize your font usage in any way you want: <strong>web fonts</strong>. This is a little bit more complex, and we will be discussing this in a <a>separate article</a> later on in the module.</p>\n</div>\n<h4 id="default_fonts">Default fonts</h4>\n<p>CSS defines five generic names for fonts: <code>serif</code>, <code>sans-serif</code>, <code>monospace</code>, <code>cursive</code> and <code>fantasy</code>. Those are very generic and the exact font face used when using those generic names is up to each browser and can vary for each operating system they are running on. It represents a <em>worst case scenario</em> where the browser will try to do its best to provide at least a font that looks appropriate. <code>serif</code>, <code>sans-serif</code> and <code>monospace</code> are quite predictable and should provide something reasonable. On the other hand, <code>cursive</code> and <code>fantasy</code> are less predictable and we recommend using them very carefully, testing as you go.</p>\n<p>The five names are defined as follows:</p>\n\n<h4 id="font_stacks">Font stacks</h4>\n<p>Since you can\'t guarantee the availability of the fonts you want to use on your webpages (even a web font <em>could</em> fail for some reason), you can supply a <strong>font stack</strong> so that the browser has multiple fonts it can choose from. This simply involves a <code>font-family</code> value consisting of multiple font names separated by commas, e.g.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">p {\n  font-family: "Trebuchet MS", Verdana, sans-serif;\n}\n</pre></div>\n<p>In such a case, the browser starts at the beginning of the list and looks to see if that font is available on the machine. If it is, it applies that font to the selected elements. If not, it moves on to the next font, and so on.</p>\n<p>It is a good idea to provide a suitable generic font name at the end of the stack so that if none of the listed fonts are available, the browser can at least provide something approximately suitable. To emphasise this point, paragraphs are given the browser\'s default serif font if no other option is available — which is usually Times New Roman — this is no good for a sans-serif font!</p>\n<div class="notecard note" id="sect7">\n  <p><strong>Примечание:</strong> Font names that have more than one word — like <code>Trebuchet MS</code> — need to be surrounded by quotes, for example <code>"Trebuchet MS"</code>.</p>\n</div>\n<h4 id="a_font-family_example">A font-family example</h4>\n<p>Let\'s add to our previous example, giving the paragraphs a sans-serif font:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">p {\n  color: red;\n  font-family: Helvetica, Arial, sans-serif;\n}\n</pre></div>\n<p>This gives us the following result:</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Tommy the cat</h1>\n\n<p>Well I remember it as though it were a meal ago...</p>\n\n<p>\n  Said Tommy the Cat as he reeled back to clear whatever foreign matter may have\n  nestled its way into his mighty throat. Many a fat alley rat had met its\n  demise while staring point blank down the cavernous barrel of this awesome\n  prowling machine. Truly a wonder of nature this urban predator — Tommy the cat\n  had many a story to tell. But it was a rare occasion such as this that he did.\n</p>\n</pre></div><div class="code-example" id="sect8"><div class="example-header" id="sect9"></div></div></div></section><section aria-labelledby="font_size"><h3 id="font_size"><a>Font size</a></h3><div class="section-content"><p>In our previous module\'s <a>CSS values and units</a> article, we reviewed length and size units. Font size (set with the <a><code>font-size</code></a> property) can take values measured in most of these units (and others, such as <a>percentages</a>), however the most common units you\'ll use to size text are:</p>\n<ul>\n  <li><code>px</code> (pixels): The number of pixels high you want the text to be. This is an absolute unit — it results in the same final computed value for the font on the page in pretty much any situation.</li>\n  <li><code>em</code>s: 1 <code>em</code> is equal to the font size set on the parent element of the current element we are styling (more specifically, the width of a capital letter M contained inside the parent element.) This can become tricky to work out if you have a lot of nested elements with different font sizes set, but it is doable, as you\'ll see below. Why bother? It is quite natural once you get used to it, and you can use <code>em</code> to size everything, not just text. You can have an entire website sized using <code>em</code>, which makes maintenance easy.</li>\n  <li><code>rem</code>s: These work just like <code>em</code>, except that 1 <code>rem</code> is equal to the font size set on the root element of the document (i.e. <a><code>&lt;html&gt;</code></a>), not the parent element. This makes doing the maths to work out your font sizes much easier, although if you want to support really old browsers, you might struggle — <code>rem</code> is not supported in Internet Explorer 8 and below.</li>\n</ul>\n<p>The <code>font-size</code> of an element is inherited from that element\'s parent element. This all starts with the root element of the entire document — <a><code>&lt;html&gt;</code></a> — the <code>font-size</code> of which is set to 16<code>px</code> as standard across browsers. Any paragraph (or another element that doesn\'t have a different size set by the browser) inside the root element will have a final size of 16 <code>px</code>. Other elements may have different default sizes, for example an <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;h1&gt;</code> <small>(en-US)</small></a> element has a size of 2 <code>em</code> set by default, so it will have a final size of 32 <code>px</code>.</p>\n<p>Things become more tricky when you start altering the font size of nested elements. For example, if you had an <a><code>&lt;article&gt;</code></a> element in your page, and set its <code>font-size</code> to 1.5 <code>em</code> (which would compute to 24 <code>px</code> final size), and then wanted the paragraphs inside the <code>&lt;article&gt;</code> elements to have a computed font size of 20 <code>px</code>, what <code>em</code> value would you use?</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><!-- document base font-size is 16px -->\n<article>\n  <!-- If my font-size is 1.5em -->\n  <p>My paragraph</p>\n  <!-- How do I compute to 20px font-size? -->\n</article>\n</pre></div>\n<p>You would need to set its <code>em</code> value to 20/24, or 0.83333333 <code>em</code>. The maths can be complicated, so you need to be careful about how you style things. It is best to use <code>rem</code> where you can, to keep things simple, and avoid setting the <code>font-size</code> of container elements where possible.</p>\n<h4 id="a_simple_sizing_example">A simple sizing example</h4>\n<p>When sizing your text, it is usually a good idea to set the base <code>font-size</code> of the document to 10 <code>px</code>, so that then the maths is a lot easier to work out — required <code>(r)em</code> values are then the pixel font size divided by 10, not 16. After doing that, you can easily size the different types of text in your document to what you want. It is a good idea to list all your <code>font-size</code> rulesets in a designated area in your stylesheet, so they are easy to find.</p>\n<p>Our new result is like so:</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Tommy the cat</h1>\n\n<p>Well I remember it as though it were a meal ago...</p>\n\n<p>\n  Said Tommy the Cat as he reeled back to clear whatever foreign matter may have\n  nestled its way into his mighty throat. Many a fat alley rat had met its\n  demise while staring point blank down the cavernous barrel of this awesome\n  prowling machine. Truly a wonder of nature this urban predator — Tommy the cat\n  had many a story to tell. But it was a rare occasion such as this that he did.\n</p>\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">html {\n  font-size: 10px;\n}\n\nh1 {\n  font-size: 5rem;\n}\n\np {\n  font-size: 1.5rem;\n  color: red;\n  font-family: Helvetica, Arial, sans-serif;\n}\n</pre></div><div class="code-example" id="sect10"><div class="example-header" id="sect11"></div></div></div></section><section aria-labelledby="font_style_font_weight_text_transform_and_text_decoration"><h3 id="font_style_font_weight_text_transform_and_text_decoration"><a>Font style, font weight, text transform, and text decoration</a></h3><div class="section-content"><p>CSS provides four common properties to alter the visual weight/emphasis of text:</p>\n<ul>\n  <li><a><code>font-style</code></a>: Used to turn italic text on and off. Possible values are as follows (you\'ll rarely use this, unless you want to turn some italic styling off for some reason):\n    <ul>\n      <li><code>normal</code>: Sets the text to the normal font (turns existing italics off.)</li>\n      <li><code>italic</code>: Sets the text to use the <em>italic version of the font</em> if available; if not available, it will simulate italics with oblique instead.</li>\n      <li><code>oblique</code>: Sets the text to use a simulated version of an italic font, created by slanting the normal version.</li>\n    </ul>\n  </li>\n  <li><a><code>font-weight</code></a>: Sets how bold the text is. This has many values available in case you have many font variants available (such as <em>-light</em>, <em>-normal</em>, <em>-bold</em>, <em>-extrabold</em>, <em>-black</em>, etc.), but realistically you\'ll rarely use any of them except for <code>normal</code> and <code>bold</code>:\n    <ul>\n      <li><code>normal</code>, <code>bold</code>: Normal and <strong>bold</strong> font weight</li>\n      <li><code>lighter</code>, <code>bolder</code>: Sets the current element\'s boldness to be one step lighter or heavier than its parent element\'s boldness.</li>\n      <li><code>100</code>–<code>900</code>: Numeric boldness values that provide finer grained control than the above keywords, if needed.</li>\n    </ul>\n  </li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>text-transform</code> <small>(en-US)</small></a>: Allows you to set your font to be transformed. Values include:\n    <ul>\n      <li><code>none</code>: Prevents any transformation.</li>\n      <li><code>uppercase</code>: Transforms all text to capitals.</li>\n      <li><code>lowercase</code>: Transforms all text to lower case.</li>\n      <li><code>capitalize</code>: Transforms all words to have the first letter capitalized.</li>\n      <li><code>full-width</code>: Transforms all glyphs to be written inside a fixed-width square, similar to a monospace font, allowing aligning of e.g. Latin characters along with Asian language glyphs (like Chinese, Japanese, Korean).</li>\n    </ul>\n  </li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>text-decoration</code> <small>(en-US)</small></a>: Sets/unsets text decorations on fonts (you\'ll mainly use this to unset the default underline on links when styling them.) Available values are:\n    <ul>\n      <li><code>none</code>: Unsets any text decorations already present.</li>\n      <li><code>underline</code>: <strong>Underlines the text</strong>.</li>\n      <li><code>overline</code>: Gives the text an overline.</li>\n      <li><code>line-through</code>: Puts a <del>strikethrough over the text</del>.</li>\n    </ul>You should note that <a class="only-in-en-us" title="Currently only available in English (US)"><code>text-decoration</code> <small>(en-US)</small></a> can accept multiple values at once, if you want to add multiple decorations simultaneously, for example <code>text-decoration: underline overline</code>. Also note that <a class="only-in-en-us" title="Currently only available in English (US)"><code>text-decoration</code> <small>(en-US)</small></a> is a shorthand property for <a class="only-in-en-us" title="Currently only available in English (US)"><code>text-decoration-line</code> <small>(en-US)</small></a>, <a class="only-in-en-us" title="Currently only available in English (US)"><code>text-decoration-style</code> <small>(en-US)</small></a>, and <a class="only-in-en-us" title="Currently only available in English (US)"><code>text-decoration-color</code> <small>(en-US)</small></a>. You can use combinations of these property values to create interesting effects, for example <code>text-decoration: line-through red wavy</code>.\n  </li>\n</ul>\n<p>Let\'s look at adding a couple of these properties to our example:</p>\n<p>Our new result is like so:</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Tommy the cat</h1>\n\n<p>Well I remember it as though it were a meal ago...</p>\n\n<p>\n  Said Tommy the Cat as he reeled back to clear whatever foreign matter may have\n  nestled its way into his mighty throat. Many a fat alley rat had met its\n  demise while staring point blank down the cavernous barrel of this awesome\n  prowling machine. Truly a wonder of nature this urban predator — Tommy the cat\n  had many a story to tell. But it was a rare occasion such as this that he did.\n</p>\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">html {\n  font-size: 10px;\n}\n\nh1 {\n  font-size: 5rem;\n  text-transform: capitalize;\n}\n\nh1 + p {\n  font-weight: bold;\n}\n\np {\n  font-size: 1.5rem;\n  color: red;\n  font-family: Helvetica, Arial, sans-serif;\n}\n</pre></div><div class="code-example" id="sect12"><div class="example-header" id="sect13"></div></div></div></section><section aria-labelledby="text_drop_shadows"><h3 id="text_drop_shadows"><a>Text drop shadows</a></h3><div class="section-content"><p>You can apply drop shadows to your text using the <a><code>text-shadow</code></a> property. This takes up to four values, as shown in the example below:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">text-shadow: 4px 4px 5px red;\n</pre></div>\n<p>The four properties are as follows:</p>\n<ol>\n  <li>The horizontal offset of the shadow from the original text — this can take most available CSS <a>length and size units</a>, but you\'ll most commonly use <code>px</code>; positive values move the shadow right, and negative values left. This value has to be included.</li>\n  <li>The vertical offset of the shadow from the original text; behaves basically just like the horizontal offset, except that it moves the shadow up/down, not left/right. This value has to be included.</li>\n  <li>The blur radius — a higher value means the shadow is dispersed more widely. If this value is not included, it defaults to 0, which means no blur. This can take most available CSS <a>length and size units</a>.</li>\n  <li>The base color of the shadow, which can take any <a>CSS color unit</a>. If not included, it defaults to <code>black</code>.</li>\n</ol>\n<h4 id="multiple_shadows">Multiple shadows</h4>\n<p>You can apply multiple shadows to the same text by including multiple shadow values separated by commas, for example:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">text-shadow:\n  1px 1px 1px red,\n  2px 2px 1px red;\n</pre></div>\n<p>If we applied this to the <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;h1&gt;</code> <small>(en-US)</small></a> element in our Tommy the cat example, we\'d end up with this:</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Tommy the cat</h1>\n\n<p>Well I remember it as though it were a meal ago...</p>\n\n<p>\n  Said Tommy the Cat as he reeled back to clear whatever foreign matter may have\n  nestled its way into his mighty throat. Many a fat alley rat had met its\n  demise while staring point blank down the cavernous barrel of this awesome\n  prowling machine. Truly a wonder of nature this urban predator — Tommy the cat\n  had many a story to tell. But it was a rare occasion such as this that he did.\n</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">html {\n  font-size: 10px;\n}\n\nh1 {\n  font-size: 5rem;\n  text-transform: capitalize;\n  text-shadow:\n    1px 1px 1px red,\n    2px 2px 1px red;\n}\n\nh1 + p {\n  font-weight: bold;\n}\n\np {\n  font-size: 1.5rem;\n  color: red;\n  font-family: Helvetica, Arial, sans-serif;\n}\n</pre></div><div class="code-example" id="sect14"><div class="example-header" id="sect15"></div></div>\n<div class="notecard note" id="sect16">\n  <p><strong>Примечание:</strong> You can see more interesting examples of <code>text-shadow</code> usage in the Sitepoint article <a class="external" target="_blank">Moonlighting with CSS text-shadow</a>.</p>\n</div></div></section><section aria-labelledby="text_layout"><h2 id="text_layout"><a>Text layout</a></h2><div class="section-content"><p>With basic font properties out the way, let\'s now have a look at properties we can use to affect text layout.</p></div></section><section aria-labelledby="text_alignment"><h3 id="text_alignment"><a>Text alignment</a></h3><div class="section-content"><p>The <a><code>text-align</code></a> property is used to control how text is aligned within its containing content box. The available values are as follows, and work in pretty much the same way as they do in a regular word processor application:</p>\n<ul>\n  <li><code>left</code>: Left-justifies the text.</li>\n  <li><code>right</code>: Right-justifies the text.</li>\n  <li><code>center</code>: Centers the text.</li>\n  <li><code>justify</code>: Makes the text spread out, varying the gaps in between the words so that all lines of text are the same width. You need to use this carefully — it can look terrible, especially when applied to a paragraph with lots of long words in it. If you are going to use this, you should also think about using something else along with it, such as <a><code>hyphens</code></a>, to break some of the longer words across lines.</li>\n</ul>\n<p>If we applied <code>text-align: center;</code> to the <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;h1&gt;</code> <small>(en-US)</small></a> in our example, we\'d end up with this:</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Tommy the cat</h1>\n\n<p>Well I remember it as though it were a meal ago...</p>\n\n<p>\n  Said Tommy the Cat as he reeled back to clear whatever foreign matter may have\n  nestled its way into his mighty throat. Many a fat alley rat had met its\n  demise while staring point blank down the cavernous barrel of this awesome\n  prowling machine. Truly a wonder of nature this urban predator — Tommy the cat\n  had many a story to tell. But it was a rare occasion such as this that he did.\n</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">html {\n  font-size: 10px;\n}\n\nh1 {\n  font-size: 5rem;\n  text-transform: capitalize;\n  text-shadow:\n    1px 1px 1px red,\n    2px 2px 1px red;\n  text-align: center;\n}\n\nh1 + p {\n  font-weight: bold;\n}\n\np {\n  font-size: 1.5rem;\n  color: red;\n  font-family: Helvetica, Arial, sans-serif;\n}\n</pre></div><div class="code-example" id="sect17"><div class="example-header" id="sect18"></div></div></div></section><section aria-labelledby="line_height"><h3 id="line_height"><a>Line height</a></h3><div class="section-content"><p>The <a><code>line-height</code></a> property sets the height of each line of text — this can take most <a>length and size units</a>, but can also take a unitless value, which acts as a multiplier and is generally considered the best option — the <a><code>font-size</code></a> is multiplied to get the <code>line-height</code>. Body text generally looks nicer and is easier to read when the lines are spaced apart; the recommended line height is around 1.5 – 2 (double spaced.) So to set our lines of text to 1.6 times the height of the font, you\'d use this:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">line-height: 1.6;\n</pre></div>\n<p>Applying this to the <a><code>&lt;p&gt;</code></a> elements in our example would give us this result:</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Tommy the cat</h1>\n\n<p>Well I remember it as though it were a meal ago...</p>\n\n<p>\n  Said Tommy the Cat as he reeled back to clear whatever foreign matter may have\n  nestled its way into his mighty throat. Many a fat alley rat had met its\n  demise while staring point blank down the cavernous barrel of this awesome\n  prowling machine. Truly a wonder of nature this urban predator — Tommy the cat\n  had many a story to tell. But it was a rare occasion such as this that he did.\n</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">html {\n  font-size: 10px;\n}\n\nh1 {\n  font-size: 5rem;\n  text-transform: capitalize;\n  text-shadow:\n    1px 1px 1px red,\n    2px 2px 1px red;\n  text-align: center;\n}\n\nh1 + p {\n  font-weight: bold;\n}\n\np {\n  font-size: 1.5rem;\n  color: red;\n  font-family: Helvetica, Arial, sans-serif;\n  line-height: 1.6;\n}\n</pre></div><div class="code-example" id="sect19"><div class="example-header" id="sect20"></div></div></div></section><section aria-labelledby="letter_and_word_spacing"><h3 id="letter_and_word_spacing"><a>Letter and word spacing</a></h3><div class="section-content"><p>The <a><code>letter-spacing</code></a> and <a><code>word-spacing</code></a> properties allow you to set the spacing between letters and words in your text. You won\'t use these very often, but might find a use for them to get a certain look, or to improve the legibility of a particularly dense font. They can take most <a>length and size units</a>.</p>\n<p>So as an example, we could apply some word- and letter-spacing to the first line of each <a><code>&lt;p&gt;</code></a> element in our example:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">p::first-line {\n  letter-spacing: 4px;\n  word-spacing: 4px;\n}\n</pre></div>\n<p>Let\'s add some to our example, like so:</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Tommy the cat</h1>\n\n<p>Well I remember it as though it were a meal ago...</p>\n\n<p>\n  Said Tommy the Cat as he reeled back to clear whatever foreign matter may have\n  nestled its way into his mighty throat. Many a fat alley rat had met its\n  demise while staring point blank down the cavernous barrel of this awesome\n  prowling machine. Truly a wonder of nature this urban predator — Tommy the cat\n  had many a story to tell. But it was a rare occasion such as this that he did.\n</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">html {\n  font-size: 10px;\n}\n\nh1 {\n  font-size: 5rem;\n  text-transform: capitalize;\n  text-shadow:\n    1px 1px 1px red,\n    2px 2px 1px red;\n  text-align: center;\n  letter-spacing: 2px;\n}\n\nh1 + p {\n  font-weight: bold;\n}\n\np::first-line {\n  letter-spacing: 4px;\n  word-spacing: 4px;\n}\n\np {\n  font-size: 1.5rem;\n  color: red;\n  font-family: Helvetica, Arial, sans-serif;\n  line-height: 1.6;\n  letter-spacing: 1px;\n}\n</pre></div><div class="code-example" id="sect21"><div class="example-header" id="sect22"></div></div></div></section><section aria-labelledby="other_properties_worth_looking_at"><h3 id="other_properties_worth_looking_at"><a>Other properties worth looking at</a></h3><div class="section-content"><p>The above properties give you an idea of how to start styling text on a webpage, but there are many more properties you could use. We just wanted to cover the most important ones here. Once you\'ve become used to using the above, you should also explore the following:</p>\n<p>Font styles:</p>\n<ul>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>font-variant</code> <small>(en-US)</small></a>: Switch between small caps and normal font alternatives.</li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>font-kerning</code> <small>(en-US)</small></a>: Switch font kerning options on and off.</li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>font-feature-settings</code> <small>(en-US)</small></a>: Switch various <a class="external" target="_blank">OpenType</a> font features on and off.</li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>font-variant-alternates</code> <small>(en-US)</small></a>: Control the use of alternate glyphs for a given font-face.</li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>font-variant-caps</code> <small>(en-US)</small></a>: Control the use of alternate capital glyphs.</li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>font-variant-east-asian</code> <small>(en-US)</small></a>: Control the usage of alternate glyphs for East Asian scripts, like Japanese and Chinese.</li>\n  <li><a><code>font-variant-ligatures</code></a>: Control which ligatures and contextual forms are used in text.</li>\n  <li><a><code>font-variant-numeric</code></a>: Control the usage of alternate glyphs for numbers, fractions, and ordinal markers.</li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>font-variant-position</code> <small>(en-US)</small></a>: Control the usage of alternate glyphs of smaller sizes positioned as superscript or subscript.</li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>font-size-adjust</code> <small>(en-US)</small></a>: Adjust the visual size of the font independently of its actual font size.</li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>font-stretch</code> <small>(en-US)</small></a>: Switch between possible alternative stretched versions of a given font.</li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>text-underline-position</code> <small>(en-US)</small></a>: Specify the position of underlines set using the <code>text-decoration-line</code> property <code>underline</code> value.</li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>text-rendering</code> <small>(en-US)</small></a>: Try to perform some text rendering optimization.</li>\n</ul>\n<p>Text layout styles:</p>\n<ul>\n  <li><a><code>text-indent</code></a>: Specify how much horizontal space should be left before the beginning of the first line of the text content.</li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>text-overflow</code> <small>(en-US)</small></a>: Define how overflowed content that is not displayed is signaled to users.</li>\n  <li><a><code>white-space</code></a>: Define how whitespace and associated line breaks inside the element are handled.</li>\n  <li><a><code>word-break</code></a>: Specify whether to break lines within words.</li>\n  <li><a><code>direction</code></a>: Define the text direction (This depends on the language and usually it\'s better to let HTML handle that part as it is tied to the text content.)</li>\n  <li><a><code>hyphens</code></a>: Switch on and off hyphenation for supported languages.</li>\n  <li><a><code>line-break</code></a>: Relax or strengthen line breaking for Asian languages.</li>\n  <li><a><code>text-align-last</code></a>: Define how the last line of a block or a line, right before a forced line break, is aligned.</li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>text-orientation</code> <small>(en-US)</small></a>: Define the orientation of the text in a line.</li>\n  <li><a><code>overflow-wrap</code></a>: Specify whether or not the browser may break lines within words in order to prevent overflow.</li>\n  <li><a><code>writing-mode</code></a>: Define whether lines of text are laid out horizontally or vertically and the direction in which subsequent lines flow.</li>\n</ul></div></section><section aria-labelledby="font_shorthand"><h2 id="font_shorthand"><a>Font shorthand</a></h2><div class="section-content"><p>Many font properties can also be set through the shorthand property <a><code>font</code></a>. These are written in the following order: <a><code>font-style</code></a>, <a class="only-in-en-us" title="Currently only available in English (US)"><code>font-variant</code> <small>(en-US)</small></a>, <a><code>font-weight</code></a>, <a class="only-in-en-us" title="Currently only available in English (US)"><code>font-stretch</code> <small>(en-US)</small></a>, <a><code>font-size</code></a>, <a><code>line-height</code></a>, and <a><code>font-family</code></a>.</p>\n<p>Among all those properties, only <code>font-size</code> and <code>font-family</code> are required when using the <code>font</code> shorthand property.</p>\n<p>A forward slash has to be put in between the <a><code>font-size</code></a> and <a><code>line-height</code></a> properties.</p>\n<p>A full example would look like this:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">font:\n  italic normal bold normal 3em/1.5 Helvetica,\n  Arial,\n  sans-serif;\n</pre></div></div></section><section aria-labelledby="active_learning_playing_with_styling_text"><h2 id="active_learning_playing_with_styling_text"><a>Active learning: Playing with styling text</a></h2><div class="section-content"><p>In this active learning session, we don\'t have any specific exercises for you to do: we\'d just like you to have a good play with some font/text layout properties, and see what you can produce! You can either do this using offline HTML/CSS files, or enter your code into the live editable example below.</p>\n<p>If you make a mistake, you can always reset it using the <em>Reset</em> button.</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><div class="body-wrapper" style="font-family: \'Open Sans Light\',Helvetica,Arial,sans-serif;">\n  <h2>HTML Input</h2>\n  <input id="code" class="html-input" style="width: 90%;height: 10em;padding: 10px;border: 1px solid #0095dd;">&lt;p&gt;Some sample text for your delight&lt;/p&gt;\n  </input>\n\n  <h2>CSS Input</h2>\n  <input id="code" class="css-input" style="width: 90%;height: 10em;padding: 10px;border: 1px solid #0095dd;">p {\n\n}\n</input>\n\n  <h2>Output</h2>\n  <div class="output" style="width: 90%;height: 10em;padding: 10px;border: 1px solid #0095dd;"></div>\n  <div class="controls">\n    <input id="reset" type="button" value="Reset" style="margin: 10px 10px 0 0;">\n  </div>\n</div>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">const htmlInput = document.querySelector(".html-input");\nconst cssInput = document.querySelector(".css-input");\nconst reset = document.getElementById("reset");\nlet htmlCode = htmlInput.value;\nlet cssCode = cssInput.value;\nconst output = document.querySelector(".output");\n\nconst styleElem = document.createElement("style");\nconst headElem = document.querySelector("head");\nheadElem.appendChild(styleElem);\n\nfunction drawOutput() {\n  output.innerHTML = htmlInput.value;\n  styleElem.textContent = cssInput.value;\n}\n\nreset.addEventListener("click", function () {\n  htmlInput.value = htmlCode;\n  cssInput.value = cssCode;\n  drawOutput();\n});\n\nhtmlInput.addEventListener("input", drawOutput);\ncssInput.addEventListener("input", drawOutput);\nwindow.addEventListener("load", drawOutput);\n</pre></div><div class="code-example" id="sect23"><div class="example-header" id="sect24"></div></div></div></section><section aria-labelledby="test_your_skills!"><h2 id="test_your_skills!"><a>Test your skills!</a></h2><div class="section-content"><p>You\'ve reached the end of this article, and already did some skill testing in our Active Learning section, but can you remember the most important information going forward? You can find an assessment to verify that you\'ve retained this information at the end of the module — see <a>Typesetting a community school homepage</a>.</p>\n<p>This assessment tests all the knowledge discussed in this module, so you might want to read the other articles before moving on to it.</p></div></section><section aria-labelledby="summary"><h2 id="summary"><a>Summary</a></h2><div class="section-content"><p>We hoped you enjoyed playing with text in this article! The next article will give you all you need to know about styling HTML lists.</p></div></section><section aria-labelledby="in_this_module"><h2 id="in_this_module"><a>In this module</a></h2><div class="section-content"><ul>\n  <li><a aria-current="page">Fundamental text and font styling</a></li>\n  <li><a>Styling lists</a></li>\n  <li><a>Styling links</a></li>\n  <li><a>Web fonts</a></li>\n  <li><a>Typesetting a community school homepage</a></li>\n</ul></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Стилизация списков',
		
		content:
			'<header><h1>Стилизация списков</h1></header><div class="section-content">\n<p><a>Списки</a>, по-большому счету, ведут себя также как любой другой текст, но существуют некоторые специфичные настройки CSS, о которых вы должны знать. В этой статье они все описываются.</p>\n</div><section aria-labelledby="пример_простого_списка"><h2 id="пример_простого_списка"><a>Пример простого списка</a></h2><div class="section-content"><p>Для начала, давайте взглянем на пример простого списка. В данной статье мы рассмотрим ненумерованный, нумерованный и описательный списки — все они имеют аналогичные свойства стилизации, но некоторые имеют свои специальные свойства. Не стилизованный пример <a class="external" target="_blank">доступен на Github</a> (проверьте также <a class="external" target="_blank">источник кода</a>.)</p>\n<p>HTML для нашего примера списка представлен ниже:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><h2>Shopping (unordered) list</h2>\n\n<p>\n  Paragraph for reference, paragraph for reference, paragraph for reference,\n  paragraph for reference, paragraph for reference, paragraph for reference.\n</p>\n\n<ul>\n  <li>Hummus</li>\n  <li>Pita</li>\n  <li>Green salad</li>\n  <li>Halloumi</li>\n</ul>\n\n<h2>Recipe (ordered) list</h2>\n\n<p>\n  Paragraph for reference, paragraph for reference, paragraph for reference,\n  paragraph for reference, paragraph for reference, paragraph for reference.\n</p>\n\n<ol>\n  <li>Toast pita, leave to cool, then slice down the edge.</li>\n  <li>\n    Fry the halloumi in a shallow, non-stick pan, until browned on both sides.\n  </li>\n  <li>Wash and chop the salad.</li>\n  <li>Fill pita with salad, hummus, and fried halloumi.</li>\n</ol>\n\n<h2>Ingredient description list</h2>\n\n<p>\n  Paragraph for reference, paragraph for reference, paragraph for reference,\n  paragraph for reference, paragraph for reference, paragraph for reference.\n</p>\n\n<dl>\n  <dt>Hummus</dt>\n  <dd>\n    A thick dip/sauce generally made from chick peas blended with tahini, lemon\n    juice, salt, garlic, and other ingredients.\n  </dd>\n  <dt>Pita</dt>\n  <dd>A soft, slightly leavened flatbread.</dd>\n  <dt>Halloumi</dt>\n  <dd>\n    A semi-hard, unripened, brined cheese with a higher-than-usual melting\n    point, usually made from goat/sheep milk.\n  </dd>\n  <dt>Green salad</dt>\n  <dd>That green healthy stuff that many of us just use to garnish kebabs.</dd>\n</dl>\n</pre></div>\n<p>Если вы перейдёте к живому примеру прямо сейчас и изучите элемент списка используя <a>инструменты разработчика браузера</a>, то вы заметите несколько стилей установленных по умолчанию:</p>\n<ul>\n  <li>Элементы <a><code>&lt;ul&gt;</code></a> и <a><code>&lt;ol&gt;</code></a> имеют верхний и нижний <a><code>margin</code></a> по <code>16px</code> (<code>1em</code>) и <a><code>padding-left</code></a> <code>40px</code> (<code>2.5em</code>.)</li>\n  <li>Объекты списка (элементы <a><code>&lt;li&gt;</code></a>) не имеют заданных значений по умолчанию для интервалов.</li>\n  <li>Элемент <a><code>&lt;dl&gt;</code></a> имеет верхний и нижний <a><code>margin</code></a> по <code>16px</code> (<code>1em</code>), но padding не задан.</li>\n  <li>Элементы <a><code>&lt;dd&gt;</code></a> имеют <a><code>margin-left</code></a> <code>40px</code> (<code>2.5em</code>.)</li>\n  <li>Элементы <a><code>&lt;p&gt;</code></a> которые мы включили для ссылок (сноски) имеют верхний и нижний <a><code>margin</code></a> по <code>16px</code> (<code>1em</code>), точно так же, как и различные типы списков.</li>\n</ul></div></section><section aria-labelledby="управление_интервалами_списков"><h2 id="управление_интервалами_списков"><a>Управление интервалами списков</a></h2><div class="section-content"><p>При оформлении списков, вам необходимо настроить их стили так, чтоб они сохраняли то же вертикальное расстояние, что и окружающие их элементы (такие как параграфы и изображения; иногда называемые вертикальным ритмом) и то же расстояние по горизонтали как и между собой (посмотреть <a class="external" target="_blank">законченный стилизированный пример</a> на Github, а также <a class="external" target="_blank">найти исходный код</a>.)</p>\n<p>CSS, используемый для оформления текста и интервалов, выглядит следующим образом:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">/* Базовые стили */\n\nhtml {\n  font-family: Helvetica, Arial, sans-serif;\n  font-size: 10px;\n}\n\nh2 {\n  font-size: 2rem;\n}\n\nul,\nol,\ndl,\np {\n  font-size: 1.5rem;\n}\n\nli,\np {\n  line-height: 1.5;\n}\n\n/* Задаём стили для списка описаний */\n\ndd,\ndt {\n  line-height: 1.5;\n}\n\ndt {\n  font-weight: bold;\n}\n\ndd {\n  margin-bottom: 1.5rem;\n}\n</pre></div>\n<ul>\n  <li>Первое правило устанавливает шрифт сайта и основной размер шрифта 10px. Они наследуются всеми на этой странице.</li>\n  <li>Правила 2 и 3 задают относительные размеры шрифтов заголовков, различных типов списков (их наследуют дочерние элементы списков) и параграфов. Это значит, что каждый параграф и список будут иметь одинаковый размер шрифта, а также верхний и нижний интервалы, помогая сохранить согласованность вертикального ритма.</li>\n  <li>Правило 4 задаёт одинаковую высоту <a><code>line-height</code></a> в параграфах и пунктах списка — так, что параграфы и каждый отдельный пункт списка будут иметь те же интервалы между строками. Это также поможет сохранить согласованность вертикального ритма.</li>\n  <li>Правила 5 и 6 применяются к списку описаний — мы задаём одинаковую высоту <code>line-height</code> между терминами и описаниями списке описаний как мы это делали с параграфами и пунктами списка. И снова, согласованность хорошая! Мы также делаем описание терминов жирным шрифтом, чтобы они визуально выделялись легче.</li>\n</ul></div></section><section aria-labelledby="стили_специфичные_для_списков"><h2 id="стили_специфичные_для_списков"><a>Стили специфичные для списков</a></h2><div class="section-content"><p>Теперь, рассмотрев общие методы интервалов для списков, давайте изучим некоторые специфичные спискам свойства. Существует три свойства, с которых вам надо начать знакомство, которые могут быть установлены для элементов <a><code>&lt;ul&gt;</code></a> или <a><code>&lt;ol&gt;</code></a>:</p>\n<ul>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>list-style-type</code> <small>(en-US)</small></a>: задаёт тип маркеров для использования в списке, например, квадратные или круглые маркеры для неупорядоченного списка, или цифры, буквы или римские цифры для упорядоченного списка.</li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>list-style-position</code> <small>(en-US)</small></a>: управляет будет ли маркер появляется внутри пунктов списка или вне их перед началом каждого элемента.</li>\n  <li><a><code>list-style-image</code></a>: позволяет вам использовать пользовательские изображения в качестве маркеров, а не просто квадрат или круг.</li>\n</ul></div></section><section aria-labelledby="стили_маркеров"><h3 id="стили_маркеров"><a>Стили маркеров</a></h3><div class="section-content"><p>Как указано выше, свойство <a class="only-in-en-us" title="Currently only available in English (US)"><code>list-style-type</code> <small>(en-US)</small></a> позволяет вам устанавливать какой тип маркера использовать в качестве точек маркера. В нашем примере мы установили использование заглавных римских цифр в упорядоченном списке:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">ol {\n  list-style-type: upper-roman;\n}\n</pre></div>\n<p>Это даёт нам следующий вид:</p>\n<p>\n  \n</p>\n<p>Вы можете найти гораздо больше опций, заглянув на справочную страницу <a class="only-in-en-us" title="Currently only available in English (US)"><code>list-style-type</code> <small>(en-US)</small></a>.</p></div></section><section aria-labelledby="позиция_маркера"><h3 id="позиция_маркера"><a>Позиция маркера</a></h3><div class="section-content"><p>Свойство <a class="only-in-en-us" title="Currently only available in English (US)"><code>list-style-position</code> <small>(en-US)</small></a> устанавливает будет ли появляться маркер внутри пунктов списка или снаружи перед началом каждого пункта. Значение по умолчанию — <code>outside</code>, которое заставляет маркеры находится снаружи пунктов списка, как видно выше.</p>\n<p>Если вы установите значение на <code>inside</code>, то маркеры будут находиться внутри строк:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">ol {\n  list-style-type: upper-roman;\n  list-style-position: inside;\n}\n</pre></div>\n<p>\n  \n</p></div></section><section aria-labelledby="использование_пользовательского_изображения_как_маркер"><h3 id="использование_пользовательского_изображения_как_маркер"><a>Использование пользовательского изображения как маркер</a></h3><div class="section-content"><p>Свойство <a><code>list-style-image</code></a> позволяет вам использовать пользовательское изображение в качестве вашего маркера. Синтаксис довольно прост:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">ul {\n  list-style-image: url(star.svg);\n}\n</pre></div>\n<p>Однако это свойство немного ограничено с точки зрения управления позициями, размерами (и т.д.) маркеров. Вам лучше использовать семейство свойств <a><code>background</code></a>, о которых вы узнаете намного больше в модуле <a>Styling boxes</a>. А пока вот вам образец для дегустации!</p>\n<p>В нашем законченном примере мы оформили неупорядоченный список следующим образом (поверх того, что вы уже видели выше):</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">ul {\n  padding-left: 2rem;\n  list-style-type: none;\n}\n\nul li {\n  padding-left: 2rem;\n  background-image: url(star.svg);\n  background-position: 0 0;\n  background-size: 1.6rem 1.6rem;\n  background-repeat: no-repeat;\n}\n</pre></div>\n<p>Мы сделали следующее:</p>\n<ul>\n  <li>Установили <a><code>padding-left</code></a> элемента <a><code>&lt;ul&gt;</code></a> с <code>40px</code> по умолчанию на <code>20px</code>, затем установили то же самое количество в пунктах списка. Это для того, чтобы все пункты списка продолжали выравниваться с порядком пунктов списка и описаний списка описаний, но пункты списка имеют некоторый padding для фоновых изображений чтобы сидеть внутри. Если бы мы не сделали этого, то фоновые изображения накладывались бы с текстом пунктов списка, что выглядело бы неряшливо.</li>\n  <li>Установили <a class="only-in-en-us" title="Currently only available in English (US)"><code>list-style-type</code> <small>(en-US)</small></a> на <code>none</code>, для того чтобы маркеры не появлялись по умолчанию. Мы собираемся использовать свойства <a><code>background</code></a> для управления маркерами.</li>\n  <li>Вставили маркер в каждый пункт неупорядоченного списка. Соответствующие свойства, следующие:\n    <ul>\n      <li><a><code>background-image</code></a>: Указывает путь к файлу изображения, который вы хотите использовать в качестве маркера.</li>\n      <li><a><code>background-position</code></a>: Определяет где в фоне выбранного элемента появится изображение — в данном случае мы говорим <code>0 0</code>, что значит что маркер будет появляться в самом верху слева каждого пункта списка.</li>\n      <li><a><code>background-size</code></a>: Задаёт размер фонового изображения. В идеале мы хотим, чтоб маркеры были того же размера что и пункты списка (или самую малость меньше или крупнее). Мы используем размер <code>1.6rem</code> (<code>16px</code>), что очень хорошо сочетается с отступом (padding) <code>20px</code>, который мы позволили разместить внутри маркера — 16px плюс 4px интервала между маркером и текстом пункта списка работают хорошо.</li>\n      <li><a><code>background-repeat</code></a>: По умолчанию, фоновые изображения повторяются пока не заполнят доступное фоновое пространство. Мы хотим всего лишь одну копию вставленного изображения в каждом случае, поэтому мы установили значение <code>no-repeat</code>.</li>\n    </ul>\n  </li>\n</ul>\n<p>Это даёт нам следующий результат:</p>\n<p>\n  \n</p></div></section><section aria-labelledby="короткая_запись_list-style"><h3 id="короткая_запись_list-style"><a>короткая запись list-style</a></h3><div class="section-content"><p>Эти три свойства упомянутые выше могут все быть заданы, используя лишь одну короткую запись свойства, <a class="only-in-en-us" title="Currently only available in English (US)"><code>list-style</code> <small>(en-US)</small></a>. Например, следующий CSS:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">ul {\n  list-style-type: square;\n  list-style-image: url(example.png);\n  list-style-position: inside;\n}\n</pre></div>\n<p>Может быть заменён этим:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">ul {\n  list-style: square url(example.png) inside;\n}\n</pre></div>\n<p>Значения могут быть перечислены в любом порядке, и вы можете использовать одно, два и все три (значения по умолчанию, использованные для свойств, которые не включены — <code>disc</code>, <code>none</code>, и <code>outside</code>). Если указаны и <code>type</code> и <code>image</code>, тип используется в качестве запасного варианта, если изображение по какой-либо причине не может быть загружено.</p></div></section><section aria-labelledby="контроль_счета_списка"><h2 id="контроль_счета_списка"><a>Контроль счета списка</a></h2><div class="section-content"><p>Иногда вам может понадобиться вести счёт в упорядоченном списке по-другому — например начинать с цифры отличной от 1, или считать в обратном порядке, или вести счёт с шагом больше 1. HTML и CSS имеют несколько инструментов которые помогут с этим.</p></div></section><section aria-labelledby="start"><h3 id="start"><a>start</a></h3><div class="section-content"><p>Атрибут <a><code>start</code></a> позволит вам начать счёт списка с цифры отличной от 1. Например:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><ol start="4">\n  <li>Toast pita, leave to cool, then slice down the edge.</li>\n  <li>\n    Fry the halloumi in a shallow, non-stick pan, until browned on both sides.\n  </li>\n  <li>Wash and chop the salad.</li>\n  <li>Fill pita with salad, hummus, and fried halloumi.</li>\n</ol>\n</pre></div>\n<p>что даст вам такой результат:</p><div class="code-example" id="sect1"><div class="example-header" id="sect2"></div></div></div></section><section aria-labelledby="reversed"><h3 id="reversed"><a>reversed</a></h3><div class="section-content"><p>Атрибут <a><code>reversed</code></a> начнёт отсчёт по убыванию вместо возрастания. Например:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><ol start="4" reversed="">\n  <li>Toast pita, leave to cool, then slice down the edge.</li>\n  <li>\n    Fry the halloumi in a shallow, non-stick pan, until browned on both sides.\n  </li>\n  <li>Wash and chop the salad.</li>\n  <li>Fill pita with salad, hummus, and fried halloumi.</li>\n</ol>\n</pre></div>\n<p>что даст вам такой результат:</p><div class="code-example" id="sect3"><div class="example-header" id="sect4"></div></div>\n<div class="notecard note" id="sect5">\n  <p><strong>Примечание:</strong> Если пунктов в списке в обратном списке больше, чем значение атрибута <code>start</code>, счёт продолжится до нуля и далее отрицательные значения.</p>\n</div></div></section><section aria-labelledby="value"><h3 id="value"><a>value</a></h3><div class="section-content"><p>Атрибут <a><code>value</code></a> позволит вам установить специфичные цифровые значения к пунктам списка. Например:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><ol>\n  <li value="2">Toast pita, leave to cool, then slice down the edge.</li>\n  <li value="4">\n    Fry the halloumi in a shallow, non-stick pan, until browned on both sides.\n  </li>\n  <li value="6">Wash and chop the salad.</li>\n  <li value="8">Fill pita with salad, hummus, and fried halloumi.</li>\n</ol>\n</pre></div>\n<p>что даст вам такой результат:</p><div class="code-example" id="sect6"><div class="example-header" id="sect7"></div></div>\n<div class="notecard note" id="sect8">\n  <p><strong>Примечание:</strong> Даже если вы используете нечисловой <a class="only-in-en-us" title="Currently only available in English (US)"><code>list-style-type</code> <small>(en-US)</small></a>, вам всё равно надо использовать эквивалентное цифровое значение в атрибуте <code>value</code>.</p>\n</div></div></section><section aria-labelledby="активное_изучение_стилизация_вложенного_списка"><h2 id="активное_изучение_стилизация_вложенного_списка"><a>Активное изучение: Стилизация вложенного списка</a></h2><div class="section-content"><p>В этой сессии активного изучения, мы хотим, чтобы вы взяли всё что вы выучили выше и попробовали стилизовать вложенный список. Мы предоставили вам HTML и хотим, чтобы вы:</p>\n<ol>\n  <li>Задали неупорядоченному списку квадратные маркеры.</li>\n  <li>Задали пунктам неупорядоченного и упорядоченного списка 1,5 межстрочный интервал их размера шрифта.</li>\n  <li>Задали упорядоченному списку маркеры в виде строчных букв.</li>\n  <li>Не стесняйтесь играться с примерами списков столько сколько вам нравится, экспериментируя с типами маркеров, интервалами или со всем что вы найдёте.</li>\n</ol>\n<p>Если вы допустите ошибку, вы всегда можете сделать сброс используя кнопку <em>Reset</em>. Если вы застрянете, нажмите кнопку <em>Show solution</em> чтобы посмотреть возможный ответ.</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><div class="body-wrapper" style="font-family: \'Open Sans Light\',Helvetica,Arial,sans-serif;">\n  <h2>HTML Input</h2>\n  <input id="code" class="html-input" style="width: 90%;height: 10em;padding: 10px;border: 1px solid #0095dd;">&lt;ul&gt;\n  &lt;li&gt;First, light the candle.&lt;/li&gt;\n  &lt;li&gt;Next, open the box.&lt;/li&gt;\n  &lt;li&gt;Finally, place the three magic items in the box, in this exact order, to complete the spell:\n    &lt;ol&gt;\n      &lt;li&gt;The book of spells&lt;/li&gt;\n      &lt;li&gt;The shiny rod&lt;/li&gt;\n      &lt;li&gt;The goblin statue&lt;/li&gt;\n    &lt;/ol&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;</input>\n\n  <h2>CSS Input</h2>\n  <input id="code" class="css-input" style="width: 90%;height: 10em;padding: 10px;border: 1px solid #0095dd;"></input>\n\n  <h2>Output</h2>\n  <div class="output" style="width: 90%;height: 12em;padding: 10px;border: 1px solid #0095dd;overflow: auto;"></div>\n  <div class="controls">\n    <input id="reset" type="button" value="Reset" style="margin: 10px 10px 0 0;">\n    <input id="solution" type="button" value="Show solution" style="margin: 10px 0 0 10px;">\n  </div>\n</div>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">var htmlInput = document.querySelector(".html-input");\nvar cssInput = document.querySelector(".css-input");\nvar reset = document.getElementById("reset");\nvar htmlCode = htmlInput.value;\nvar cssCode = cssInput.value;\nvar output = document.querySelector(".output");\nvar solution = document.getElementById("solution");\n\nvar styleElem = document.createElement("style");\nvar headElem = document.querySelector("head");\nheadElem.appendChild(styleElem);\n\nfunction drawOutput() {\n  output.innerHTML = htmlInput.value;\n  styleElem.textContent = cssInput.value;\n}\n\nreset.addEventListener("click", function () {\n  htmlInput.value = htmlCode;\n  cssInput.value = cssCode;\n  drawOutput();\n});\n\nsolution.addEventListener("click", function () {\n  htmlInput.value = htmlCode;\n  cssInput.value =\n    "ul {\n  list-style-type: square;\n}\n\nul li, ol li {\n  line-height: 1.5;\n}\n\nol {\n  list-style-type: lower-alpha\n}";\n  drawOutput();\n});\n\nhtmlInput.addEventListener("input", drawOutput);\ncssInput.addEventListener("input", drawOutput);\nwindow.addEventListener("load", drawOutput);\n</pre></div><div class="code-example" id="sect9"><div class="example-header" id="sect10"></div></div></div></section><section aria-labelledby="заключение"><h2 id="заключение"><a>Заключение</a></h2><div class="section-content"><p>В плане стилизации списки сравнительно легко освоить, как только вы освоите несколько связанных базовых принципов и специфичные свойства. В следующей статье мы перейдём к методам стилизации ссылок.</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Стилизация ссылок',
		
		content:
			'<header><h1>Стилизация ссылок</h1></header><div class="section-content">\n<p>При стилизации ссылок, важно понимать как использовать псевдоклассы, чтобы стилизировать состояния ссылок эффективно, и как стилизировать ссылки для использования в общих разнообразных функциях интерфейса: таких как например навигационное меню и вкладки. Мы рассмотрим все эти темы в этой статье.</p>\n</div><section aria-labelledby="давайте_посмотрим_на_некоторые_ссылки"><h2 id="давайте_посмотрим_на_некоторые_ссылки"><a>Давайте посмотрим на некоторые ссылки</a></h2><div class="section-content"><p>Мы рассматривали как реализуются ссылки в вашем HTML в соответствии с лучшими практиками в <a>Создании гиперссылок</a>. В этой статье мы будем опираться на эти знания, показывая вам лучшие практики по оформлению ссылок.</p></div></section><section aria-labelledby="состояния_ссылок"><h3 id="состояния_ссылок"><a>Состояния ссылок</a></h3><div class="section-content"><p>Первое, что нужно понять, это концепция состояний ссылок — разные состояния в которых могут существовать ссылки, которые могут быть стилизованы используя различные <a>псевдоклассы</a>:</p>\n<ul>\n  <li><strong>Link (не посещённая)</strong>: Состояние по умолчанию, в котором находится ссылка, когда она не находится в каком-либо другом состоянии. Она может быть специфически стилизована используя псевдокласс <a><code>:link</code></a>.</li>\n  <li><strong>Visited</strong>: Ссылка, когда она уже была посещена (существует в истории браузера), стилизуется используя псевдокласс <a><code>:visited</code></a>.</li>\n  <li><strong>Hover</strong>: Ссылка, когда на неё наведён курсор мыши, стилизуется используя псевдокласс <a><code>:hover</code></a></li>\n  <li>\n    <strong>Focus</strong>: Ссылка, когда она была сфокусирована (например когда пользователь переместился на неё используя клавишу\n    <kbd>Tab</kbd>\n    или наподобие или программно сфокусирована используя <a class="only-in-en-us" title="Currently only available in English (US)"><code>HTMLElement.focus()</code> <small>(en-US)</small></a>) — стилизуется используя псевдокласс <a><code>:focus</code></a>.\n  </li>\n  <li><strong>Active</strong>: Ссылка, когда она активируется (например при клике по ней), стилизуется используя псевдокласс <a><code>:active</code></a></li>\n</ul></div></section><section aria-labelledby="стили_по_умолчанию"><h3 id="стили_по_умолчанию"><a>Стили по умолчанию</a></h3><div class="section-content"><p>Следующий пример показывает, как будет вести себя ссылка по умолчанию (CSS просто увеличивает и центрирует текст чтоб больше выделить его).</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><p><a href="https://mozilla.org">A link to the Mozilla homepage</a></p>\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">p {\n  font-size: 2rem;\n  text-align: center;\n}\n</pre></div><div class="code-example" id="sect1"><div class="example-header" id="sect2"></div></div>\n<p>Вы заметите несколько вещей при изучении стилей по умолчанию:</p>\n<ul>\n  <li>Ссылки подчёркнуты.</li>\n  <li>Не посещённые ссылки синие.</li>\n  <li>Посещённые ссылки фиолетовые</li>\n  <li>Наведение курсора мыши на ссылку меняют указатель мыши на иконку маленькой руки.</li>\n  <li>\n    Сфокусированные ссылки имеют контур вокруг себя — вы можете сфокусироваться на ссылках на этой странице с помощью клавиатуры, нажав клавишу табуляции (на Mac, вам может понадобиться включить опцию <em>Full Keyboard Access: All controls</em> нажав\n    <kbd>Ctrl</kbd>\n    +\n    <kbd>F7</kbd>\n    , прежде чем это будет работать).\n  </li>\n  <li>Активные ссылки красные (попробуйте удерживать кнопку мыши на ссылке, когда вы кликните по ней).</li>\n</ul>\n<p>Довольно интересно, что эти стили по умолчанию приблизительно такие же какими они были в первые дни браузеров в середине 1990-ых. Это потому, что пользователи знают и привыкли ожидать такого поведения — если бы ссылки были стилизованы по-разному, это бы путало много людей. Это не значит, что вы не должны стилизовать ссылки совсем, просто вы не должны уходить слишком далеко от ожидаемого поведения. По крайней мере вы должны:</p>\n<ul>\n  <li>Использовать нижнее подчёркивание для ссылок, но не для других вещей. Если вы не хотите подчёркивать ссылки, то хотя бы выделите их каким-либо другим путём.</li>\n  <li>Сделать так чтобы они как-нибудь реагировали на наведение/фокусировку на них и немного отличались после активации.</li>\n</ul>\n<p>Стили по умолчанию могут быть выключены/изменены, используя следующие свойства CSS:</p>\n<ul>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)"><code>color</code> <small>(en-US)</small></a> для цвета текста.</li>\n  <li><a><code>cursor</code></a> для стиля курсора мыши — вы не должны отключать эту опцию только если у вас нет на это веской причины.</li>\n  <li><a><code>outline</code></a> для контура текста (контур схож с границей, единственное отличие — это то, что границы занимают место в блоке, а контур — нет; он просто располагается поверх фона). Контур является полезным вспомогательным средством, так что подумайте хорошо, прежде чем отключать его; по крайней мере вы должны удвоить стили, заданные для состояния hover, а также состояния фокусировки.</li>\n</ul>\n<div class="notecard note" id="sect3">\n  <p><strong>Примечание:</strong> вы не ограничены только перечисленными выше свойствами чтобы стилизовать ссылки — вы можете использовать любые свойства, которые вам нравятся. Просто постарайтесь не сходить с ума слишком сильно!</p>\n</div></div></section><section aria-labelledby="стилизация_некоторых_ссылок"><h3 id="стилизация_некоторых_ссылок"><a>Стилизация некоторых ссылок</a></h3><div class="section-content"><p>Мы уже рассмотрели состояния по умолчанию в некоторых деталях, давайте взглянем на типичный набор стилей ссылок.</p>\n<p>Чтобы начать, мы выпишем наши пустые наборы правил:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">a {\n}\n\na:link {\n}\n\na:visited {\n}\n\na:focus {\n}\n\na:hover {\n}\n\na:active {\n}\n</pre></div>\n<p>Этот порядок важен так как стили ссылок опираются друг на друга, например стили в первом правиле будут применяться ко всем последующим правилам и когда ссылка будет активирована, она также будет находиться под "наведением" (hover). Если вы введёте их в неправильном порядке, стили не будут работать правильно. Чтобы запомнить этот порядок вы можете попробовать использовать мнемонику типа <strong>L</strong>o<strong>V</strong>e <strong>F</strong>ears <strong>HA</strong>te.</p>\n<p>А теперь давайте добавим ещё немного информации чтобы правильно оформить этот стиль:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">body {\n  width: 300px;\n  margin: 0 auto;\n  font-size: 1.2rem;\n  font-family: sans-serif;\n}\n\np {\n  line-height: 1.4;\n}\n\na {\n  outline: none;\n  text-decoration: none;\n  padding: 2px 1px 0;\n}\n\na:link {\n  color: #265301;\n}\n\na:visited {\n  color: #437a16;\n}\n\na:focus {\n  border-bottom: 1px solid;\n  background: #bae498;\n}\n\na:hover {\n  border-bottom: 1px solid;\n  background: #cdfeaa;\n}\n\na:active {\n  background: #265301;\n  color: #cdfeaa;\n}\n</pre></div>\n<p>Также мы дадим некий пример HTML к которому применяется CSS:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><p>\n  There are several browsers available, such as\n  <a href="https://www.mozilla.org/en-US/firefox/">Mozilla Firefox</a>,\n  <a href="https://www.google.com/chrome/index.html">Google Chrome</a>, and\n  <a href="https://www.microsoft.com/en-us/windows/microsoft-edge">Microsoft Edge</a>.\n</p>\n</pre></div>\n<p>Объединение этих двух даёт нам такой результат:</p><div class="code-example" id="sect4"><div class="example-header" id="sect5"></div></div>\n<p>Итак, что мы сделали тут? Это определённо выглядит иначе чем стилизация по умолчанию, но все ещё даёт достаточно знакомый опыт для пользователей, чтобы знать, что происходит:</p>\n<ul>\n  <li>Первые два правила не так интересны в этом обсуждении.</li>\n  <li>Третье правило использует селектор <code>a</code> чтобы избавиться от подчёркивания текста и контура фокуса по умолчанию (которые всё равно варьируют в зависимости от браузера), а также добавляет малое количество padding к каждой ссылке — все это станет ясно позже.</li>\n  <li>Далее, мы используем селекторы <code>a:link</code> и <code>a:visited</code> чтобы настроить пару цветовых вариаций не посещённых и посещённых ссылок, так чтоб они отличались.</li>\n  <li>Следующие два правила используют <code>a:focus</code> и <code>a:hover</code> настраивают сфокусированные и наведённые (hovered) ссылки таким образом чтобы они имели разные фоновые цвета, плюс нижнее подчёркивание чтобы ссылка выделялась ещё больше. Два пункта на которые надо обратить внимание:\n    <ul>\n      <li>Нижнее подчёркивание создано используя <a><code>border-bottom</code></a>, а не <a class="only-in-en-us" title="Currently only available in English (US)"><code>text-decoration</code> <small>(en-US)</small></a> — некоторые люди предпочитают это потому что первый имеет лучшие варианты стилизации, чем второй, и отрисован немного ниже, так что не срезает нижние элементы слов будучи подчёркнутыми (например хвосты у букв как "р" и "у").</li>\n      <li>Значение <a><code>border-bottom</code></a> установлено на <code>1px solid</code>, без определённого цвета. Это позволяет границам принимать тот же цвет что и элементы текста, что полезно в случае как этом, где текст имеет разные цвета в каждом случае.</li>\n    </ul>\n  </li>\n  <li>Наконец, <code>a:active</code> используется чтобы дать ссылкам инвертированную цветовую схему в то время когда они активированы, чтобы было ясно что происходит что то важное!</li>\n</ul></div></section><section aria-labelledby="активное_изучение_стилизуйте_ссылки_самостоятельно"><h3 id="активное_изучение_стилизуйте_ссылки_самостоятельно"><a>Активное изучение: Стилизуйте ссылки самостоятельно</a></h3><div class="section-content"><p>В этой секции активного изучения, мы бы хотели, чтобы взяли наш набор пустых правил и добавили ваши собственные объявления так чтобы ссылки выглядели действительно круто. Используйте своё воображение, не сковывайтесь. Мы уверены, что вы можете придумать что-то более крутое и все ещё так же функциональное, как и наш пример выше.</p>\n<p>Если вы допустите ошибку, вы всегда можете сделать сброс используя кнопку <em>Reset</em>. Если вы действительно застряли нажмите кнопку <em>Show solution</em> чтобы вставить пример, который мы показали выше.</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><div class="body-wrapper" style="font-family: \'Open Sans Light\',Helvetica,Arial,sans-serif;">\n  <h2>HTML Input</h2>\n  <input id="code" class="html-input" style="width: 90%;height: 10em;padding: 10px;border: 1px solid #0095dd;">&lt;p&gt;There are several browsers available, such as &lt;a href="https://www.mozilla.org/en-US/firefox/"&gt;Mozilla\n Firefox&lt;/a&gt;, &lt;a href="https://www.google.com/chrome/index.html"&gt;Google Chrome&lt;/a&gt;, and\n&lt;a href="https://www.microsoft.com/en-us/windows/microsoft-edge"&gt;Microsoft Edge&lt;/a&gt;.&lt;/p&gt;</input>\n\n  <h2>CSS Input</h2>\n  <input id="code" class="css-input" style="width: 90%;height: 10em;padding: 10px;border: 1px solid #0095dd;">a {\n\n}\n\na:link {\n\n}\n\na:visited {\n\n}\n\na:focus {\n\n}\n\na:hover {\n\n}\n\na:active {\n\n}</input>\n\n  <h2>Output</h2>\n  <div class="output" style="width: 90%;height: 10em;padding: 10px;border: 1px solid #0095dd;"></div>\n  <div class="controls">\n    <input id="reset" type="button" value="Reset" style="margin: 10px 10px 0 0;">\n    <input id="solution" type="button" value="Show solution" style="margin: 10px 0 0 10px;">\n  </div>\n</div>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">var htmlInput = document.querySelector(".html-input");\nvar cssInput = document.querySelector(".css-input");\nvar reset = document.getElementById("reset");\nvar htmlCode = htmlInput.value;\nvar cssCode = cssInput.value;\nvar output = document.querySelector(".output");\nvar solution = document.getElementById("solution");\n\nvar styleElem = document.createElement("style");\nvar headElem = document.querySelector("head");\nheadElem.appendChild(styleElem);\n\nfunction drawOutput() {\n  output.innerHTML = htmlInput.value;\n  styleElem.textContent = cssInput.value;\n}\n\nreset.addEventListener("click", function () {\n  htmlInput.value = htmlCode;\n  cssInput.value = cssCode;\n  drawOutput();\n});\n\nsolution.addEventListener("click", function () {\n  htmlInput.value = htmlCode;\n  cssInput.value =\n    "p {\n  font-size: 1.2rem;\n  font-family: sans-serif;\n  line-height: 1.4;\n}\n\na {\n  outline: none;\n  text-decoration: none;\n  padding: 2px 1px 0;\n}\n\na:link {\n  color: #265301;\n}\n\na:visited {\n  color: #437A16;\n}\n\na:focus {\n  border-bottom: 1px solid;\n  background: #BAE498;\n}\n\na:hover {\n  border-bottom: 1px solid;\n  background: #CDFEAA;\n}\n\na:active {\n  background: #265301;\n  color: #CDFEAA;\n}";\n  drawOutput();\n});\n\nhtmlInput.addEventListener("input", drawOutput);\ncssInput.addEventListener("input", drawOutput);\nwindow.addEventListener("load", drawOutput);\n</pre></div><div class="code-example" id="sect6"><div class="example-header" id="sect7"></div></div></div></section><section aria-labelledby="добавление_иконок_в_ссылки"><h2 id="добавление_иконок_в_ссылки"><a>Добавление иконок в ссылки</a></h2><div class="section-content"><p>Обычной практикой является добавление иконок в ссылки, чтобы предоставить больше индикатора того, на какой контент указывает ссылка. Давайте рассмотрим очень простой пример, который добавляет иконку к внешним ссылкам (ссылки, которые ведут на другие сайты). Такая ссылка обычно выглядит как маленькая стрела торчащая из коробочки — например, мы будем использовать <a class="external" target="_blank">этот отличный образец с сайта icons8.com</a>.</p>\n<p>Давайте взглянем на HTML и CSS которые дадут нам эффект, который мы хотим. Во-первых, немного простого HTML который будет стилизован:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><p>\n  For more information on the weather, visit our\n  <a href="weather.html">weather page</a>, look at\n  <a href="https://en.wikipedia.org/wiki/Weather">weather on Wikipedia</a>, or\n  check out\n  <a href="http://www.extremescience.com/weather.htm">weather on Extreme Science</a>.\n</p>\n</pre></div>\n<p>Далее, CSS:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">body {\n  width: 300px;\n  margin: 0 auto;\n  font-family: sans-serif;\n}\n\np {\n  line-height: 1.4;\n}\n\na {\n  outline: none;\n  text-decoration: none;\n  padding: 2px 1px 0;\n}\n\na:link {\n  color: blue;\n}\n\na:visited {\n  color: purple;\n}\n\na:focus,\na:hover {\n  border-bottom: 1px solid;\n}\n\na:active {\n  color: red;\n}\n\na[href*="http"] {\n  background: url("external-link-52.png") no-repeat 100% 0;\n  background-size: 16px 16px;\n  padding-right: 19px;\n}\n</pre></div><div class="code-example" id="sect8"><div class="example-header" id="sect9"></div></div>\n<p>Итак, что же тут происходит? Мы пропустим большую часть CSS так как это та же информация, которую вы рассматривали ранее. Однако, последнее правило интересное — тут мы вставляем пользовательское фоновое изображение во внешнюю ссылку схожим способом как мы делали <a>пользовательские маркеры для пунктов списка</a> в последней статье — в этот раз, однако, мы используем короткую запись <a><code>background</code></a> вместо индивидуальных свойств. Мы задаём путь к изображению, которое хотим вставить, устанавливаем <code>no-repeat</code> чтобы мы получили только одну копию вставленного и затем устанавливаем позицию на 100% до правого края изображения и 0 пикселей от верхнего края.</p>\n<p>Также мы используем <a><code>background-size</code></a> для того чтобы указать размер в котором бы хотим чтобы было показано фоновое изображение — полезно иметь иконку большего размера и далее менять его размер так, как нужно для адаптивного (отзывчивого) веб-дизайна. Однако это работает только в IE9 и следующих версиях так что, если вам нужна поддержка тех старых браузеров вам просто придётся менять размер изображения и вставлять его как есть.</p>\n<p>Наконец, мы задаём некоторый <a><code>padding-right</code></a> для ссылки чтобы добавить пространство в котором появляется фоновое изображение, таким образом, чтобы мы не накладывали его на текст.</p>\n<p>И последнее слово — как мы выбрали только внешние ссылки? Ну, если вы пишете свои <a>HTML ссылки</a> правильно, то вы должны были использовать только абсолютные URL для внешних ссылок — гораздо эффективнее использовать относительные ссылки для связи с другими частями вашего сайта. Текст "http" таким образом должен появляться только во внешних ссылках и можем выбрать его при помощи <a>селектора атрибутов</a>: <code>a[href*="http"]</code> выбирает элементы <a><code>&lt;a&gt;</code></a>, но только если они имеют атрибут <a><code>href</code></a> со значением содержащим "http" где-то внутри него.</p>\n<p>Ну вот и все — попробуйте посетить секцию активного изучения выше и испытайте этот новый метод!</p>\n<div class="notecard note" id="sect10">\n  <p><strong>Примечание:</strong> Не переживайте если вы ещё не знакомы с <a>фоном</a> и <a class="only-in-en-us" title="Currently only available in English (US)">адаптивным (отзывчивым) веб-дизайном <small>(en-US)<small></small></small></a>; это объяснено в других местах</p>\n</div></div></section><section aria-labelledby="стилизация_ссылок_в_виде_кнопок"><h2 id="стилизация_ссылок_в_виде_кнопок"><a>Стилизация ссылок в виде кнопок</a></h2><div class="section-content"><p>Инструменты, которые вы исследовали в этой статье также могут быть использованы другим способом. Например, такие состояния как hover могут быть использованы для стилизации множества различных элементов, не только ссылок — вы можете захотеть стилизовать состояние hover параграфов, элементов списка или других вещей.</p>\n<p>Дополнительно, ссылки очень часто стилизуют так, чтоб они выглядели и вели себя как кнопки при определённых обстоятельствах — навигационное меню веб-сайтов обычно размечено как список, содержащий ссылки, который легко может быть стилизован так чтоб выглядел как набор кнопок управления или вкладок которые обеспечивают пользователя доступом к другим частям сайта. Давайте изучим как.</p>\n<p>Для начала HTML:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><ul>\n  <li><a href="#">Home</a></li>\n  <li><a href="#">Pizza</a></li>\n  <li><a href="#">Music</a></li>\n  <li><a href="#">Wombats</a></li>\n  <li><a href="#">Finland</a></li>\n</ul>\n</pre></div>\n<p>А теперь наш CSS:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">body,\nhtml {\n  margin: 0;\n  font-family: sans-serif;\n}\n\nul {\n  padding: 0;\n  width: 100%;\n}\n\nli {\n  display: inline;\n}\n\na {\n  outline: none;\n  text-decoration: none;\n  display: inline-block;\n  width: 19.5%;\n  margin-right: 0.625%;\n  text-align: center;\n  line-height: 3;\n  color: black;\n}\n\nli:last-child a {\n  margin-right: 0;\n}\n\na:link,\na:visited,\na:focus {\n  background: yellow;\n}\n\na:hover {\n  background: orange;\n}\n\na:active {\n  background: red;\n  color: white;\n}\n</pre></div>\n<p>Что даёт нам следующий результат:</p><div class="code-example" id="sect11"><div class="example-header" id="sect12"></div></div>\n<p>Давайте объясним, что тут происходит, фокусируясь на самых интересных частях:</p>\n<ul>\n  <li>Наше второе правило удаляет заданный по умолчанию <a><code>padding</code></a> у элемента <a><code>&lt;ul&gt;</code></a> и устанавливает его ширину так, чтобы охватить 100% внешнего контейнера (в этом случае <a><code>&lt;body&gt;</code></a>).</li>\n  <li>Элементы <a><code>&lt;li&gt;</code></a> по умолчанию в норме являются блочными (см. <a>типы блоков CSS</a> чтобы вспомнить), что значит что они будут располагаться на своих собственных строках. В этом случае мы создаём горизонтальный список ссылок, поэтому в третьем правиле задаём свойству <a><code>display</code></a> значение inline, что приводит к тому, что элементы списка располагаются в одной строке друг с другом — теперь они ведут себя как строчные элементы.</li>\n  <li>четвёртое правило — которое стилизует элемент <a><code>&lt;a&gt;</code></a> — самое сложное; давайте пройдёмся по нему шаг за шагом:\n    <ul>\n      <li>как в предыдущем примере, мы начинаем отключать настройки по умолчанию для <a class="only-in-en-us" title="Currently only available in English (US)"><code>text-decoration</code> <small>(en-US)</small></a> и <a><code>outline</code></a> — мы не хотим, чтоб они портили нам вид.</li>\n      <li>Далее мы устанавливаем <a><code>display</code></a> на <code>inline-block</code> — элементы <a><code>&lt;a&gt;</code></a> являются строчными по умолчанию и, поскольку мы не хотим чтобы они вываливались на свои собственные строки как если бы это получалось со значением <code>block</code>, мы хотим иметь возможность менять их размер. <code>inline-block</code> позволяет нам делать это.</li>\n      <li>Теперь только изменение размера! Мы хотим заполнить всю ширину элемента <a><code>&lt;ul&gt;</code></a>, оставить немного margin между каждой кнопкой (не без зазора с правого края) и мы имеем 5 кнопок, которые надо разместить и которые должны иметь одинаковый размер. Для того чтобы это сделать мы задаём <a><code>width</code></a> на 19.5%, а <a><code>margin-right</code></a> на 0.625%. Вы заметите что вся эта эта ширина составляет 100.625%, что может сделать так что последняя кнопка перекроет <code>&lt;ul&gt;</code> и выпадет вниз на следующую строку. Тем не менее, мы возвращаемся к 100%, используя следующее правило, которое выбирает только последний <code>&lt;a&gt;</code> в списке и удаляет его margin. Сделано!</li>\n      <li>Последние три объявления довольно просты и в основном просто для косметических целей. Мы центрируем текст внутри каждой ссылки, задаём <a><code>line-height</code></a> на 3 чтобы кнопки имели некую высоту (что также имеет преимущество в центрировании текста по вертикали) и задаём для текста чёрный цвет.</li>\n    </ul>\n  </li>\n</ul>\n<div class="notecard note" id="sect13">\n  <p><strong>Примечание:</strong> вы могли заметить что элементы списка в HTML все находятся на одной строке друг с другом — так сделано потому, что это сделано потому, что пробелы/разрывы строк между элементами встроенного блока создают пробелы на странице, точно также как пробелы между словами и такие пробелы могли бы нарушить расположение нашего горизонтального меню навигации. Вы можете найти больше информации об этой проблеме (и решения) на <a class="external" target="_blank">Fighting the space between inline block elements</a>.</p>\n</div></div></section><section aria-labelledby="заключение"><h2 id="заключение"><a>Заключение</a></h2><div class="section-content"><p>Мы надеемся эта статья снабдила вас всем что вам надо знать о ссылках — на данный момент! Последняя статья в нашем модуле стилизации текста детализирует как использовать пользовательские шрифты на вашем веб-сайте или как они больше известны веб-шрифты.</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Веб-шрифты',
		
		content:
			'<header><h1>Веб-шрифты</h1></header><div class="section-content">\n<p>В первой статье модуля, мы изучали основные функции CSS доступные для стилизации шрифтов и текста. В этой статье мы продвинемся дальше изучая веб-шрифты в деталях — они позволяют вам загружать пользовательские шрифты вместе с вашей веб-страницей, чтобы обеспечить более разнообразный, индивидуальный стиль текста.</p>\n</div><section aria-labelledby="краткое_повторение_семейств_шрифтов"><h2 id="краткое_повторение_семейств_шрифтов"><a>Краткое повторение семейств шрифтов</a></h2><div class="section-content"><p>Как мы рассматривали в <a>Фундаментальной стилизации текста и шрифта</a>, шрифты применённые к вашему HTML могут контролироваться при помощи свойства <a><code>font-family</code></a>. Оно принимает одно и более имён семейств шрифтов и браузер следует по списку пока не найдёт тот шрифт, который является доступным в системе, под управлением которой он работает:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">p {\n  font-family: Helvetica, "Trebuchet MS", Verdana, sans-serif;\n}\n</pre></div>\n<p>Эта система работает хорошо, но традиционно выбор шрифтов веб-разработчиков была ограниченной. Существует только горсть шрифтов которые вы можете гарантировать, что они являются доступными во всех распространённых системах — так называемые <a>Безопасные веб-шрифты</a>. Вы можете использовать стек шрифта для указания предпочтительных шрифтов, за которыми следует веб-безопасные альтернативы, за которыми следует системный шрифт по умолчанию, но это добавляет дополнительной работы с точки зрения тестирования, чтобы убедиться, что ваш дизайн выглядит хорошо с каждым из шрифтов и т. д.</p></div></section><section aria-labelledby="веб-шрифты"><h2 id="веб-шрифты"><a>Веб-шрифты</a></h2><div class="section-content"><p>Но есть альтернатива, которая работает очень хорошо начиная с 6-ой версии IE. Веб-шрифты — это функция CSS позволяющая вам указывать файлы шрифтов, загружаемые вместе с вашим веб-сайтом по мере доступа к нему, это означает, что любой браузер, поддерживающий веб-шрифты, может иметь в своём распоряжении именно те шрифты, которые вы укажете. Замечательно! Требуемый синтаксис выглядит примерно так:</p>\n<p>Во-первых, у вас есть блок <a><code>@font-face</code></a> в начале CSS, который указывает файл(-ы) шрифтов для загрузки:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">@font-face {\n  font-family: "myFont";\n  src: url("myFont.woff");\n}\n</pre></div>\n<p>Ниже вы можете использовать имя семейства шрифтов, указанное внутри @font-face, чтобы применить свой собственный шрифт ко всему, что вам нравится, как обычно:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">html {\n  font-family: "myFont", "Bitstream Vera Serif", serif;\n}\n</pre></div>\n<p>Синтаксис становится немного сложнее, чем этот; мы вдадимся в подробности ниже.</p>\n<p>Есть две важные вещи, которые нужно иметь в виду о веб-шрифтах:</p>\n<ol>\n  <li>Браузеры поддерживают разные форматы шрифтов, поэтому вам будут нужны несколько форматов шрифтов для приличной кросс-браузерной поддержки. Например, большинство современных браузеров поддерживают WOFF/WOFF2 (Web Open Font Format versions 1 and 2), наиболее эффективный формат, но старые версии IE поддерживают только шрифты EOT (Embedded Open Type) и вам возможно понадобиться включать версию SVG шрифта для поддержки старых версий браузеров iPhone и Android. Ниже мы покажем вам как генерировать требуемый код.</li>\n  <li>В основном шрифты не бесплатны для использования. Вы должны платить за них и/или соблюдать другие условия лицензии такие как указание создателя шрифта в коде (или на вашем сайте). Вы не должны красть шрифты и использовать их без должного указания авторства.</li>\n</ol>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> Веб-шрифты как технология поддерживается в Internet Explorer начиная с 4 версии!</p>\n</div></div></section><section aria-labelledby="активное_изучение_пример_веб-шрифта"><h2 id="активное_изучение_пример_веб-шрифта"><a>Активное изучение: пример веб-шрифта</a></h2><div class="section-content"><p>Имея это в виду, давайте создадим базовый пример веб-шрифта из первых принципов. Сложно продемонстрировать это на встроенном живом примере, поэтому вместо, мы бы хотели, чтобы следовали детальным шагам в секциях ниже, чтобы понять идею процесса</p>\n<p>Вы должны использовать файлы <a class="external" target="_blank">web-font-start.html</a> и <a class="external" target="_blank">web-font-start.css</a> как отправную точку добавляя в них ваш код (см. <a class="external" target="_blank">живой пример</a>). Сейчас сделайте копию этих файлов в новой директории на вашем компьютере. В файле <code>web-font-start.css</code> вы найдёте некоторый минимальный CSS для работы с базовым макетом и вёрсткой примера.</p></div></section><section aria-labelledby="поиск_шрифтов"><h3 id="поиск_шрифтов"><a>Поиск шрифтов</a></h3><div class="section-content"><p>В этом примере мы будем использовать два веб-шрифта, один для заголовков, и другой для основного текста. Для того чтобы начать нам необходимо найти файлы шрифтов, которые содержат эти шрифты. Шрифты созданы шрифтовыми "цехами" и хранятся в разных форматах фалов. Как правило существует три типа сайтов, где вы можете получить шрифты:</p>\n<ul>\n  <li>Бесплатный дистрибьютер шрифтов: это сайт, который предоставляет бесплатные шрифты для скачивания (могут существовать некоторые условия лицензии, например, указание создателя шрифта). Примеры включают <a class="external" target="_blank">Font Squirrel</a>, <a class="external" target="_blank">dafont</a>, и <a class="external" target="_blank">Everything Fonts</a>.</li>\n  <li>Платный дистрибьютер шрифтов: это сайт, который предоставляет шрифты за плату, например <a class="external" target="_blank">fonts.com</a> или <a class="external" target="_blank">myfonts.com</a>. Также вы можете купить шрифты напрямую у производителя шрифтов, например <a class="external" target="_blank">Linotype</a>, <a class="external" target="_blank">Monotype</a>, или <a class="external" target="_blank">Exljbris</a>.</li>\n  <li>Сервис онлайн шрифтов: это сайт, который предоставляет вам шрифты, делая весь процесс проще. Смотрите раздел <a>Использование онлайн-сервиса шрифтов</a> для более подробной информации.</li>\n</ul>\n<p>Давайте найдём какие-нибудь шрифты! Отправляйтесь на <a class="external" target="_blank">Font Squirrel</a> и выберите два шрифта — симпатичный интересный шрифт для заголовков (может быть симпатично выглядящий или шрифт с засечками) и немного менее кричащий и более читабельный шрифт для параграфов. Когда вы найдёте каждый шрифт, нажмите на кнопку загрузки и сохраните файлы в той же директории, где ранее вы сохранили файлы HTML и CSS. Не имеет значения являются ли они TTF (True Type Fonts) или OTF (Open Type Fonts).</p>\n<p>В любом случае распакуйте архив со шрифтом (веб-шрифты обычно распространяются в ZIP файлах, содержащих файл(-ы) шрифта и лицензионную информацию). Вы можете обнаружить несколько файлов шрифтов в упаковке (архиве) — некоторые шрифты распространяются как семейство с различными доступными вариантами, например тонкий, средний, жирный, курсив, тонкий курсив и т.д. В этом примере мы просто хотим, чтобы вы позаботились о едином файле шрифта для каждого варианта.</p>\n<div class="notecard note" id="sect2">\n  <p><strong>Примечание:</strong> В разделе "Find fonts" в колонке справа, вы можете кликать по различным тегам и классификациям чтобы отфильтровать отображаемые варианты для выбора.</p>\n</div></div></section><section aria-labelledby="генерация_требуемого_кода"><h3 id="генерация_требуемого_кода"><a>Генерация требуемого кода</a></h3><div class="section-content"><p>Теперь вам надо будет сгенерировать требуемый код (и форматы шрифтов). Для каждого шрифта проделайте следующие шаги.</p>\n<ol>\n  <li>Убедитесь, что вы выполнили все лицензионные требования если вы собираетесь использовать это в коммерческих и/или веб проектах.</li>\n  <li>Перейдите на Fontsquirrel <a class="external" target="_blank">Webfont Generator</a>.</li>\n  <li>Выгрузите два ваших файла шрифтов используя кнопку <em>Upload Fonts.</em></li>\n  <li>Поставьте галочку отмеченную "Yes, the fonts I\'m uploading are legally eligible for web embedding".</li>\n  <li>Кликните по <em>Download your kit</em>.</li>\n</ol>\n<p>После того как генератор закончит обработку, вы должны получить ZIP файл к загрузке — сохраните его в той же директории что и ваши HTML и CSS.</p></div></section><section aria-labelledby="реализация_кода_в_вашем_демо"><h3 id="реализация_кода_в_вашем_демо"><a>Реализация кода в вашем демо</a></h3><div class="section-content"><p>Теперь распакуйте набор веб-шрифта, который вы только что сгенерировали. Внутри распакованной папки вы увидите три полезных элемента:</p>\n<ul>\n  <li>несколько версий каждого шрифта (например <code>.ttf</code>, <code>.woff</code>, <code>.woff2</code> и т.д.; предоставленные шрифты будут обновляться со временем по мере изменения требований поддержки браузера). Как упомянуто выше, несколько шрифтов нужны для кросс-браузерной поддержки — это метод Fontsquirrel быть уверенными что вы получили всё что вам надо.</li>\n  <li>Демо файл HTML для каждого шрифта — загрузите их в ваш браузер чтобы посмотреть, как будет выглядеть шрифт в разных контекстах использования.</li>\n  <li>Файл <code>stylesheet.css</code>, который содержит сгенерированный @font-face код который вам нужен.</li>\n</ul>\n<p>Для внедрения их в ваше демо следуйте следующим шагам:</p>\n<ol>\n  <li>Переименуйте распакованную папку на что-нибудь лёгкое и простое, например <code>fonts</code>.</li>\n  <li>Откройте файл <code>stylesheet.css</code> и скопируйте содержимое обоих <code>@font-face</code> блоков в ваш файл <code>web-font-start.css</code> — вам надо вставить их в самый верх, до любого вашего CSS, так как шрифты должны быть импортированы до того, как вы сможете использовать их на вашем сайте.</li>\n  <li>Каждый из функций <code>url()</code> указывает на файл шрифта который мы хотим импортировать в наш CSS — мы должны убедиться в том, что пути к файлам верные, поэтому добавьте <code>fonts/</code> в начало каждого пути (настройте так как необходимо).</li>\n  <li>Теперь вы можете использовать эти шрифты в ваших стеках шрифтов, как и любой веб-безопасный или по умолчанию системный шрифт. Например:</li>\n</ol>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">font-family: "zantrokeregular", serif;\n</pre></div>\n<p>Вы должны получить демо-страницу с какими-то реализованными симпатичными шрифтами. Поскольку различные шрифты создаются в разных размерах, вам может понадобиться настроить размер, интервалы и т.д., чтобы отладить внешний вид.</p>\n<p>\n  \n</p>\n<div class="notecard note" id="sect3">\n  <p><strong>Примечание:</strong> Если у вас возникли какие-либо проблемы с тем что что-то не работает, смело сравнивайте файлы вашей версии с нашей законченной — см. <a class="external" target="_blank">web-font-finished.html</a> и <a class="external" target="_blank">web-font-finished.css</a> (<a class="external" target="_blank">run the finished example live</a>).</p>\n</div></div></section><section aria-labelledby="использование_онлайн-сервиса_шрифтов"><h2 id="использование_онлайн-сервиса_шрифтов"><a>Использование онлайн-сервиса шрифтов</a></h2><div class="section-content"><p>Онлайн-сервисы шрифтов обычно хранят и обслуживают шрифты для вас, поэтому вам не надо переживать о написании <code>@font-face</code> кода и обычно необходимо просто вставить строчку или две простого кода в ваш сайт для того чтобы все работало. Примеры включают <a class="external" target="_blank">Adobe Fonts</a> и <a class="external" target="_blank">Cloud.typography</a>. Большинство из этих услуг на основе подписки, за исключением <a class="external" target="_blank">Google Fonts</a>, полезный бесплатный сервис, особенно для быстрого тестирования работы и написания демо.</p>\n<p>Большинство из этих сервисов легки в использовании, поэтому мы не будем освещать их в деталях. Давайте кратко рассмотрим Google fonts, чтобы вы понимали идею. И снова, используйте копии <code>web-font-start.html</code> и <code>web-font-start.css</code> в качестве отправной точки.</p>\n<ol>\n  <li>Отправляйтесь на <a class="external" target="_blank">Google Fonts</a>.</li>\n  <li>Используйте фильтры с правой стороны чтобы отобразить типы шрифтов, которые вы хотите выбрать и выберите пару шрифтов, которые вам понравятся.</li>\n  <li>Для выбора семейства шрифтов нажмите на кнопку ⊕ рядом с ним.</li>\n  <li>Когда вы выбрали семейства шрифтов, нажмите на панель <em>[Number] Families Selected</em> в низу страницы.</li>\n  <li>На полученном экране, сначала вам надо скопировать строку показанного HTML кода и вставить её в head вашего HTML файла. Вставьте его выше существующего <a><code>&lt;link&gt;</code></a> элемента для того, чтоб шрифт импортировался до того, как вы начнёте пользоваться им в вашем CSS.</li>\n  <li>Далее вам надо скопировать CSS-объявления, перечисленные в вашем CSS, чтобы применить пользовательские шрифты к вашему HTML.</li>\n</ol>\n<div class="notecard note" id="sect4">\n  <p><strong>Примечание:</strong> вы можете найти законченные версии <a class="external" target="_blank">google-font.html</a> и <a class="external" target="_blank">google-font.css</a>, если вам необходимо сверить вашу работу с нашей (<a class="external" target="_blank">см. live</a>).</p>\n</div></div></section><section aria-labelledby="font-face_более_детально"><h2 id="font-face_более_детально"><a>@font-face более детально</a></h2><div class="section-content"><p>Давайте исследуем тот <code>@font-face</code> синтаксис, который fontsquirrel сгенерировал для вас. Это то, как выглядит один из этих блоков:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">@font-face {\n  font-family: "ciclefina";\n  src: url("fonts/cicle_fina-webfont.eot");\n  src:\n    url("fonts/cicle_fina-webfont.eot?#iefix") format("embedded-opentype"),\n    url("fonts/cicle_fina-webfont.woff2") format("woff2"),\n    url("fonts/cicle_fina-webfont.woff") format("woff"),\n    url("fonts/cicle_fina-webfont.ttf") format("truetype"),\n    url("fonts/cicle_fina-webfont.svg#ciclefina") format("svg");\n  font-weight: normal;\n  font-style: normal;\n}\n</pre></div>\n<p>Это называется "пуленепробиваемым @font-face синтаксисом", после публикации Пола Айриша (Paul Irish), с самого начала, когда <code>@font-face</code> начал получать популярность (<a class="external" target="_blank">Bulletproof @font-face Syntax</a>). Давайте пройдёмся по нему, чтобы посмотреть, что он делает:</p>\n<ul>\n  <li><code>font-family</code>: В этой строке указывается имя, которое вы хотите использовать для обозначения шрифта. Вы можете указать его как угодно, если вы используете его последовательно в вашем CSS.</li>\n  <li><code>src</code>: В этой строке указывается путь к файлам шрифтов которые будут импортированы в ваш CSS (<code>url</code> путь) и формат каждого файла шрифта (<code>format</code> часть). Последняя часть в каждом случае опциональна, но полезно объявлять его, потому что это позволяет браузерам быстрее находить шрифт, который они могут использовать. Могут быть перечислены несколько объявлений, разделённых запятыми — браузер будет искать среди них и использовать первый который найдёт и тот который он понимает — поэтому лучше всего ставить новые, лучшие форматы такие как WOFF2 в начало, а старые, не такие хорошие форматы как TTF в конец. Единственное исключение это EOT шрифты — они размещены первыми чтобы исправить пару багов в старых версиях IE который постарается использовать первую вещь, которую найдёт, даже если он не умеет использовать этот шрифт.</li>\n  <li><a><code>font-weight</code></a>/<a><code>font-style</code></a>: В этих строках указывается какую толщину имеет шрифт и является ли он курсивом или нет. Если вы импортируете несколько значений толщины одного и того же шрифта вы можете указать какая у них толщина/стиль и затем использовать разные значения <a><code>font-weight</code></a>/<a><code>font-style</code></a> для выбора между ними, вместо того, чтобы называть всех разных членов семейства шрифтов разными именами. <a class="external" target="_blank">@font-face совет: установите font-weight и font-style так чтобы ваш CSS был простым</a> от Роджера Джонсона (Roger Johansson) покажет, что делать более детально.</li>\n</ul>\n<div class="notecard note" id="sect5">\n  <p><strong>Примечание:</strong> вы также можете указать определённые значения <a class="only-in-en-us" title="Currently only available in English (US)"><code>font-variant</code> <small>(en-US)</small></a> и <a class="only-in-en-us" title="Currently only available in English (US)"><code>font-stretch</code> <small>(en-US)</small></a> для ваших веб-шрифтов. В новых браузерах вы также можете указать значение <a class="only-in-en-us" title="Currently only available in English (US)"><code>unicode-range</code> <small>(en-US)</small></a>, который является конкретным диапазоном символов, которые вы хотите использовать из веб-шрифта — в поддерживающих браузерах, будут загружены только указанные символы, сохраняя от ненужной загрузки. <a class="external" target="_blank">Creating Custom Font Stacks with Unicode-Range</a> от Drew McLellan предоставляет некоторые полезные идеи того как это использовать</p>\n</div></div></section><section aria-labelledby="переменные_шрифты"><h2 id="переменные_шрифты"><a>Переменные шрифты</a></h2><div class="section-content"><p>В браузерах доступна новая технология, называемая переменными шрифтами — это шрифты, которые позволяют включить в единственный файл много разных вариантов дизайнов шрифтов, вместо того чтобы иметь отдельные файлы шрифтов для каждой ширины, толщины или стиля. Они несколько продвинуты для нашего курса для начинающих, но если вы хотите расширить свои знания и посмотреть на них, прочитайте наше <a class="only-in-en-us" title="Currently only available in English (US)">Руководство по переменным шрифтам <small>(en-US)<small></small></small></a>.</p></div></section><section aria-labelledby="испытайте_свои_навыки!"><h2 id="испытайте_свои_навыки!"><a>Испытайте свои навыки!</a></h2><div class="section-content"><p>Вы достигли конца этой статьи и уже испытали некоторые навыки в наших разделах активного изучения, но сможете ли вы вспомнить самую важную информацию продвигаясь дальше? Вы можете найти задание для проверки того что вы усвоили информацию к конце модуля — см. <a>Задание: стилизация школьного сайта</a>.</p></div></section><section aria-labelledby="заключение"><h2 id="заключение"><a>Заключение</a></h2><div class="section-content"><p>Теперь, когда вы ознакомились с нашими статьями об основах стилизации текста, пришло время проверить ваше понимание нашей оценкой модуля «Задание: стилизация школьного сайта».</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Задание- Стилизирование школьного сайта',
		
		content:
			'<header><h1>Задание: Стилизирование школьного сайта</h1></header><div class="section-content">\n<p>В этой оценке мы проверим ваше понимание всех методов стилизации текста, которые мы рассмотрели в этом модуле дав вам задание стилизовать текст домашней страницы общественной школы. Вы можете просто развлечься, выполняя задание.</p>\n</div><section aria-labelledby="отправная_точка"><h2 id="отправная_точка"><a>Отправная точка</a></h2><div class="section-content"><p>Чтобы начать эту оценку, вам необходимо:</p>\n<ul>\n  <li>Перейти и взять файлы <a class="external" target="_blank">HTML</a> и <a class="external" target="_blank">CSS</a> для упражнения, а также предоставленную <a class="external" target="_blank">иконку внешней ссылки</a>.</li>\n  <li>Сделайте их копии на вашем компьютере.</li>\n</ul>\n<p>В качестве альтернативы, вы можете пользоваться сайтами как <a class="external" target="_blank">JSBin</a> или <a class="external" target="_blank">Glitch</a> чтобы выполнить оценку. Вы можете вставить HTML и заполнить CSS в одном из этих онлайн-редакторов и использовать <a class="external" target="_blank">этот URL</a> чтобы указать фоновое изображение. Если же онлайн-редактор, которым вы пользуетесь, не имеет отдельной CSS панели, тогда вводите его в элемент <code>&lt;style&gt;</code> в head документа.</p>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> Если вы застрянете, то попросите помощи — см. секцию <a>Оценка или дальнейшая помощь</a> в конце этой страницы.</p>\n</div></div></section><section aria-labelledby="краткое_описание_проекта"><h2 id="краткое_описание_проекта"><a>Краткое описание проекта</a></h2><div class="section-content"><p>Вам предоставлен некоторый "сырой" HTML для домашней страницы воображаемого общественного колледжа, плюс немного CSS который стилизует страницу в макет с тремя колонками и обеспечивает ещё каким-то другим элементарным стилем. Вы должны писать ваш дополнительный CSS после комментария в низу CSS файла, чтобы убедиться, что вы с лёгкостью заметите части проделанные вами. Не переживайте если некоторые селекторы повторяются; мы отпустим вас с этим случаем.</p>\n<p>Шрифты:</p>\n<ul>\n  <li>Во-первых, загрузите парочку бесплатных для использования шрифтов. Так как это колледж, шрифты должны быть выбраны так чтоб они придавали достаточной серьёзности, формальности и чувства заслуживающего доверия — может подойти шрифт с засечками (serif) для всего основного текста, в сочетании с шрифтами sans-serif или serif для заголовков.</li>\n  <li>Используйте подходящий сервис для генерации пуленепробиваемого <code>@font-face</code> кода для этих двух шрифтов.</li>\n  <li>Примените ваш основной шрифт для всей страницы и шрифт заголовка для заголовков.</li>\n</ul>\n<p>Общая стилизация текста:</p>\n<ul>\n  <li>Дайте всей странице <code>font-size</code> <code>10px</code>.</li>\n  <li>Дайте вашему заголовку и другим типам элементов подходящие размеры шрифта задаваемые используя соответствующие относительные единицы.</li>\n  <li>Дайте основному тексту подходящую <code>line-height</code>.</li>\n  <li>Отцентрируйте ваш заголовок верхнего уровня на странице.</li>\n  <li>Дайте вашим заголовкам немного <code>letter-spacing</code> чтобы они не были слишком сжатыми, позвольте буквам немного дышать.</li>\n  <li>Дайте основному тексту немного <code>letter-spacing</code> и <code>word-spacing</code>, при необходимости.</li>\n  <li>Дайте первым параграфам после каждого заголовка в <code>&lt;section&gt;</code> немного отступа, скажем 20px.</li>\n</ul>\n<p>Ссылки:</p>\n<ul>\n  <li>Дайте состояниям link, visited, focus, и hover какой-нибудь цвет, который будет сочетается с цветом горизонтальных линий на верху и в низу страницы.</li>\n  <li>Сделайте так чтобы ссылки были подчёркнутыми по умолчанию, но, чтобы подчёркивание исчезало, когда вы фокусируетесь или наводите мышь на них.</li>\n  <li>Удалите установленный по умолчанию контурный фокус со ВСЕХ ссылок на странице.</li>\n  <li>Дайте состоянию active заметно отличимый стиль так чтоб он красиво выделялся, но чтоб он все ещё вписывался в общий дизайн страницы.</li>\n  <li>Сделайте так чтоб внешние ссылки имели иконку внешней ссылки, вставленную рядом с ними.</li>\n</ul>\n<p>Списки:</p>\n<ul>\n  <li>Убедитесь, что интервалы ваших списков и пунктов списка совпадают со стилизацией всей страницы. Все элементы списка должны иметь ту же <code>line-height</code> что и строки параграфов, и каждый список должен иметь те же интервалы сверху и снизу которые имеются между параграфами.</li>\n  <li>Дайте элементам списка симпатичные маркеры, соответствующие дизайну страницы. Выберете ли вы пользовательские изображения для маркеров или что-то другое — зависит от вас.</li>\n</ul>\n<p>Меню навигации:</p>\n<ul>\n  <li>Стилизуйте ваше меню навигации так чтоб оно соответствовало внешнему виду страницы.</li>\n</ul></div></section><section aria-labelledby="советы_и_подсказки"><h2 id="советы_и_подсказки"><a>Советы и подсказки</a></h2><div class="section-content"><ul>\n  <li>Вам не надо как-либо редактировать HTML в этом упражнении.</li>\n  <li>Вам не надо обязательно делать меню навигации в виде кнопок, но надо чтоб они были более-менее высокими, чтобы они не выглядели глупо на краю страницы; также помните, что вам надо сделать его вертикальным меню навигации.</li>\n</ul></div></section><section aria-labelledby="пример"><h2 id="пример"><a>Пример</a></h2><div class="section-content"><p>Следующий скриншот показывает пример того, как может выглядеть законченный дизайн.</p>\n<p>\n  \n</p></div></section><section aria-labelledby="оценка_или_дальнейшая_помощь"><h2 id="оценка_или_дальнейшая_помощь"><a>Оценка или дальнейшая помощь</a></h2><div class="section-content"><p>Если вы хотите, чтобы вашу работу оценили, или вы застряли и хотите попросить помощи:</p>\n<ol>\n  <li>Разместите свою работу в онлайн редакторе в которым можно поделиться работами в таком как <a class="external" target="_blank">CodePen</a>, <a class="external" target="_blank">jsFiddle</a>, или <a class="external" target="_blank">Glitch</a>.</li>\n  <li>Напишите пост с просьбой оценки и/или помощи на <a class="external" target="_blank">MDN Discourse forum Learning category</a>. Ваш пост должен включать:\n    <ul>\n      <li>Описательный заголовок такой как "Требуется оценка вёрстки домашней страницы общественный школы".</li>\n      <li>Детали о том, что вы уже попытались сделать и что бы вы хотели, чтобы мы сделали, например, если вы застряли и вам нужна помощь, либо вы хотите оценку.</li>\n      <li>Ссылку на онлайн редактор (как упомянуто выше в пункте 1) с примером, который нуждается в оценке или с которым нужна помощь. Это хорошая практика чтобы вникнуть — очень сложно помочь кому-либо с проблемным кодом если вы не видите их код.</li>\n      <li>Ссылку на актуальную задачу или страницу оценки, чтобы мы могли найти вопрос, по которому вам нужна помощь.</li>\n    </ul>\n  </li>\n</ol></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'CSS layout',
		
		content:
			'<header><h1>CSS layout</h1></header><div class="section-content"><p>К текущему моменту мы познакомились с основами CSS. Мы знаем, как оформлять текст, как оформлять и изменять блоки, в которых находится ваш контент. Пришло время узнать, как разместить ваши блоки в нужных местах в зависимости от области просмотра и тому подобного. Мы уже знаем достаточно, чтобы погрузиться в изучение разметки с помощью CSS, в то, как изменять отображение в зависимости от особенностей экрана, как использовать современные методы разметки, такие как Flexbox и CSS grid, и некоторые традиционные методы разметки, которые все ещё применяются.</p></div><section aria-labelledby="необходимые_условия"><h2 id="необходимые_условия"><a>Необходимые условия</a></h2><div class="section-content"><p>Перед изучением этого раздела вы должны:</p>\n<ol>\n  <li>Иметь общее представление об HTML, как указано в разделе <a>Вступление в HTML</a>.</li>\n  <li>Ориентироваться в основах CSS, как указано в разделе <a>Вступление в CSS</a>.</li>\n  <li>Понимать, как <a>стилизовать блочные элементы</a>.</li>\n</ol>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> Если вы работаете на компьютере/планшете/других устройствах, где нет возможности создать ваш собственный файл, вы можете попробовать (большую часть) примеры кода в онлайн-программах для написания кода <a class="external" target="_blank">JSBin</a> и <a class="external" target="_blank">Thimble</a>.</p>\n</div></div></section><section aria-labelledby="руководство"><h2 id="руководство"><a>Руководство</a></h2><div class="section-content"><p>Эти разделы содержат инструкции по основным инструментам и методам вёрстки, доступным в CSS. На последнем уроке у вас будет возможность оценить понимание пройденного материала посредством вёрстки веб-страницы.</p>\n<dl>\n  <dt id="введение_в_css_вёрстку"><a>Введение в CSS вёрстку</a></dt>\n  <dd>\n    <p>В этом разделе будут описаны некоторые возможности CSS вёрстки, которых мы уже касались в предыдущих модулях - различные значения <a><code>display</code></a> — и представлены некоторые концепции, которые мы рассмотрим в этом модуле.</p>\n  </dd>\n  <dt id="нормальный_поток"><a>Нормальный поток</a></dt>\n  <dd>\n    <p>Элементы на веб-страницах размещаются в соответствии с нормальным потоком - пока мы не сделаем что-либо, чтобы это изменить. Этот раздел объясняет основы нормального потока как фундамент для изучения влияния на него.</p>\n  </dd>\n  <dt id="flexbox"><a>Flexbox</a></dt>\n  <dd>\n    <p><a class="only-in-en-us" title="Currently only available in English (US)">Flexbox <small>(en-US)<small></small></small></a> - это метод одномерной вёрстки для размещения элементов в строках или столбцах. Элементы растягиваются, чтобы заполнить дополнительное пространство и сжимаются, чтобы поместиться в меньшее пространство. Данный раздел объясняет фундаментальные принципы.</p>\n  </dd>\n  <dt id="grids"><a>Grids</a></dt>\n  <dd>\n    <p>CSS Grid Layout - это двумерная система вёрстки для веб. Она позволяет вам размещать контент в строках и столбцах и имеет множество возможностей, которые упрощают построение сложных макетов. Этот раздел даст вам все, что нужно знать для начала работы с макетом страницы.</p>\n  </dd>\n  <dt id="floats"><a>Floats</a></dt>\n  <dd>\n    <p>Изначально созданное для плавающих изображений внутри текстовых блоков, свойство <a><code>float</code></a> стало одним из наиболее часто используемых инструментов для создания мульти-колоночной вёрстки веб-страниц. С появлением Flexbox и Grid оно вернулось к первоначальному предназначению, как объясняется в этом разделе.</p>\n  </dd>\n  <dt id="позиционирование"><a>Позиционирование</a></dt>\n  <dd>\n    <p>Позиционирование позволяет вам брать элементы из нормального потока и изменять их поведение, например, заставляет находиться друг под другом или всегда оставаться в одном и том же месте внутри окна просмотра браузера. В этом разделе объясняются различные значения <a><code>position</code></a> и способы их применения.</p>\n  </dd>\n  <dt id="мульти-колоночная_вёрстка"><a>Мульти-колоночная вёрстка</a></dt>\n  <dd>\n    <p>Спецификация мульти-колоночной вёрстки даёт вам способ размещения содержимого в столбцах по аналогии с вёрсткой газет. Этот раздел объясняет, как использовать эту возможность.</p>\n  </dd>\n  <dt id="отзывчивый_дизайн"><a>Отзывчивый дизайн</a></dt>\n  <dd>\n    <p>По мере того, как появлялись устройства для выхода в интернет с экранами разных размеров, возникла концепция отзывчивого веб-дизайна (RWD): набор методов, позволяющих веб-страницам изменять свой макет и внешний вид в соответствии с шириной экрана, разрешением и т.д. Это изменило подход к разработке веб-страниц для различных устройств, и в этом руководстве вы познакомитесь с основными приёмами, которые необходимо знать для создания отзывчивого дизайна.</p>\n  </dd>\n  <dt id="введение_в_медиавыражения"><a class="only-in-en-us" title="Currently only available in English (US)">Введение в медиавыражения <small>(en-US)<small></small></small></a></dt>\n  <dd>\n    <p><strong>CSS Media Query</strong> позволяют писать CSS под разные условия, например "область просмотра шире 480 пикселей". Медиавыражения являются ключевой частью отзывчивого веб-дизайна, поскольку они позволяют создавать различные макеты в зависимости от размера области просмотра. Они также могут использоваться для определения других особенностей среды, в которой работает ваш сайт, например, использует ли пользователь сенсорный экран, а не мышь. В этом руководстве вы сперва познакомитесь с синтаксисом медиавыражений, а после разберёте их использование на интерактивном примере, показывающем, как простой дизайн можно сделать отзывчивым.</p>\n  </dd>\n  <dt id="устаревшие_методы_вёрстки"><a class="only-in-en-us" title="Currently only available in English (US)">Устаревшие методы вёрстки <small>(en-US)<small></small></small></a></dt>\n  <dd>\n    <p>Grid-системы - это очень распространённая возможность, используемая в CSS layouts, и до CSS Grid Layout они, как правило, реализовывались с помощью floats или других возможностей вёрстки. Вы представляете свою вёрстку в виде заданного числа столбцов (например, 4 или 6), а затем вы помещаете содержимое в эти воображаемые столбцы. В этом разделе мы рассмотрим, как работают эти старые методы, чтобы вы понимали, как они использовались, если столкнётесь со старыми проектами.</p>\n  </dd>\n  <dt id="поддержка_старыми_браузерами"><a class="only-in-en-us" title="Currently only available in English (US)">Поддержка старыми браузерами <small>(en-US)<small></small></small></a></dt>\n  <dd>\n    <p>В этом модуле мы рекомендуем использовать Flexbox и Grid как основные методы вёрстки для ваших проектов. Однако, ваш сайт могут посещать со старых браузеров или браузеров, которые не поддерживают данные методы. В сети это будет всегда - по мере появления новых возможностей, для различных браузеров будут приоритетны различные вещи. Этот раздел объясняет, как использовать современные веб-технологии без блокировки пользователей со старыми технологиями.</p>\n  </dd>\n  <dt id="фундаментальное_понятие_вёрстки"><a>Фундаментальное понятие вёрстки</a></dt>\n  <dd>\n    <p>Оценка ваших знаний различных методов вёрстки посредством вёрстки веб-страницы.</p>\n  </dd>\n</dl></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Введение в CSS вёрстку',
		
		content:
			'<header><h1>Введение в CSS вёрстку</h1></header><div class="section-content">\n<p>В этой статье мы рассмотрим некоторые функции макета CSS, которые мы затрагивали в предыдущих статьях, например различные значения свойства <a><code>display</code></a>, и разберём некоторые концепции, которые будут рассмотрены в этой статье.</p>\n\n<p>Методы компоновки страниц CSS позволяют нам использовать элементы, расположенные на веб-странице, и контролировать где они находятся относительно их позиции по умолчанию, других элементов вокруг них, их родителей или главного окна. Методы компоновки страниц, которые мы подробно рассмотрим в этой статье.</p>\n<ul>\n  <li>Нормальный поток</li>\n  <li>Свойство <a><code>display</code></a></li>\n  <li>Flexbox</li>\n  <li>Grid</li>\n  <li>Floats</li>\n  <li>Позиционирование</li>\n  <li>Макет таблицы</li>\n  <li>Многоколоночный макет</li>\n</ul>\n<p>Каждый метод имеет свои преимущества и недостатки и ни одна техника не предназначена для использования в изоляции от других. Разбирая данные методы, вы поймёте, какой из них лучший инструмент разметки для каждой задачи.</p></div><section aria-labelledby="normal_flow"><h2 id="normal_flow"><a>Normal flow</a></h2><div class="section-content"><p>Нормальный поток (Normal flow) это то как ваш браузер отображает по умолчанию, когда вы не меняли расположение элементов на странице. Взглянем на пример:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><p>I love my cat.</p>\n\n<ul>\n  <li>Buy cat food</li>\n  <li>Exercise</li>\n  <li>Cheer up friend</li>\n</ul>\n\n<p>The end!</p>\n</pre></div>\n<p>По умолчанию ваш браузер выведет этот код следующим образом:</p><div class="code-example" id="sect1"><div class="example-header" id="sect2"></div></div>\n<p>Заметьте, что HTML-элементы здесь отображаются точно в таком порядке, как и в исходном коде — первый параграф, за ним неупорядоченный список, затем второй параграф.</p>\n<p>Элементы, выводящиеся один <em>под</em> другим, называются <em>блочными</em>, в противоположность <em>строчным</em>, которые выводятся один <em>вслед</em> за другим, как отдельные слова в обычном абзаце текста.</p>\n<div class="notecard note" id="sect3">\n  <p><strong>Примечание:</strong> Направление, в котором отображается содержимое блока, называется Block Direction. Block Direction вертикально в языках типа Английского, имеющих горизонтальное направление письма. В языках, типа Японского, имеющих вертикальное направление письма, Block Direction горизонтально. Соответствующее Inline Direction отвечает за направление отображения строковых элементов (таких как предложение).</p>\n</div>\n<p>Когда вы используете CSS для создания разметки, вы двигаете элементы относительно их обычного расположения, но для многих элементов на вашей странице их обычное положение - это именно то, что вам подойдёт. Именно поэтому важно начинать вёрстку с создания правильно организованного HTML документа, для того, чтобы базовое расположение элементов впоследствии работало на вас.</p>\n<p>Методы CSS, которыми вы можете управлять разметкой элементов:</p>\n<ul>\n  <li><strong>Свойство <a><code>display</code></a></strong> — Стандартные значения <code>block</code>, <code>inline</code> или <code>inline-block</code> могут изменять поведение элементов в обычном потоке (см.подробнее <a>Types of CSS boxes</a>). Также можно менять сами методы разметки такими значениями свойства <code>display</code>, как <a>CSS Grid</a> или <a>Flexbox</a>.</li>\n  <li><strong>Floats</strong> — Применение значения <a><code>float</code></a> типа <code>left</code> может заставить элемент блочного типа "прилепить" содержимое к одной стороне элемента, как иногда изображения обволакиваются текстом на газетных страницах.</li>\n  <li><strong>Свойство <a><code>position</code></a></strong> — Позволяет точно контролировать положение блоков внутри других блоков. <code>static</code> позиционирование является стандартным, но также можно применять другие значения свойства, например фиксированное в углу экрана.</li>\n  <li><strong>Макет Таблицы</strong> — свойства для разметки таблиц могут быть использованы и для нетабличных элементов, с помощью <code>display: table</code> и соответствующих свойств.</li>\n  <li><strong>Multi-column layout</strong> — <a class="only-in-en-us" title="Currently only available in English (US)">Многоколоночный макет <small>(en-US)<small></small></small></a> поможет расположить содержимое столбцами, как в газетах.</li>\n</ul></div></section><section aria-labelledby="свойство_display"><h2 id="свойство_display"><a>Свойство display</a></h2><div class="section-content"><p>Значения свойства <code>display</code> являются главными методами вёрстки разметки страницы в CSS. Это свойство позволяет нам менять то, как что-то отображается по умолчанию. Каждый элемент по умолчанию имеет свойство <code>display</code>, влияющее на то, как этот элемент отображается. Например, параграфы на английском располагаются один под другим только потому что они имеют по умолчанию свойство <code>display: block</code>. Если же вы создадите ссылку внутри параграфа, эта ссылка будет отображаться в общем потоке с остальным текстом, без переноса на новую строку. Это потому что у элемента <a><code>&lt;a&gt;</code></a> по умолчанию установлено свойство <code>display: inline</code>.</p>\n<p>Вы можете изменить дефолтное поведение display. К примеру, <a><code>&lt;li&gt;</code></a> отображается как <code>display: block</code> по умолчанию, это означает что элементы списка отображаются один за другим в нашем документе.Если мы изменим значение display на <code>inline</code> они будут отображаться друг за другом, как это делают слова в предложении. Тот факт, что вы можете изменить значение display для любого элемента означает, что вы можете выбирать HTML-элементы по их семантическому значению, не беспокоясь о том как они будут выглядеть. То как они выглядят это то, что вы можете поменять.</p>\n<p>В дополнение к возможности менять значение с <code>block</code> на <code>inline</code> и обратно, есть и другие возможности вёрстки с другими значениями <code>display</code>. Однако, в основном все они требуют использования дополнительных свойств. Двумя наиболее важными для задач вёрстки страниц являются <code>display: flex</code> и <code>display: grid</code>.</p></div></section><section aria-labelledby="flexbox"><h2 id="flexbox"><a>Flexbox</a></h2><div class="section-content"><p>Flexbox (сокращение от <a>Flexible Box Layout</a>) это модуль, разработанный для облегчения вёрстки в одном из измерений — как ряд или как колонка. Для использования, установите свойство <code>display: flex</code> для родительского элемента тех элементов, к которым хотите применить этот тип вёрстки; все его прямые потомки станут flex элементами. Рассмотрим это на простом примере.</p>\n<p>Разметка HTML, представленная ниже, состоит из элемента <code>wrapper</code>, включающего в себя три <a><code>&lt;div&gt;</code></a> элемента. По умолчанию все они будут изображаться как блочные, один под другим.</p>\n<p>Но если мы добавим свойство <code>display: flex</code> родительскому элементу, три дочерних сгруппируются в колонки. Всё это потому что они сами становятся элементами <em>flex</em> и наследуют некоторые свойства, установленные контейнеру, в котором они находятся. Они выстраиваются в строку, потому что начальное значение <a><code>flex-direction</code></a> это <code>row</code>. Высота становится равной высоте самого высокого элемента, потому что начальное значение <a><code>align-items</code></a> установлено как <code>stretch</code>. Это значит, элементы вытягиваются по высоте контейнера, который в этом случае сам принимает высоту самого высокого элемента. Все они группируются в начале контейнера, оставляя пустое пространство в конце строки.</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup">* {\n  box-sizing: border-box;\n}\n\n.wrapper &gt; div {\n  border-radius: 5px;\n  background-color: rgb(207, 232, 220);\n  padding: 1em;\n}\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.wrapper {\n  display: flex;\n}\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><div class="wrapper">\n  <div class="box1">One</div>\n  <div class="box2">Two</div>\n  <div class="box3">Three</div>\n</div>\n</pre></div><div class="code-example" id="sect4"><div class="example-header" id="sect5"></div></div>\n<p>В дополнение к свойствам, применяемым к контейнеру, существуют свойства, применяемые ко вложенным элементам. Эти свойства помимо всего прочего, могут менять размеры элемента, растягивая его и заставляя занимать всё доступное место.</p>\n<p>В качестве простого примера, добавим свойство <a><code>flex</code></a> ко всем дочерним элементам, со значением <code>1</code>. Это заставит все элементы растянуться и заполнить контейнер, не оставляя свободного места в конце строки. Если освободится дополнительное пространство, элементы растянутся; если доступное место убавится - элементы сожмутся. Также, если вы добавите дополнительный элемент, остальные элементы станут меньше, для того, чтобы все они были одного размера.</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup">* {\n  box-sizing: border-box;\n}\n\n.wrapper &gt; div {\n  border-radius: 5px;\n  background-color: rgb(207, 232, 220);\n  padding: 1em;\n}\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.wrapper {\n  display: flex;\n}\n\n.wrapper &gt; div {\n  flex: 1;\n}\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><div class="wrapper">\n  <div class="box1">One</div>\n  <div class="box2">Two</div>\n  <div class="box3">Three</div>\n</div>\n</pre></div><div class="code-example" id="sect6"><div class="example-header" id="sect7"></div></div>\n<div class="notecard note" id="sect8">\n  <p><strong>Примечание:</strong> Это было очень краткое введение в то что возможно во Flexbox, чтобы узнать больше см. нашу статью <a>Flexbox</a>.</p>\n</div></div></section><section aria-labelledby="grid_layout"><h2 id="grid_layout"><a>Grid Layout</a></h2><div class="section-content"><p>В то время как flexbox предназначен для одномерной разметки, Grid Layout предназначен для двумерной — выстраивая предметы в ряды и столбцы.</p>\n<p>Ещё раз, вы можете переключиться на Grid Layout при помощи конкретного значения отображения — <code>display: grid</code>. Пример ниже использует разметку подобную примеру flex, а также мы определяем некоторые дорожки рядов и столбцов в родительском элементе, используя свойства <a><code>grid-template-rows</code></a> и <a><code>grid-template-columns</code></a> соответственно. Мы определили три столбца каждый по <code>1fr</code> и два ряда по <code>100px</code>. Мне не надо вводить какие-либо правила для дочерних элементов; они автоматически помещаются в ячейки, созданные нашей сеткой.</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup">* {\n  box-sizing: border-box;\n}\n\n.wrapper &gt; div {\n  border-radius: 5px;\n  background-color: rgb(207, 232, 220);\n  padding: 1em;\n}\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.wrapper {\n  display: grid;\n  grid-template-columns: 1fr 1fr 1fr;\n  grid-template-rows: 100px 100px;\n  grid-gap: 10px;\n}\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><div class="wrapper">\n  <div class="box1">One</div>\n  <div class="box2">Two</div>\n  <div class="box3">Three</div>\n  <div class="box4">Four</div>\n  <div class="box5">Five</div>\n  <div class="box6">Six</div>\n</div>\n</pre></div><div class="code-example" id="sect9"><div class="example-header" id="sect10"></div></div>\n<p>Когда у вас есть сетка (grid), мы можете точно размещать на ней свои элементы, а не полагаться на поведение авто-размещения, отмеченного выше. Ниже во втором примере мы задали ту же сетку, но в этот раз с тремя дочерними элементами. Мы задали начало и конец линии каждого элемента используя свойства <a><code>grid-column</code></a> и <a class="only-in-en-us" title="Currently only available in English (US)"><code>grid-row</code> <small>(en-US)</small></a>. Это заставляет элементы охватывать несколько дорожек.</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup">* {\n  box-sizing: border-box;\n}\n\n.wrapper &gt; div {\n  border-radius: 5px;\n  background-color: rgb(207, 232, 220);\n  padding: 1em;\n}\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.wrapper {\n  display: grid;\n  grid-template-columns: 1fr 1fr 1fr;\n  grid-template-rows: 100px 100px;\n  grid-gap: 10px;\n}\n\n.box1 {\n  grid-column: 2 / 4;\n  grid-row: 1;\n}\n\n.box2 {\n  grid-column: 1;\n  grid-row: 1 / 3;\n}\n\n.box3 {\n  grid-row: 2;\n  grid-column: 3;\n}\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><div class="wrapper">\n  <div class="box1">One</div>\n  <div class="box2">Two</div>\n  <div class="box3">Three</div>\n</div>\n</pre></div><div class="code-example" id="sect11"><div class="example-header" id="sect12"></div></div>\n<div class="notecard note" id="sect13">\n  <p><strong>Примечание:</strong> Эти два примера всего лишь малая часть мощности Grid layout; чтобы узнать больше см. нашу статью <a>Grid Layout</a>.</p>\n</div>\n<p>Остальная часть этого руководства освещает другие методы разметок, которые менее важны для основной структуры разметки вашей страницы, но всё равно могут помочь вам в достижении определённых задач. Понимая природу задачи каждой разметки, вы вскоре обнаружите, что, глядя на конкретный компонент вашего дизайна, часто будет ясно какой тип разметки подходит лучше всего.</p></div></section><section aria-labelledby="floats"><h2 id="floats"><a>Floats</a></h2><div class="section-content"><p>Делая элемент плавающим (float) мы меняем поведение этого элемента и элементов блочного уровня, следующих за ним в нормальном потоке. Элемент перемещается влево или вправо и удаляется из нормального потока (normal flow), а окружающий контент обтекает плавающий элемент.</p>\n<p>Свойство <a><code>float</code></a> имеет четыре возможных значения:</p>\n<ul>\n  <li><code>left</code> — Элемент выравнивается слева и другие элементы обтекают его справа.</li>\n  <li><code>right</code> — Элемент выравнивается справа и другие элементы обтекают его слева.</li>\n  <li><code>none</code> — Не задаёт float совсем. Это значение по умолчанию.</li>\n  <li><code>inherit</code> — Определяет, что значение свойства <code>float</code> должно быть унаследовано от родительского элемента.</li>\n</ul>\n<p>В примере ниже мы задаём элементу <code>&lt;div&gt;</code> float - left и даём <a><code>margin</code></a> с правой стороны чтобы отталкивать текст от этого элемента. Это даёт нам эффект того, что текст оборачивает этот блок и является большей частью того, что вам нужно знать о float, используемых в современном веб-дизайне.</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 90%;\n  max-width: 900px;\n  margin: 0 auto;\n}\n\np {\n  line-height: 2;\n  word-spacing: 0.1rem;\n}\n\n.box {\n  background-color: rgb(207, 232, 220);\n  border: 2px solid rgb(79, 185, 227);\n  padding: 10px;\n  border-radius: 5px;\n}\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><h1>Simple float example</h1>\n\n<div class="box">Float</div>\n\n<p>\n  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam\n  dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus\n  ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus\n  laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum,\n  tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus\n  neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat\n  volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros\n  pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec\n  lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.\n</p>\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.box {\n  float: left;\n  width: 150px;\n  height: 150px;\n  margin-right: 30px;\n}\n</pre></div><div class="code-example" id="sect14"><div class="example-header" id="sect15"></div></div>\n<div class="notecard note" id="sect16">\n  <p><strong>Примечание:</strong> Float полностью объяснён в нашем уроке по свойствам <a>float и clear</a>. До таких методов как Flexbox и Grid Layout, float использовался как метод создания макетов колонок. Вы все ещё можете встретить эти методы в интернете; мы рассмотрим их в уроке по <a class="only-in-en-us" title="Currently only available in English (US)">устаревшим методам разметки <small>(en-US)<small></small></small></a>.</p>\n</div></div></section><section aria-labelledby="методы_позиционирования"><h2 id="методы_позиционирования"><a>Методы позиционирования</a></h2><div class="section-content"><p>Позиционирование позволяет вам перемещать элементы с места, где бы они располагались при нормальном потоке в другую локацию. Позиционирование не является методом создания основной разметки страницы, это больше об управлении и точной настройке положения определённых элементов на странице.</p>\n<p>Однако, существуют полезные методы точной разметки шаблонов, которые полагаются на свойство <a><code>position</code></a>. Понимание позиционирования также способствует пониманию нормального потока и того, что значит вывести элемент из нормального потока.</p>\n<p>Существует пять типов позиционирования о которых вам следует знать:</p>\n<ul>\n  <li><strong>Static positioning (статическое позиционирование)</strong> — умолчание, которое получают все элементы — это всё лишь значит "поместить элемент в его нормальную позицию в разметке документа — тут нет ничего особенного на что посмотреть".</li>\n  <li><strong>Relative positioning (относительное позиционирование)</strong> позволяет вам менять положение элемента на странице, перемещая его относительно его положения в нормальном потоке — в том числе заставляя его перекрывать другие элементы на странице.</li>\n  <li><strong>Absolute positioning (абсолютное позиционирование)</strong> полностью перемещает элемент из нормального потока разметки страницы так будто он находится на своём собственном отдельном слое. Оттуда вы можете исправлять его положение относительно краёв <code>&lt;html&gt;</code> элемента страницы (или его ближайшего позиционированного элемента предка). Это является полезным при создании сложных эффектов разметки такие как вкладки, в которых различные панели содержимого располагаются друг над другом и отображаются и/или скрываются по желанию или информационные панели, которые располагаются на экране по умолчанию, но могут скользить по экрану используя кнопки управления.</li>\n  <li><strong>Fixed positioning (фиксированное позиционирование)</strong> очень похоже на абсолютное за исключением того, что он изменяет положение относительно окна просмотра браузера, а не другого элемента. Это полезно при создании эффектов таких как постоянное меню навигации, которое всегда остаётся в одном и том же месте на экране, в то время как другой контент прокручивается.</li>\n  <li><strong>Sticky positioning (липкое позиционирование)</strong> это новый метод позиционирования, который заставляет элемент вести себя как <code>position: static</code> пока не достигнет определённой линии окна просмотра и с этого момента будет вести себя как <code>position: fixed</code>.</li>\n</ul></div></section><section aria-labelledby="пример_простого_позиционирования"><h3 id="пример_простого_позиционирования"><a>Пример простого позиционирования</a></h3><div class="section-content"><p>Для ознакомления с этими методами вёрстки, мы покажем вам пару быстрых примеров. Наши примеры будут иметь одинаковый HTML, который выглядит следующим образом:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><h1>Positioning</h1>\n\n<p>I am a basic block level element.</p>\n<p class="positioned">I am a basic block level element.</p>\n<p>I am a basic block level element.</p>\n</pre></div>\n<p>Этот HTML по умолчанию будет стилизован, используя следующий CSS:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">body {\n  width: 500px;\n  margin: 0 auto;\n}\n\np {\n  background-color: rgb(207, 232, 220);\n  border: 2px solid rgb(79, 185, 227);\n  padding: 10px;\n  margin: 10px;\n  border-radius: 5px;\n}\n</pre></div>\n<p>Результат выглядит следующим образом:</p><div class="code-example" id="sect17"><div class="example-header" id="sect18"></div></div></div></section><section aria-labelledby="relative_positioning"><h3 id="relative_positioning"><a>Relative positioning</a></h3><div class="section-content"><p>Относительное (Relative) позиционирование позволяет вам смещать элемент относительно положения, которое он бы имел по умолчанию в нормальном потоке. Это значит, что вы можете выполнить такую задачу как перемещение иконки немного вниз, так чтобы он был на одной линии с текстовой меткой. Чтобы сделать это, мы можем добавить следующее правило для добавления относительного позиционирования.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.positioned {\n  position: relative;\n  top: 30px;\n  left: 30px;\n}\n</pre></div>\n<p>Здесь мы даём нашему среднему параграфу <a><code>position</code></a> со значением <code>relative</code> — сам по себе он ничего не делает, поэтому мы также добавляем свойства <a><code>top</code></a> и <a class="only-in-en-us" title="Currently only available in English (US)"><code>left</code> <small>(en-US)</small></a>. Они служат для перемещения задействованного элемента вниз и вправо — что может выглядеть как противоположность тому, чего вы ожидаете, но вам надо думать об этом так будто элемент отталкивается от левого или верхнего края, и в результате он перемещается вправо и вниз.</p>\n<p>Добавление этого кода даст следующий результат:</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Relative positioning</h1>\n\n<p>I am a basic block level element.</p>\n<p class="positioned">This is my relatively positioned element.</p>\n<p>I am a basic block level element.</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 500px;\n  margin: 0 auto;\n}\n\np {\n  background-color: rgb(207, 232, 220);\n  border: 2px solid rgb(79, 185, 227);\n  padding: 10px;\n  margin: 10px;\n  border-radius: 5px;\n}\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.positioned {\n  position: relative;\n  background: rgba(255, 84, 104, 0.3);\n  border: 2px solid rgb(255, 84, 104);\n  top: 30px;\n  left: 30px;\n}\n</pre></div><div class="code-example" id="sect19"><div class="example-header" id="sect20"></div></div></div></section><section aria-labelledby="absolute_positioning"><h3 id="absolute_positioning"><a>Absolute positioning</a></h3><div class="section-content"><p>Абсолютное (Absolute) позиционирование используется чтобы полностью удалить элемент из нормального потока и разместить его, используя смещение от краёв содержащего блока.</p>\n<p>Возвращаясь к нашему примеру без позиционирования, мы можем добавить следующее CSS-правило, чтобы реализовать абсолютное позиционирование:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.positioned {\n  position: absolute;\n  top: 30px;\n  left: 30px;\n}\n</pre></div>\n<p>Здесь мы даём нашему среднему параграфу <a><code>position</code></a> со значением <code>absolute</code>, и все те же свойства <a><code>top</code></a> и <a class="only-in-en-us" title="Currently only available in English (US)"><code>left</code> <small>(en-US)</small></a> как ранее. Однако, добавление этого кода даст следующий результат:</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Absolute positioning</h1>\n\n<p>I am a basic block level element.</p>\n<p class="positioned">This is my absolutely positioned element.</p>\n<p>I am a basic block level element.</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 500px;\n  margin: 0 auto;\n}\n\np {\n  background-color: rgb(207, 232, 220);\n  border: 2px solid rgb(79, 185, 227);\n  padding: 10px;\n  margin: 10px;\n  border-radius: 5px;\n}\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.positioned {\n  position: absolute;\n  background: rgba(255, 84, 104, 0.3);\n  border: 2px solid rgb(255, 84, 104);\n  top: 30px;\n  left: 30px;\n}\n</pre></div><div class="code-example" id="sect21"><div class="example-header" id="sect22"></div></div>\n<p>Это совсем другое! Позиционированный элемент теперь совершенно отделен от разметки остальной страницы и располагается поверх него. Другие два параграфа теперь располагаются вместе так будто бы их позиционированный брат не существует. Свойства <a><code>top</code></a> и <a class="only-in-en-us" title="Currently only available in English (US)"><code>left</code> <small>(en-US)</small></a> имеют иной эффект на абсолютно позиционированные элементы, чем на относительно позиционированные элементы. В данном случае смещения были рассчитаны сверху и слева от страницы. Возможно изменить родительский элемент так что он становится контейнером, но мы рассмотрим это в уроке по <a>позиционированию</a>.</p></div></section><section aria-labelledby="fixed_positioning"><h3 id="fixed_positioning"><a>Fixed positioning</a></h3><div class="section-content"><p>Фиксированное (Fixed) позиционирование удаляет наш элемент из потока документа так же, как и абсолютное позиционирование. Однако, вместо смещения применяемого относительно контейнера, оно применяется относительно окна просмотра. Поскольку элемент остаётся зафиксированным относительно окна просмотра, мы можем создавать такие эффекты как меню, которое остаётся зафиксированным пока страница прокручивается под ним.</p>\n<p>Для этого примера наш HTML это три параграфа текста для того, чтобы мы могли прокручивать страницу и блок, которому мы дадим <code>position: fixed</code>.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><h1>Fixed positioning</h1>\n\n<div class="positioned">Fixed</div>\n\n<p>Paragraph 1.</p>\n<p>Paragraph 2.</p>\n<p>Paragraph 3.</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Fixed positioning</h1>\n\n<div class="positioned">Fixed</div>\n\n<p>\n  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam\n  dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus\n  ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus\n  laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum,\n  tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus\n  neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat\n  volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros\n  pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec\n  lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.\n</p>\n\n<p>\n  Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada\n  ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed\n  est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus\n  tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies lectus\n  sed lobortis finibus. Vivamus eu urna eget velit cursus viverra quis\n  vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque\n  penatibus et magnis dis parturient montes, nascetur ridiculus mus.\n</p>\n\n<p>\n  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam\n  dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus\n  ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus\n  laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum,\n  tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus\n  neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat\n  volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros\n  pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec\n  lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.\n</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 500px;\n  margin: 0 auto;\n}\n\n.positioned {\n  background: rgba(255, 84, 104, 0.3);\n  border: 2px solid rgb(255, 84, 104);\n  padding: 10px;\n  margin: 10px;\n  border-radius: 5px;\n}\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.positioned {\n  position: fixed;\n  top: 30px;\n  left: 30px;\n}\n</pre></div><div class="code-example" id="sect23"><div class="example-header" id="sect24"></div></div></div></section><section aria-labelledby="sticky_positioning"><h3 id="sticky_positioning"><a>Sticky positioning</a></h3><div class="section-content"><p>Липкое (Sticky) позиционирование — это последний тип позиционирования которой мы имеем в нашем распоряжении. Это микс дефолтного статического позиционирования с фиксированным позиционированием. когда элемент имеет <code>position: sticky</code> он будет прокручиваться в нормальном потоке пока не достигнет границы окна просмотра которую мы задали. С этого момента он (элемент) "прилипает", как если бы был применён <code>position: fixed</code>.</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Sticky positioning</h1>\n\n<p>\n  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam\n  dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus\n  ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus\n  laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum,\n  tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus\n  neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat\n  volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros\n  pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec\n  lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.\n</p>\n\n<div class="positioned">Sticky</div>\n\n<p>\n  Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada\n  ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed\n  est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus\n  tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies lectus\n  sed lobortis finibus. Vivamus eu urna eget velit cursus viverra quis\n  vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque\n  penatibus et magnis dis parturient montes, nascetur ridiculus mus.\n</p>\n\n<p>\n  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam\n  dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus\n  ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus\n  laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum,\n  tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus\n  neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat\n  volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros\n  pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec\n  lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.\n</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 500px;\n  margin: 0 auto;\n}\n\n.positioned {\n  background: rgba(255, 84, 104, 0.3);\n  border: 2px solid rgb(255, 84, 104);\n  padding: 10px;\n  margin: 10px;\n  border-radius: 5px;\n}\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.positioned {\n  position: sticky;\n  top: 30px;\n  left: 30px;\n}\n</pre></div><div class="code-example" id="sect25"><div class="example-header" id="sect26"></div></div>\n<div class="notecard note" id="sect27">\n  <p><strong>Примечание:</strong> чтобы узнать больше о позиционировании, см. нашу статью <a>Позиционирование.</a></p>\n</div></div></section><section aria-labelledby="макет_таблицы"><h2 id="макет_таблицы"><a>Макет таблицы</a></h2><div class="section-content"><p>HTML таблицы хороши для отображения табличных данных, но много лет назад — до того, как даже базовый CSS надёжно поддерживался в браузерах — веб-разработчики также использовали таблицы для разметки всей веб-страницы — размещая свои заголовки, нижние колонтитулы, различные колонки и т.д. в разных строках и столбцах таблиц. Это работало в то время, но оно имеет много проблем — разметка таблиц не гибкая, очень тяжёлая в вёрстке, сложна в отладке, и семантически не верная. (например, пользователи скринридеров имеют проблемы с навигацией в табличном макете).</p>\n<p>То, как таблица выглядит на веб-странице при использовании разметки таблицы, обусловлено набором свойств CSS, которые определяют макет таблицы. Эти свойства могут использоваться для размещения элементов, которые не являются таблицами, использование, которое иногда описывается как «использование CSS таблиц».</p>\n<p>Пример ниже показывает одно такое использование; использование CSS таблиц для вёрстки должно считаться устаревшим методом на данный момент, для тех ситуаций, когда у вас старые браузеры без поддержки Flexbox или Grid.</p>\n<p>Давайте взглянем на пример. Во-первых, немного простой разметки, которая создаёт HTML форму. Каждый input элемент имеет label, и мы также заключили описание в параграф. каждая пара label/input обёрнута в <a><code>&lt;div&gt;</code></a>, для целей вёрстки.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><form>\n  <p>First of all, tell us your name and age.</p>\n  <div>\n    <label for="fname">First name:</label>\n    <input type="text" id="fname">\n  </div>\n  <div>\n    <label for="lname">Last name:</label>\n    <input type="text" id="lname">\n  </div>\n  <div>\n    <label for="age">Age:</label>\n    <input type="text" id="age">\n  </div>\n</form>\n</pre></div>\n<p>А теперь CSS для нашего примера. Большая часть CSS довольно обычна, за исключением использования свойства <a><code>display</code></a>. <a><code>&lt;form&gt;</code></a>-е, <a><code>&lt;div&gt;</code></a>-ам, а также <a><code>&lt;label&gt;</code></a>-ам и <a><code>&lt;input&gt;</code></a>-ам было сказано отображать как таблица, табличные строки и табличные ячейки соответственно — в принципе, они будут вести себя как разметка HTML таблицы, заставляя label-ы and input-ы красиво выравниваться по умолчанию. Все что мы должны будем сделать это добавить немного размеров, margin и т.д., чтобы все выглядело красивей, и на этом мы закончили.</p>\n<p>Вы заметите, что параграфу с описанием дано <code>display: table-caption;</code> — что заставляет его вести себя как табличный <a><code>&lt;caption&gt;</code></a> — а <code>caption-side: bottom;</code> для того чтобы указать описанию располагаться снизу таблицы в целях дизайна, не смотря на то что разметка находится до <code>&lt;input&gt;</code> элементов в источнике. Это обеспечивает гибкостью.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">html {\n  font-family: sans-serif;\n}\n\nform {\n  display: table;\n  margin: 0 auto;\n}\n\nform div {\n  display: table-row;\n}\n\nform label,\nform input {\n  display: table-cell;\n  margin-bottom: 10px;\n}\n\nform label {\n  width: 200px;\n  padding-right: 5%;\n  text-align: right;\n}\n\nform input {\n  width: 300px;\n}\n\nform p {\n  display: table-caption;\n  caption-side: bottom;\n  width: 300px;\n  color: #999;\n  font-style: italic;\n}\n</pre></div>\n<p>Это даёт нам следующий результат:</p><div class="code-example" id="sect28"><div class="example-header" id="sect29"></div></div>\n<p>Также вы можете посмотреть этот живой пример на <a class="external" target="_blank">css-tables-example.html</a> (смотрите также <a class="external" target="_blank">исходный код</a>.)</p></div></section><section aria-labelledby="многоколоночный_макет"><h2 id="многоколоночный_макет"><a>Многоколоночный макет</a></h2><div class="section-content"><p>Модуль многоколоночного макета (multi-column layout) даёт нам способ располагать контент в столбцах, подобно тому, как текст располагается в газете. Хоть и чтение столбцов вверх и вниз менее полезно в контексте веба, так как вы не хотите заставлять пользователей прокручивать вверх и вниз, размещение контента по столбцам может быть полезной техникой.</p>\n<p>Чтобы превратить блок в многоколоночный контейнер мы используем свойство <a><code>column-count</code></a>, которое говорит браузеру сколько колонок мы хотим иметь, либо свойство <a class="only-in-en-us" title="Currently only available in English (US)"><code>column-width</code> <small>(en-US)</small></a>, которое говорит браузеру заполнить контейнер как можно большим количеством столбцов, по крайней мере, такой ширины.</p>\n<p>В примере ниже мы начинаем с HTML блоком, который содержится в элементе <code>&lt;div&gt;</code> с классом <code>container</code>.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><div class="container">\n  <h1>Multi-column layout</h1>\n\n  <p>Paragraph 1.</p>\n  <p>Paragraph 2.</p>\n</div>\n</pre></div>\n<p>Мы используем <code>column-width</code> 200 px для этого контейнера, заставляя браузер создавать столько 200 пиксельных столбцов, сколько уместится в этом контейнере и затем разделить оставшееся пространство между созданными столбцами.</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><div class="container">\n  <h1>Multi-column Layout</h1>\n\n  <p>\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n    aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,\n    pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at\n    ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer\n    ligula ipsum, tristique sit amet orci vel, viverra egestas ligula. Curabitur\n    vehicula tellus neque, ac ornare ex malesuada et. In vitae convallis lacus.\n    Aliquam erat volutpat. Suspendisse ac imperdiet turpis. Aenean finibus\n    sollicitudin eros pharetra congue. Duis ornare egestas augue ut luctus.\n    Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare felis,\n    eget fermentum sapien.\n  </p>\n\n  <p>\n    Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada\n    ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed\n    est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus\n    tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies\n    lectus sed lobortis finibus. Vivamus eu urna eget velit cursus viverra quis\n    vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque\n    penatibus et magnis dis parturient montes, nascetur ridiculus mus.\n  </p>\n</div>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  max-width: 800px;\n  margin: 0 auto;\n}\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.container {\n  column-width: 200px;\n}\n</pre></div><div class="code-example" id="sect30"><div class="example-header" id="sect31"></div></div></div></section><section aria-labelledby="заключение"><h2 id="заключение"><a>Заключение</a></h2><div class="section-content"><p>Эта статья предоставила короткое обобщение всех методов макетов о которых вам следует знать. Читайте далее для получения дополнительной информации по каждому методу!</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Базовый поток',
		
		content:
			'<header><h1>Базовый поток</h1></header><div class="section-content">\n<p>Эта статья объясняет нормальный/базовый поток (normal flow) или способ, которым элементы страницы располагаются на веб-странице по умолчанию.</p>\n\n<p>Как говорилось ранее, элементы на веб-странице располагаются в нормальном потоке, если вы не применили к ним ни единого CSS для изменения их поведения. И, как мы уже выяснили, вы можете изменить поведение элементов либо путём изменения их положения в этом нормальном потоке, либо удалением этих элементов из этого потока. Хорошо структурированный документ, читабельный в нормальном потоке является лучшим путём начала любой веб-страницы. Это гарантирует, что ваш контент будет читабельным, даже если пользователи используют очень ограниченный браузер или устройство для чтения, которое считывает содержимое страницы. Кроме того, поскольку нормальный поток предназначен для создания читабельного документа, имейте в виду, что вы не сражаетесь с первоначальным видом документа, а работаете с ним.</p>\n<p>Прежде чем углубиться в разные способы компоновки, стоит пересмотреть некоторые из вещей, которые вы изучили в предыдущих модулях в отношении нормального потока документов.</p></div><section aria-labelledby="как_элементы_располагаются_по_умолчанию"><h2 id="как_элементы_располагаются_по_умолчанию"><a>Как элементы располагаются по умолчанию?</a></h2><div class="section-content"><p>Прежде всего, индивидуальные боксы элементов располагаются в зависимости от содержимого элементов, затем добавляя какой-нибудь padding, border и margin вокруг них - это опять-таки боксовая модель, которую мы рассмотрели ранее.</p>\n<p>По умолчанию содержимое элемента уровня блока составляет 100% от ширины его родительского элемента и столь же высок, как и его содержимое. Строчные элементы высоки и широки, как их содержимое. Вы не можете установить ширину или высоту на строчные элементы — они просто находятся внутри содержимого элементов блочного уровня. Если вы хотите контролировать размер строчного элемента вам нужно настроить его так, чтобы он себя вёл как элемент блочного уровня при помощи <code>display: block;</code> (или даже, <code>display: inline-block;</code>, который смешивает характеристики обоих.).</p>\n<p>Это объясняет отдельные элементы, но как насчёт того, как элементы взаимодействуют друг с другом? Нормальный поток макета (упомянутый в статье введения макета) - это система, посредством которой элементы размещаются внутри окна просмотра браузера. По умолчанию элементы уровня блока выкладываются в направлении, что блокирует отображение в режиме записи документа - каждый из них будет отображаться в новой строке ниже последней строки, и они будут разделены любым полем, установленным на них. Поэтому на английском языке или на любом другом, в котором режим писания горизонтальный, сверху вниз, элементы уровня блока располагаются вертикально.</p>\n<p>Строчные элементы ведут себя по-другому — они не появляются на новых строках; они располагаются на той же строке, что и другие и любой смежной или завёрнутый текст располагается на всю ширину внутри элемента уровня родительского блока, до тех пор, пока не закончится пространство. Если пространства нет, тогда текст и/или элементы перейдут на новую строку (не с абзаца).</p>\n<p>Если два смежных элемента имеют заданные для них поля/внешние отступы (margin) и эти поля соприкасаются друг с другом, большее из них остаётся, а меньшее исчезает — это называется схлопывание полей (margin collapsing), и мы рассматривали это ранее.</p>\n<p>Давайте посмотрим на пример, который объясняет всё из того, что мы рассмотрели в данной статье:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><h1>Базовый поток документа</h1>\n\n<p>\n  Я базовый элемент уровня блока. Мои соседние блочные элементы находятся на\n  новой строке подо мной.\n</p>\n\n<p>\n  По умолчанию мы охватываем 100% ширины нашего родительского элемента, и мы так\n  же высоки, как и наш child-контент. Наша общая ширина и высота - это наш\n  контент + внутренний отступ (padding) + ширина / высота границы.\n</p>\n\n<p>\n  Мы отделены нашими полями. Из-за схлопывания полей мы отделены шириной одного\n  из наших полей, а не обоих\n</p>\n\n<p>\n  Строчные элементы <span>такие как этот</span> и <span>этот</span> находятся на\n  одной линии с другими, и смежным текстом, если есть пространство. Строчные\n  элементы, что не влезают\n  <span>переходят на новую строку если это возможно (как этот текст)</span>если\n  же это невозможно, они переходят на новую строку, как это изображение:\n  <img src="long.jpg">\n</p>\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">body {\n  width: 500px;\n  margin: 0 auto;\n}\n\np {\n  background: rgba(255, 84, 104, 0.3);\n  border: 2px solid rgb(255, 84, 104);\n  padding: 10px;\n  margin: 10px;\n}\n\nspan {\n  background: white;\n  border: 1px solid black;\n}\n</pre></div><div class="code-example" id="sect1"><div class="example-header" id="sect2"></div></div></div></section><section aria-labelledby="заключение"><h2 id="заключение"><a>Заключение</a></h2><div class="section-content"><p>Теперь, когда вы поняли нормальный поток и как браузер выкладывает содержимое по умолчанию, двигаемся дальше, чтобы понять как это изменить для создания макета согласно вашему дизайну.</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Flexbox',
		
		content:
			'<header><h1>Flexbox</h1></header><div class="section-content">\n<p>Это новая технология, которая уже имеет достаточно широкую поддержку браузеров. Flexbox предоставляет инструменты для быстрого создания сложных, гибких макетов, и функции, которые были сложны в традиционных методах CSS. В этой статье объясняются все основы данной технологии.</p>\n</div><section aria-labelledby="почему_flexbox"><h2 id="почему_flexbox"><a>Почему Flexbox?</a></h2><div class="section-content"><p>Долгое время единственными надёжными инструментами CSS вёрстки были такие способы как Float (обтекание) и позиционирование.</p>\n<p>С их помощью сложно или невозможно достичь следующих простых требований к макету:</p>\n<ul>\n  <li>Вертикального выравнивания блока внутри родителя.</li>\n  <li>Оформления всех детей контейнера так, чтобы они распределили между собой доступную ширину/высоту, независимо от того, сколько ширины/высоты доступно.</li>\n  <li>Сделать все колонки в макете одинаковой высоты, даже если наполнение в них различно.</li>\n</ul>\n<p>Как вы увидите в последующих разделах, flexbox значительно облегчает работу с макетами. Погружаемся!</p></div></section><section aria-labelledby="разберём_простой_пример"><h2 id="разберём_простой_пример"><a>Разберём простой пример</a></h2><div class="section-content"><p>В этой статье вы проработаете серию упражнений, которые помогут понять, как работает flexbox. Чтобы начать, скачайте на компьютер стартовый файл — <a class="external" target="_blank">flexbox0.html</a> с нашего Github репозитория — загрузите его в современном браузере (Firefox или Chrome), а также в любимом редакторе кода. Также вы можете <a class="external" target="_blank">посмотреть его вживую</a>.</p>\n<p>Вы увидите элемент <a><code>&lt;header&gt;</code></a> с заголовком верхнего уровня внутри, и элемент <a><code>&lt;section&gt;</code></a> содержащий три элемента <a><code>&lt;article&gt;</code></a>. Мы будем использовать их для создания стандартного трёхколоночного макета.</p>\n<p>\n  \n</p></div></section><section aria-labelledby="определяем_какие_элементы_разместить_в_виде_flex_блоков"><h2 id="определяем_какие_элементы_разместить_в_виде_flex_блоков"><a>Определяем, какие элементы разместить в виде flex блоков</a></h2><div class="section-content"><p>Для начала нам нужно выбрать, какие элементы следует выкладывать в виде flex блоков. Для этого мы устанавливаем специальное значение <a><code>display</code></a> в родительском элементе тех элементов, которые вы хотите оформить. В нашем случае мы хотим расположить элементы <a><code>&lt;article&gt;</code></a>, поэтому мы устанавливаем это значение на <a><code>&lt;section&gt;</code></a> (который становится flex контейнером):</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">section {\n  display: flex;\n}\n</pre></div>\n<p>В результате у нас получится вот так:</p>\n<p>\n  \n</p>\n<p>Так, всего одно объявление делает всё, что нам нужно — здорово, правда? Мы получили 3-х колоночный макет с колонками равных размеров по ширине и высоте. Это связано с тем, что значения по умолчанию, заданные для flex элементов (дочерние элементы flex контейнера), настроены для решения основных задач. Подробнее об этом позже.</p>\n<p><strong>Примечание</strong>: вы также можете установить значение <a><code>display</code></a> <code>inline-flex</code>, если хотите расставить inline элементы как flex блоки.</p></div></section><section aria-labelledby="внутри_flex_модели"><h2 id="внутри_flex_модели"><a>Внутри flex модели</a></h2><div class="section-content"><p>Когда элементы выложены как flex блоки, они располагаются вдоль двух осей:</p>\n<p>\n  \n</p>\n<ul>\n  <li><strong>Главная ось (main axis)</strong> проходит в том направлении, вдоль которого расположены Flex элементы (например, в строку слева направо или вдоль колонок вниз.) Начало и конец этой оси называются <strong>main start</strong> и <strong>main end</strong>.</li>\n  <li><strong>Поперечная ось (cross axis)</strong> проходит перпендикулярно Flex элементам. Начало и конец этой оси называются <strong>cross start</strong> and <strong>cross end</strong>.</li>\n  <li>Родительский элемент, на который назначено свойство <code>display: flex</code> (<a><code>&lt;section&gt;</code></a> в нашем примере) называется <strong>flex container</strong>.</li>\n  <li>Элементы, размещённые в нём как Flex блоки называются <strong>flex items</strong> (в нашем примере это <a><code>&lt;article&gt;</code></a> ).</li>\n</ul>\n<p>Запомните эти термины, они пригодятся вам в последующих разделах.</p></div></section><section aria-labelledby="столбцы_или_строки"><h2 id="столбцы_или_строки"><a>Столбцы или строки?</a></h2><div class="section-content"><p>В Flexbox есть свойство под названием <a><code>flex-direction</code></a>, которое определяет направление главной оси (в каком направлении располагаются flexbox-дочерние элементы) — по умолчанию ему присваивается значение <code>row</code>, т.е. располагать дочерние элементы в ряд слева направо (для большинства языков) или справа налево (для арабских языков).</p>\n<p>Попробуйте добавить следующую строчку в ваш файл:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">flex-direction: column;\n</pre></div>\n<p>Вы увидите, что элементы расположились в виде столбцов, также как было до того, как мы добавили CSS код. Прежде чем продолжать, удалите эту строчку из примера.</p>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> вы можете также располагать flex элементы в обратном направлении, используя значения <code>row-reverse</code> и <code>column-reverse</code>. Попробуйте их тоже!</p>\n</div></div></section><section aria-labelledby="перенос_строк"><h2 id="перенос_строк"><a>Перенос строк</a></h2><div class="section-content"><p>Проблема может быть в том, что, если у вас фиксированная ширина или высота макета, ваши flexbox элементы переполнят контейнер и нарушат макет. Посмотрите на этот пример: <a class="external" target="_blank">flexbox-wrap0.html</a> и <a class="external" target="_blank">посмотрите его вживую</a> (сохраните его себе на компьютер, если хотите изучить этот пример):</p>\n<p>\n  \n</p>\n<p>Мы видим, что дочерние элементы выбиваются из своего родителя-контейнера. Один из способов как это исправить — добавить следующее свойство в CSS-правило для <a><code>&lt;section&gt;</code></a>:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">flex-wrap: wrap;\n</pre></div>\n<p>Также добавьте следующее свойство в CSS-правило для <a class="page-not-created" title="Документация об этом ещё не написана. Пожалуйста, поспособствуйте её написанию!"><code>&lt;arcticle&gt;</code></a>:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">flex: 200px;\n</pre></div>\n<p>Попробуйте, и вы увидите, что так макет стал выглядеть гораздо лучше:</p>\n<p>\n  \n</p>\n<p>Теперь у нас в макете несколько рядов— все дети-блоки, которые не помещаются, переносятся на следующую строку, чтобы не было переполнения. Свойство <code>flex: 200px</code>, установленное на статьях, означает, что каждый блок должен быть минимум 200 пикселей в ширину. Мы обсудим это свойство более подробно позже. Вы также можете заметить, что несколько дочерних блоков в последней строке стали более широкими, так что вся строка стала заполнена.</p>\n<p>Но мы можем пойти дальше. Прежде всего, попробуйте изменить значение свойства <a><code>flex-direction</code></a> на <code>row-reverse</code> — теперь у вас также макет в несколько строк, но он начинается из противоположного угла окна браузера и теперь выстраивается в обратном порядке.</p></div></section><section aria-labelledby="flex-flow_сокращение"><h2 id="flex-flow_сокращение"><a>flex-flow сокращение</a></h2><div class="section-content"><p>На этом этапе нужно заметить, что существует сокращение для свойств <a><code>flex-direction</code></a> и <a><code>flex-wrap</code></a> — <a><code>flex-flow</code></a>. Например, вы можете заменить</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">flex-direction: row;\nflex-wrap: wrap;\n</pre></div>\n<p>на</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">flex-flow: row wrap;\n</pre></div></div></section><section aria-labelledby="гибкое_изменение_размеров_flex_элементов"><h2 id="гибкое_изменение_размеров_flex_элементов"><a>Гибкое изменение размеров flex элементов</a></h2><div class="section-content"><p>Теперь давайте вернёмся к нашему первому примеру и посмотрим, как мы можем контролировать, в каких пропорциях flex элементы будут занимать место. Включите свою копию файла <a class="external" target="_blank">flexbox0.html</a>, или скачайте <a class="external" target="_blank">flexbox1.html</a> (<a class="external" target="_blank">просмотр</a>).</p>\n<p>Прежде всего, добавим следующее правило в конец вашего CSS кода:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">article {\n  flex: 1;\n}\n</pre></div>\n<p>Это безразмерное значение пропорции, которое указывает, сколько свободного пространства на главной оси (main axis) каждый flex элемент сможет занять. В этом случае, мы даём каждому элементу <a><code>&lt;article&gt;</code></a> значение 1, а это значит, что они будут занимать равное количество свободного места в макете, которое осталось после установки свойств padding и margin.</p>\n<p>Теперь добавьте следующее правило в строку после предыдущего:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">article:nth-of-type(3) {\n  flex: 2;\n}\n</pre></div>\n<p>Обновив страницу, вы увидите, что третий элемент <a><code>&lt;article&gt;</code></a> занимает в два раза больше доступной ширины, чем два других — итого теперь доступно 4 единицы пропорции. Первые два flex элемента имеют по одной единице, поэтому берут 1/4 пространства каждый. А у третьего 2 единицы, так что он берёт 2/4 свободного места (или 1/2).</p>\n<p>Вы также можете указать минимальный размер внутри значения flex. Попробуйте изменить существующие правила, добавив размеры:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">article {\n  flex: 1 200px;\n}\n\narticle:nth-of-type(3) {\n  flex: 2 200px;\n}\n</pre></div>\n<p>Это просто означает, что каждому flex элементу сначала будет дано 200px от свободного места. Потом оставшееся место будет поделено в соответствии с частями пропорций. Обновите страницу, и вы увидите разницу, как пространство поделено теперь.</p>\n<p>\n  \n</p>\n<p>Настоящая ценность flexbox можно увидеть в его гибкости/отзывчивости — если изменить размер окна или добавить ещё элемент <a><code>&lt;article&gt;</code></a>, макет будет и дальше выглядеть также хорошо.</p></div></section><section aria-labelledby="flex_краткий_код_против_развёрнутого"><h2 id="flex_краткий_код_против_развёрнутого"><a>flex: краткий код против развёрнутого</a></h2><div class="section-content"><p><a><code>flex</code></a> это сокращённое свойство, в которым можно задать до трёх разных свойств:</p>\n<ul>\n  <li>Значение пропорции, которое мы обсуждали выше. Оно может быть установлено отдельно с помощью свойства <a><code>flex-grow</code></a>.</li>\n  <li>Следующее значение пропорции — <a><code>flex-shrink</code></a> — вступает в роль, когда flex элементы переполняют контейнер. Оно указывает, сколько забирается от размера каждого flex элемента, чтобы он перестал переполнять контейнер. Это продвинутая функция flexbox, и в этом параграфе мы не будем её разбирать.</li>\n  <li>Значение минимального размера, как мы обсуждали ранее. Оно может быть установлено отдельно с помощью свойства <a><code>flex-basis</code></a>.</li>\n</ul>\n<p>Мы не советуем использовать развёрнутые свойства flex, если вам в действительности это не нужно (например, переопределить ранее установленное). Они приводят к написанию большого количества дополнительного кода и могут запутать кого угодно.</p></div></section><section aria-labelledby="горизонтальное_и_вертикальное_выравнивание"><h2 id="горизонтальное_и_вертикальное_выравнивание"><a>Горизонтальное и вертикальное выравнивание</a></h2><div class="section-content"><p>Flexbox также имеет функции для выравнивания flex элементов вдоль основной (main) или поперечной (cross) осей. Рассмотрим их на новом примере — <a class="external" target="_blank">flex-align0.html</a> (<a class="external" target="_blank">просмотр</a>) — который мы превратим в аккуратную, гибкую кнопочную панель инструментов. На данный момент вы видите горизонтальную панель меню, кнопки которой застряли в верхнем левом углу.</p>\n<p>\n  \n</p>\n<p>Сначала сделайте себе копию этого примера.</p>\n<p>Теперь добавьте следующую строку в низ кода CSS:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">div {\n  display: flex;\n  align-items: center;\n  justify-content: space-around;\n}\n</pre></div>\n<p>Обновите страницу, и вы увидите, что кнопки теперь хорошо центрированы, горизонтально и вертикально. Мы сделали это с помощью двух новых свойств.</p>\n<p><a><code>align-items</code></a> контролирует, где на поперечной оси находятся flex элементы.</p>\n<ul>\n  <li>По умолчанию стоит значение <code>stretch</code>, которое растягивает все flex элементы, чтобы заполнить родителя вдоль поперечной (cross axis) оси. Если у родителя нет фиксированной ширины вдоль поперечной оси, все flex элементы примут длину самого длинного flex элемента. Вот почему наш первый пример по умолчанию получил столбцы с одинаковой высотой.</li>\n  <li>Значение <code>center</code> , которое мы использовали в коде вверху, заставляет элементы сохранять свои собственные размеры, но центрирует их вдоль поперечной оси. Вот почему кнопки текущего примера центрированы по вертикали.</li>\n  <li>Также есть значения <code>flex-start</code> и <code>flex-end</code>, которые выравнивают все элементы по началу и концу поперечной оси соответственно. См. подробнее <a><code>align-items</code></a>.</li>\n</ul>\n<p>Вы можете переопределить <a><code>align-items</code></a> поведение для отдельных flex элементов, применив свойство <a><code>align-self</code></a> к ним. Например, попробуйте добавить эти строки в код:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">button:first-child {\n  align-self: flex-end;\n}\n</pre></div>\n<p>Посмотрите, что произошло и удалите эти строки.</p>\n<p><a><code>justify-content</code></a> контролирует, где flex элементы располагаются на главной оси.</p>\n<ul>\n  <li>По умолчанию стоит значение <code>flex-start</code>, которое располагает все элементы в начале главной оси.</li>\n  <li>Также можно использовать <code>flex-end</code>, чтобы расположить их в конце.</li>\n  <li><code>center</code> - также одно из значений <code>justify-content</code>, располагает все элементы по центру главной оси.</li>\n  <li>Значение, которое мы использовали выше, <code>space-around</code>, весьма полезно — оно распределяет все элементы равномерно по главной оси, с небольшим количеством свободного места на обоих концах.</li>\n  <li>И ещё одно значение, <code>space-between</code>, которое очень похоже на <code>space-around,</code> за исключением того, что оно не оставляет места на обоих концах.</li>\n</ul>\n<p>Попробуйте немного поиграть с этими значениями прежде чем продолжить</p></div></section><section aria-labelledby="порядок_элементов_flex"><h2 id="порядок_элементов_flex"><a>Порядок элементов flex</a></h2><div class="section-content"><p>В Flexbox также есть возможность менять порядок расположения flex элементов, не влияя на исходный порядок. Это ещё одна вещь, которую невозможно сделать традиционными методами CSS.</p>\n<p>Код здесь простой: попробуйте добавить следующий CSS вниз вашего кода примера:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">button:first-child {\n  order: 1;\n}\n</pre></div>\n<p>и теперь вы увидите, что кнопка «Smile» переместилась в конец главной оси. Давайте теперь поговорим подробнее о том, как это работает:</p>\n<ul>\n  <li>По умолчанию все элементы flex имеют значение <a><code>order</code></a> равное 0.</li>\n  <li>Элементы Flex с установленными на них бОльшими значениями будут отображаться позже в порядке отображения, чем элементы с меньшими значениями порядка.</li>\n  <li>Элементы Flex с одинаковым значением порядка будут отображаться в исходном порядке. Так, если у вас есть четыре элемента с порядковыми значениями 2, 1, 1 и 0, установленными на них соответственно, их порядок отображения будет 4-й, 2-й, 3-й, затем 1-й.</li>\n  <li>Третий элемент появляется после второго, потому что он имеет то же значение порядка и находится после него в порядке написания.</li>\n</ul>\n<p>Вы можете установить отрицательные значения , чтобы элементы отображались раньше, чем элементы с установленным 0. Например, вы можете сделать, чтобы кнопка «Blush» появлялась в начале основной оси, используя следующее правило:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">button:last-child {\n  order: -1;\n}\n</pre></div></div></section><section aria-labelledby="вложенные_flex_блоки"><h2 id="вложенные_flex_блоки"><a>Вложенные flex блоки</a></h2><div class="section-content"><p>Можно создать несколько довольно сложных макетов с помощью flexbox. Совершенно нормально сделать flex элемент flex контейнером, чтобы его потомки также были flex блоками. Посмотрите на <a class="external" target="_blank">complex-flexbox.html</a> (<a class="external" target="_blank">см. вживую</a>).</p>\n<p>\n  \n</p>\n<p>HTML для этого довольно простой. У нас есть элемент <a><code>&lt;section&gt;</code></a>, содержащий три <a><code>&lt;article&gt;</code></a>. Третий <a><code>&lt;article&gt;</code></a> содержит ещё три <a><code>&lt;div&gt;</code></a>.</p>\n<pre compile="false" disable="true" language="css">section - article\n          article\n          article - div - button\n                    div   button\n                    div   button\n                          button\n                          button\n</pre>\n<p>Давайте посмотрим на код, который мы использовали для макета.</p>\n<p>Прежде всего, мы устанавливаем дочерние элементы <a><code>&lt;section&gt;</code></a> в виде flex блоков.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup">section {\n  display: flex;\n}\n</pre></div>\n<p>Затем мы устанавливаем несколько значений на самих <a><code>&lt;article&gt;</code></a>. Обратите внимание на второе правило: мы устанавливаем третий <a><code>&lt;article&gt;</code></a>, чтобы его дети были в макете в виде flex блоков, но на этот раз мы располагаем их как столбец.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">article {\n  flex: 1 200px;\n}\n\narticle:nth-of-type(3) {\n  flex: 3 200px;\n  display: flex;\n  flex-flow: column;\n}\n</pre></div>\n<p>Затем мы берём первый <a><code>&lt;div&gt;</code></a>. Сначала мы пишем flex: 1 100px; чтобы дать ему минимальную высоту 100px, потом мы устанавливаем его дочерние элементы (элементы <a><code>&lt;button&gt;</code></a>) также в виде flex блоков. Им мы назначаем перенос блоков и выравниваем их по центру доступного пространства, как это было в примере с кнопкой.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">article:nth-of-type(3) div:first-child {\n  flex: 1 100px;\n  display: flex;\n  flex-flow: row wrap;\n  align-items: center;\n  justify-content: space-around;\n}\n</pre></div>\n<p>Наконец, мы устанавливаем размер кнопке, мы даём ему значение flex 1. Это даёт очень интересный эффект, который вы увидите, если попытаетесь изменить размер ширины окна браузера. Кнопки занимают столько места, сколько могут, и сидят на одной линии также, сколько могут. Если же они не могут комфортно расположиться на одной линии, они перепрыгнут на новые строки.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">button {\n  flex: 1 auto;\n  margin: 5px;\n  font-size: 18px;\n  line-height: 1.5;\n}\n</pre></div></div></section><section aria-labelledby="подытожим"><h2 id="подытожим"><a>Подытожим</a></h2><div class="section-content"><p>Мы завершаем нашу статью по основам flexbox. Надеемся, что вам понравилось, и вы хорошо развлечётесь, путешествуя дальше и изучая его. Далее мы рассмотрим ещё один важный аспект макетов CSS - grid-системы.</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Grids',
		
		content:
			'<header><h1>Grids</h1></header><div class="section-content"><p></p>Сетки (grids) являются установленным инструментом проектирования и многие современные макеты веб-сайта основаны на регулярной сетке. В этой статье мы рассмотрим дизайн на основе сетки и увидим как CSS можно использовать для создания сеток — как с помощью современных инструментов, так и с помощью новых технологий, которые только начинают становиться доступными в браузерах.<p></p>\n</div><section aria-labelledby="что_такое_макет_сетки_grid_layout"><h2 id="что_такое_макет_сетки_grid_layout"><a>Что такое макет сетки (grid layout)?</a></h2><div class="section-content"><p>Сетка (grid) - это просто набор горизонтальных и вертикальных линий, создающих шаблон, по которому мы можем выстроить элементы дизайна. Они помогают нам создавать проекты, в которых элементы не прыгают или не меняют ширину при переходе от страницы к странице, обеспечивая большую согласованность на наших сайтах.</p>\n<p>В сетке обычно будут <strong>столбцы (columns)</strong>, <strong>строки (rows)</strong>, а затем промежутки между каждой строкой и столбцом, обычно называемые <strong>желобами (gutters)</strong>.</p>\n<p>\n  \n</p>\n<p>[Временная диаграмма; скоро будет заменена лучшей диаграммой.]</p>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> Может показаться удивительным, если кто-нибудь из фона дизайна, что CSS не имеет встроенной сетки, и вместо этого мы, похоже, используем множество субоптимальных методов для создания сетчатых конструкций. Как вы узнаете в последней части этой статьи, это изменится, однако вам, вероятно, понадобятся существующие методы создания гридов в течение некоторого времени.</p>\n</div></div></section><section aria-labelledby="использование_grid_system_в_ваших_проектах"><h2 id="использование_grid_system_в_ваших_проектах"><a>Использование "grid system" в ваших проектах</a></h2><div class="section-content"><p>Чтобы обеспечить постоянный опыт на вашем сайте или в приложении, основываясь на системе сетки с самого начала, вам не нужно думать о том, насколько широкий элемент имеет отношение к другим элементам. Ваш выбор ограничен «количеством столбцов сетки, которые этот элемент будет охватывать».</p>\n<p>Ваша «сеточная система» может быть просто решением, принятым в процессе проектирования, для использования регулярной сетки. Если ваши проекты начнутся в приложении для редактирования графики, например Photoshop, вы можете создать сетку для ссылки во время этого процесса, как описано в <a class="external" target="_blank">A better Photoshop grid for responsive web design</a> by Elliot Jay Stocks.</p>\n<p>Ваша сетевая система также может быть структурой - либо третьей стороной, либо созданной вами только для вашего проекта, - которую вы используете для обеспечения сетки с помощью CSS.</p></div></section><section aria-labelledby="создание_простых_рамок_сетки"><h2 id="создание_простых_рамок_сетки"><a>Создание простых рамок сетки</a></h2><div class="section-content"><p>Мы начнём с рассмотрения того, как вы можете создать простую сетку для вашего проекта.</p>\n<p>В настоящее время большинство макетов типа grid создаются с использованием поплавков (floats). Если вы прочитали <a>нашу предыдущую статью о поплавках,</a> вы уже видели, как мы можем использовать эту технику для создания раскладки нескольких столбцов, что является сущностью любой сетки, использующей этот метод.</p>\n<p>Самый простой тип структуры сетки для создания фиксированной ширины — нам просто нужно выяснить, сколько общей ширины мы хотим для нашего дизайна, сколько столбцов мы хотим и насколько широки должны быть желоба и столбцы. Если бы вместо этого мы решили выложить наш проект на сетке со столбцами, которые растут и сокращаются в соответствии с шириной браузера, нам нужно будет рассчитать процентную ширину для столбцов и желобов между ними.</p>\n<p>В следующих разделах мы рассмотрим, как создать оба. Мы создадим сетку с 12 столбцами - очень общий выбор, который, как видно, очень адаптируется к различным ситуациям, учитывая, что 12 прекрасно делится на 6, 4, 3 и 2.</p></div></section><section aria-labelledby="простая_сетка_с_фиксированной_шириной"><h3 id="простая_сетка_с_фиксированной_шириной"><a>Простая сетка с фиксированной шириной</a></h3><div class="section-content"><p>Давайте сначала создадим сетку, использующую столбцы фиксированной ширины.</p>\n<p>Начните с создания локальной копии нашего образца <a class="external" target="_blank">simple-grid.html</a> файла, который содержит следующую разметку в своём теле.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><div class="wrapper">\n  <div class="row">\n    <div class="col">1</div>\n    <div class="col">2</div>\n    <div class="col">3</div>\n    <div class="col">4</div>\n    <div class="col">5</div>\n    <div class="col">6</div>\n    <div class="col">7</div>\n    <div class="col">8</div>\n    <div class="col">9</div>\n    <div class="col">10</div>\n    <div class="col">11</div>\n    <div class="col">12</div>\n  </div>\n  <div class="row">\n    <div class="col span1">13</div>\n    <div class="col span6">14</div>\n    <div class="col span3">15</div>\n    <div class="col span2">16</div>\n  </div>\n</div>\n</pre></div>\n<p>Цель состоит в том, чтобы превратить это в демонстрационную сетку из двух рядов на двенадцать столбцов сетки (grid) - верхний ряд, демонстрирующий размер отдельных столбцов, второй ряд - некоторые области разного размера в сетке.</p>\n<p>\n  \n</p>\n<p>В элементе <a><code>&lt;style&gt;</code></a> добавьте следующий код, который даёт контейнеру ширину 980 пикселей с отступом с правой стороны 20 пикселей. Это даёт нам 960 пикселей для нашей общей ширины столбца/желоба - в этом случае отступы вычитаются из общей ширины содержимого, потому что мы установили <a><code>box-sizing</code></a> в рамку по всем элементам на сайте (см. <a>Changing the box model completely</a> для большего объяснения).</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">* {\n  box-sizing: border-box;\n}\n\nbody {\n  width: 980px;\n  margin: 0 auto;\n}\n\n.wrapper {\n  padding-right: 20px;\n}\n</pre></div>\n<p>Теперь используйте контейнер строк, который обёрнут вокруг каждой строки сетки, чтобы очистить одну строку от другой. Добавьте следующее правило ниже предыдущего:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.row {\n  clear: both;\n}\n</pre></div>\n<p>Применение этого клиринга означает, что нам не нужно полностью заполнять каждую строку элементами, составляющими полные двенадцать столбцов. Строки будут разделены и не будут мешать друг другу.</p>\n<p>Желоба между колоннами шириной 20 пикселей. Мы создаём эти желоба в качестве поля в левой части каждого столбца, включая первый столбец, чтобы сбалансировать 20 пикселей прокладки в правой части контейнера. Таким образом, у нас есть 12 водосточных желобов - 12 x 20 = 240.</p>\n<p>Нам нужно вычесть это из нашей общей ширины 960 пикселей, что даёт нам 720 пикселей для наших столбцов. Если мы разделим это на 12, мы знаем, что каждый столбец должен быть 60 пикселей в ширину. Наш следующий шаг - создать правило для класса <code>.col</code>, плавающее влево, предоставив ему <a><code>margin-left</code></a> из 20 пикселей для формирования желоба и <a><code>width</code></a> из 60 пикселей. Добавьте нижеследующее правило в CSS:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.col {\n  float: left;\n  margin-left: 20px;\n  width: 60px;\n  background: rgb(255, 150, 150);\n}\n</pre></div>\n<p>Верхний ряд отдельных столбцов теперь будет аккуратно размещаться в виде сетки.</p>\n<div class="notecard note" id="sect2">\n  <p><strong>Примечание:</strong> Мы также дали каждому столбцу светло-красный цвет, чтобы вы могли точно видеть, сколько места занимает каждый.</p>\n</div>\n<p>В контейнерах макетов, которые мы хотим разместить более одного столбца, нужно предоставить специальные классы, чтобы скорректировать их значения <a><code>width</code></a> до необходимого количества столбцов (плюс желоба между ними). Нам нужно создать дополнительный класс, чтобы контейнеры могли охватывать от 2 до 12 столбцов. Каждая ширина является результатом сложения ширины столбца этого количества столбцов плюс ширины желоба, который всегда будет набирать номер меньше, чем число столбцов.</p>\n<p>Добавьте нижеследующую часть вашего CSS:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">/\n  *\n  Ширина\n  двух\n  колонок\n  (120 пикселей)\n  плюс\n  одна\n  ширина\n  желоба\n  (20 пикселей)\n  */\n  .col.span2 {\n  width: 140px;\n}\n/\n  *\n  Три\n  ширины\n  столбца\n  (180 пикселей)\n  плюс\n  две\n  ширины\n  желоба\n  (40 пикселей)\n  *\n  /\n  .col.span3 {\n  width: 220px;\n}\n/* И так далее... */\n.col.span4 {\n  width: 300px;\n}\n.col.span5 {\n  width: 380px;\n}\n.col.span6 {\n  width: 460px;\n}\n.col.span7 {\n  width: 540px;\n}\n.col.span8 {\n  width: 620px;\n}\n.col.span9 {\n  width: 700px;\n}\n.col.span10 {\n  width: 780px;\n}\n.col.span11 {\n  width: 860px;\n}\n.col.span12 {\n  width: 940px;\n}\n</pre></div>\n<p>С помощью этих классов мы можем теперь выкладывать разные столбцы ширины в сетке. Попробуйте сохранить и загрузить страницу в своём браузере, чтобы увидеть эффекты.</p>\n<div class="notecard note" id="sect3">\n  <p><strong>Примечание:</strong> Если вам не удаётся заставить приведённый выше пример работать, попробуйте сравнить его с нашей <a class="external" target="_blank">готовой версией</a> на GitHub (см. также <a class="external" target="_blank">запуск в режиме реального времени</a>).</p>\n</div>\n<p>Попробуйте изменить классы на своих элементах или даже добавить и удалить некоторые контейнеры, чтобы увидеть, как вы можете изменять макет. Например, вы можете сделать вторую строку следующим образом:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css"><div class="row">\n  <div class="col span8">13</div>\n  <div class="col span4">14</div>\n</div>\n</pre></div>\n<p>Теперь у вас работает сетка, вы можете просто определить строки и количество столбцов в каждой строке, а затем заполнить каждый контейнер своим необходимым контентом. Отлично!</p></div></section><section aria-labelledby="создание_fluid_grid"><h3 id="создание_fluid_grid"><a>Создание fluid grid</a></h3><div class="section-content"><p>Наша сетка работает красиво, но имеет фиксированную ширину. Нам очень нужна гибкая (жидкая) сетка, которая будет расти и сокращаться с доступным пространством в браузере <a>viewport</a>. Для этого мы можем использовать опорные пиксельные ширины и превратить их в проценты</p>\n<p>Уравнение, которое превращает фиксированную ширину в гибкую, основанную на процентах, выглядит следующим образом.</p>\n<pre compile="false" disable="true" language="css">target / context = result\n</pre>\n<p>Для нашей ширины столбца наша <strong>целевая ширина</strong> составляет 60 пикселей, а наш <strong>контекст</strong> 960 пикселей. Для расчёта процента мы можем использовать следующее.</p>\n<pre compile="false" disable="true" language="css">60 / 960 = 0.0625\n</pre>\n<p>Затем мы перемещаем десятичные точки на 2 места, давая нам процент от 6,25%. Таким образом, в нашем CSS мы можем заменить ширину столбца 60 пикселей на 6,25%.</p>\n<p>Мы должны сделать то же самое с нашей шириной желоба:</p>\n<pre compile="false" disable="true" language="css">20 / 960 = 0.02083333333\n</pre>\n<p>Поэтому нам нужно заменить 20 пикселей <a><code>margin-left</code></a> на наше правило <code>.col</code> 20 пикселей <a><code>padding-right</code></a> на <code>.wrapper</code> с 2.08333333%.</p>\n<h4 id="обновление_нашей_сетки">Обновление нашей сетки</h4>\n<p>Чтобы начать работу в этом разделе, создайте новую копию предыдущей страницы примера или создайте локальную копию нашего кода <a class="external" target="_blank">simple-grid-finished.html</a>, который будет использоваться в качестве отправной точки.</p>\n<p>Обновите второе правило CSS (с помощью селектора <code>.wrapper</code>) следующим образом:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup">body {\n  width: 90%;\n  max-width: 980px;\n  margin: 0 auto;\n}\n\n.wrapper {\n  padding-right: 2.08333333%;\n}\n</pre></div>\n<p>Мы не только дали нам процент <a><code>width</code></a>, мы также добавили свойство <a><code>max-width</code></a>, чтобы остановить распространение макета.</p>\n<p>Затем обновите четвёртое правило CSS (с селектором <code>.col</code>) следующим образом:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup">.col {\n  float: left;\n  margin-left: 2.08333333%;\n  width: 6.25%;\n  background: rgb(255, 150, 150);\n}\n</pre></div>\n<p>Теперь идёт немного более трудоёмкая часть - нам нужно обновить все наши правила <code>.col.span</code>, чтобы использовать проценты, а не ширину пикселей. Это занимает немного времени с калькулятором; чтобы сэкономить вам немного усилий, мы сделали это для вас ниже.</p>\n<p>Обновите нижний блок правил CSS следующим образом:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup">/* Two column widths (12.5%) plus one gutter width (2.08333333%) */\n.col.span2 {\n  width: 14.58333333%;\n}\n/* Three column widths (18.75%) plus two gutter widths (4.1666666) */\n.col.span3 {\n  width: 22.91666666%;\n}\n/* And so on... */\n.col.span4 {\n  width: 31.24999999%;\n}\n.col.span5 {\n  width: 39.58333332%;\n}\n.col.span6 {\n  width: 47.91666665%;\n}\n.col.span7 {\n  width: 56.24999998%;\n}\n.col.span8 {\n  width: 64.58333331%;\n}\n.col.span9 {\n  width: 72.91666664%;\n}\n.col.span10 {\n  width: 81.24999997%;\n}\n.col.span11 {\n  width: 89.5833333%;\n}\n.col.span12 {\n  width: 97.91666663%;\n}\n</pre></div>\n<p>Теперь сохраните свой код, загрузите его в браузере и попробуйте изменить ширину видового экрана - вы должны увидеть, что ширины столбцов хорошо меняются. Отлично!</p>\n<div class="notecard note" id="sect4">\n  <p><strong>Примечание:</strong> Если вам не удаётся заставить приведённый выше пример работать, попробуйте сравнить его с нашей <a class="external" target="_blank">готовой версией на GitHub</a> (см. также <a class="external" target="_blank">запуск в режиме реального времени</a>).</p>\n</div></div></section><section aria-labelledby="более_простые_вычисления_с_использованием_функции_calc"><h3 id="более_простые_вычисления_с_использованием_функции_calc"><a>Более простые вычисления с использованием функции calc()</a></h3><div class="section-content"><p>Вы можете использовать функцию <a class="page-not-created" title="Документация об этом ещё не написана. Пожалуйста, поспособствуйте её написанию!"><code>calc ()</code></a> для выполнения математики прямо внутри вашего CSS - это позволяет вставлять простые математические уравнения в ваши значения CSS, чтобы рассчитать, какое значение должно быть. Это особенно полезно, когда необходимо выполнить сложную математику и вы даже можете сделать расчёт, который использует разные единицы, например «Я хочу, чтобы высота этого элемента всегда была на 100% от высоты родителя, минус 50 пикселей». См. <a>этот пример из учебника API MediaRecorder</a>.</p>\n<p>В любом случае, вернёмся к нашим сетям! Любой столбец, который охватывает более одного столбца нашей сетки, имеет общую ширину 6,25%, умноженную на количество столбцов, спаренных плюс 2.08333333%, умноженное на количество желобов (которые всегда будут числом столбцов минус 1). Функция <code>calc()</code> позволяет нам делать это вычисление прямо внутри значения ширины, поэтому для любого элемента, охватывающего 4 столбца, мы можем это сделать, например:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.col.span4 {\n  width: calc((6.25% * 4) + (2.08333333% * 3));\n}\n</pre></div>\n<p>Попробуйте заменить нижний блок правил следующим, а затем перезагрузите его в браузере, чтобы узнать, получаете ли вы тот же результат:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.col.span2 {\n  width: calc((6.25% * 2) + 2.08333333%);\n}\n.col.span3 {\n  width: calc((6.25% * 3) + (2.08333333% * 2));\n}\n.col.span4 {\n  width: calc((6.25% * 4) + (2.08333333% * 3));\n}\n.col.span5 {\n  width: calc((6.25% * 5) + (2.08333333% * 4));\n}\n.col.span6 {\n  width: calc((6.25% * 6) + (2.08333333% * 5));\n}\n.col.span7 {\n  width: calc((6.25% * 7) + (2.08333333% * 6));\n}\n.col.span8 {\n  width: calc((6.25% * 8) + (2.08333333% * 7));\n}\n.col.span9 {\n  width: calc((6.25% * 9) + (2.08333333% * 8));\n}\n.col.span10 {\n  width: calc((6.25% * 10) + (2.08333333% * 9));\n}\n.col.span11 {\n  width: calc((6.25% * 11) + (2.08333333% * 10));\n}\n.col.span12 {\n  width: calc((6.25% * 12) + (2.08333333% * 11));\n}\n</pre></div>\n<div class="notecard note" id="sect5">\n  <p><strong>Примечание:</strong> вы можете увидеть нашу законченную версию в файле <a class="external" target="_blank">liquid-grid-calc.html</a> (также см. её <a class="external" target="_blank">в режиме реального времени</a>).</p>\n</div>\n<div class="notecard note" id="sect6">\n  <p><strong>Примечание:</strong> Если вы не можете заставить это работать, возможно, это связано с тем, что ваш браузер не поддерживает функцию <code>calc ()</code>, хотя он довольно хорошо поддерживается в браузерах - ещё в IE9.</p>\n</div></div></section><section aria-labelledby="семантические_и_несемантические_сетчатые_системы"><h3 id="семантические_и_несемантические_сетчатые_системы"><a>Семантические и "несемантические" сетчатые системы</a></h3><div class="section-content"><p>Добавление классов в вашу разметку для определения макета означает, что ваш контент и разметка привязаны к его визуальному представлению. Иногда вы слышите это использование классов CSS, описанных как «несемантические», - описывая, как выглядит контент, а не семантическое использование классов, описывающих контент. Это относится к классам <code>span2</code>, <code>span3</code> и т. Д.</p>\n<p>Это не единственный подход. Вместо этого вы можете выбрать свою сетку, а затем добавить информацию о размерах в правила для существующих семантических классов. Например, если у вас есть <a><code>&lt;div&gt;</code></a> с классом <code>content</code> в нем, который вы хотите разбить на 8 столбцов, вы можете скопировать по ширине из класса <code>span8</code>, предоставив вам следующее правило:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.content {\n  width: calc((6.25% * 8) + (2.08333333% * 7));\n}\n</pre></div>\n<div class="notecard note" id="sect7">\n  <p><strong>Примечание:</strong> Если вы использовали препроцессор, такой как <a class="external" target="_blank">Sass</a>, вы могли бы создать простой mixin, чтобы вставить это значение для вас.</p>\n</div></div></section><section aria-labelledby="включение_офсетных_контейнеров_в_нашей_сетке"><h3 id="включение_офсетных_контейнеров_в_нашей_сетке"><a>Включение офсетных контейнеров в нашей сетке</a></h3><div class="section-content"><p>Сетка, которую мы создали, работает хорошо, пока мы хотим запустить все контейнеры заподлицо с левой стороны сетки. Если бы мы хотели оставить пустое пространство столбца перед первым контейнером - или между контейнерами - нам нужно было бы создать класс смещения, чтобы добавить левое поле на наш сайт, чтобы визуально визуализировать его по сетке. Больше математики!</p>\n<p>Давайте попробуем это.</p>\n<p>Начните с предыдущего кода или используйте наш файл <a class="external" target="_blank">fluid-grid.html</a> в качестве отправной точки.</p>\n<p>Давайте создадим класс в нашем CSS, который будет смещать элемент контейнера на одну ширину столбца. Добавьте нижеследующую часть вашего CSS:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.offset-by-one {\n  margin-left: calc(6.25% + (2.08333333% * 2));\n}\n</pre></div>\n<p>Или если вы предпочитаете самостоятельно рассчитать проценты, используйте это:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.offset-by-one {\n  margin-left: 10.41666666%;\n}\n</pre></div>\n<p>Теперь вы можете добавить этот класс в любой контейнер, в котором вы хотите оставить пустое пространство с одним столбцом в левой части окна. Например, если у вас есть это в вашем HTML:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><div class="col span6">14</div>\n</pre></div>\n<p>Попробуйте заменить его на</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><div class="col span5 offset-by-one">14</div>\n</pre></div>\n<div class="notecard note" id="sect8">\n  <p><strong>Примечание:</strong> Обратите внимание, что вам необходимо уменьшить количество столбцов, чтобы освободить место для смещения!</p>\n</div>\n<p>Попытайтесь загрузить и обновить, чтобы увидеть разницу или посмотрите наш пример <a class="external" target="_blank">fluid-grid-offset.html</a> (см. <a class="external" target="_blank">также «live»</a>). Готовый пример должен выглядеть так:</p>\n<p>\n  \n</p>\n<div class="notecard note" id="sect9">\n  <p><strong>Примечание:</strong> В качестве дополнительного упражнения вы можете реализовать класс «смещение на два»?</p>\n</div></div></section><section aria-labelledby="ограничения_с_плавающей_сеткой"><h3 id="ограничения_с_плавающей_сеткой"><a>Ограничения с плавающей сеткой</a></h3><div class="section-content"><p>При использовании такой системы вам необходимо позаботиться о том, чтобы ваша общая ширина была правильно вставлена и что вы не включаете элементы в строку, которая содержит больше столбцов, чем может содержать строка. Из-за того, как работают поплавки, если количество столбцов сетки становится слишком большим для сетки, элементы на конце будут опускаться до следующей строки, разбивая сетку.</p>\n<p>Также имейте в виду, что если содержимое элементов становится шире, чем занимаемые им строки, оно будет переполняться и выглядит как беспорядок.</p>\n<p>Самое большое ограничение этой системы состоит в том, что она по существу одномерна. Мы имеем дело со столбцами и охватываем элементы по столбцам, но не по строкам. С помощью этих старых методов компоновки очень сложно контролировать высоту элементов без явной установки высоты, и это тоже очень негибкий подход - он работает только, если вы можете гарантировать, что ваш контент будет определённой высоты.</p></div></section><section aria-labelledby="flexbox_grids"><h2 id="flexbox_grids"><a>Flexbox grids?</a></h2><div class="section-content"><p>Если вы прочтёте нашу предыдущую статью о <a>flexbox</a>, вы можете подумать, что flexbox - идеальное решение для создания сетчатой системы. В настоящее время доступно множество систем gridbox на основе flexbox и flexbox может решить многие из проблем, которые мы уже обнаружили при создании нашей сетки выше.</p>\n<p>Однако flexbox никогда не разрабатывался как сетчатая система и создаёт новый набор проблем при использовании в качестве одного. В качестве простого примера мы можем использовать тот же пример разметки, который мы использовали выше, и использовать следующий CSS для стилей классов-оболочек (<code>wrapper</code>), <code>row</code> и <code>col</code> классов:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">body {\n  width: 90%;\n  max-width: 980px;\n  margin: 0 auto;\n}\n\n.wrapper {\n  padding-right: 2.08333333%;\n}\n\n.row {\n  display: flex;\n}\n\n.col {\n  margin-left: 2.08333333%;\n  margin-bottom: 1em;\n  width: 6.25%;\n  flex: 1 1 auto;\n  background: rgb(255, 150, 150);\n}\n</pre></div>\n<p>Вы можете попробовать сделать эти замены в своём собственном примере или посмотреть на наш пример кода <a class="external" target="_blank">flexbox-grid.html</a> (см. также <a class="external" target="_blank">он работает в режиме реального времени</a>).</p>\n<p>Здесь мы превращаем каждую строку в гибкий контейнер. С сеткой на основе flexbox нам все ещё нужны строки, чтобы мы могли иметь элементы, которые составляют менее 100%. Мы установили этот контейнер для <code>display: flex</code>.</p>\n<p>На <code>.col</code> мы устанавливаем первое значение свойства <a><code>flex</code></a> (<a><code>flex-grow</code></a>) до 1, чтобы наши объекты могли расти, второе значение (<a class="page-not-created" title="Документация об этом ещё не написана. Пожалуйста, поспособствуйте её написанию!"><code> flex-shrink </code></a>) до 1, поэтому элементы могут сокращаться, а третье значение (<a class="page-not-created" title="Документация об этом ещё не написана. Пожалуйста, поспособствуйте её написанию!"><code> flex-basis </code></a>) - <code>auto</code>. Поскольку наш элемент имеет набор <a><code>width</code></a>, <code>auto</code> будет использовать эту ширину в качестве базового значения flex (<code>flex-basis</code>).</p>\n<p>В верхней строке мы получаем двенадцать аккуратных коробок на сетке, и они растут и сжимаются одинаково, когда мы меняем ширину окна просмотра. Однако на следующей строке у нас есть только четыре элемента, и они также растут и сокращаются с 60px. Только с четырьмя из них они могут расти намного больше, чем элементы в строке выше, в результате они все занимают одну и ту же ширину во второй строке.</p>\n<p>\n  \n</p>\n<p>Чтобы исправить это, нам всё равно нужно включить наши классы <code>span</code>, чтобы обеспечить ширину, которая заменит значение, используемое <code>flex-basis</code> для этого элемента.</p>\n<p>Они также не уважают сетку, используемую выше, потому что они ничего не знают об этом.</p>\n<p>Flexbox является <strong>одномерным</strong> по дизайну. Он имеет дело с одним измерением - со строкой или столбцом. Мы не можем создать строгую сетку для столбцов и строк, что означает, что если мы будем использовать flexbox для нашей сетки, нам всё равно нужно рассчитать проценты, как для плавающего макета.</p>\n<p>В вашем проекте вы всё равно можете использовать сетку flexbox из-за дополнительных возможностей выравнивания и распределения пространства. Flexbox обеспечивает надплавки. Однако вам следует помнить, что вы все ещё используете инструмент для чего-то другого, кроме того, для чего он предназначен. Таким образом, вы можете почувствовать, что он заставляет вас прыгать через дополнительные обручи, чтобы получить конечный результат, который вы хотите.</p></div></section><section aria-labelledby="системы_сторонних_сетей"><h2 id="системы_сторонних_сетей"><a>Системы сторонних сетей</a></h2><div class="section-content"><p>Теперь, когда мы понимаем математику за нашими расчётами в сетке, мы находимся в хорошем месте, чтобы взглянуть на некоторые из сторонних сетевых систем, которые используются совместно. Если вы ищете «CSS Grid framework» в Интернете, вы найдёте огромный список вариантов на выбор. В популярных структурах, таких как <a class="external" target="_blank">Bootstrap</a> и <a class="external" target="_blank">Foundation</a>, есть сетка. Существуют также автономные сетчатые системы, разработанные с использованием CSS или с использованием препроцессоров.</p>\n<p>Давайте рассмотрим одну из этих автономных систем, поскольку она демонстрирует общие методы работы с сеткой. Сетка, которую мы будем использовать, является частью Skeleton, простой CSS-структуры.</p>\n<p>Для начала посетите <a class="external" target="_blank">веб-сайт Skeleton</a> и выберите «Загрузить», чтобы загрузить ZIP-файл. Разархивируйте это и скопируйте файлы skeleton.css и normalize.css в новый каталог.</p>\n<p>Сделайте копию нашего файла <a class="external" target="_blank">html-skeleton.html</a> и сохраните его в том же каталоге, что и скелет, и нормализовать CSS.</p>\n<p>Включите скелет и нормализуйте CSS на странице HTML, добавив следующее в голову:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><link href="normalize.css" rel="stylesheet">\n<link href="skeleton.css" rel="stylesheet">\n</pre></div>\n<p>Скелет включает в себя больше, чем сетку - он также содержит CSS для типографики и других элементов страницы, которые вы можете использовать в качестве отправной точки. На данный момент мы оставим их по умолчанию, но именно эта сетка нас действительно интересует.</p>\n<div class="notecard note" id="sect10">\n  <p><strong>Примечание:</strong> Нормализация - очень полезная небольшая библиотека CSS, написанная Николасом Галлахером, которая автоматически делает некоторые полезные основные исправления макета и делает стиль элементов по умолчанию более согласованным в разных браузерах.</p>\n</div>\n<p>Мы будем использовать аналогичный HTML для нашего предыдущего примера. Добавьте в свой HTML-код следующее:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><div class="container">\n  <div class="row">\n    <div class="col">1</div>\n    <div class="col">2</div>\n    <div class="col">3</div>\n    <div class="col">4</div>\n    <div class="col">5</div>\n    <div class="col">6</div>\n    <div class="col">7</div>\n    <div class="col">8</div>\n    <div class="col">9</div>\n    <div class="col">10</div>\n    <div class="col">11</div>\n    <div class="col">12</div>\n  </div>\n  <div class="row">\n    <div class="col">13</div>\n    <div class="col">14</div>\n    <div class="col">15</div>\n    <div class="col">16</div>\n  </div>\n</div>\n</pre></div>\n<p>Чтобы начать использовать Skeleton, нам нужно предоставить оболочку <a><code>&lt;div&gt;</code></a> класс <code>container</code> - это уже включено в наш HTML. Это центрирует контент с максимальной шириной 960 пикселей. Вы можете видеть, как теперь коробки не становятся шире, чем 960 пикселей.</p>\n<p>Вы можете посмотреть в файле skeleton.css, чтобы увидеть CSS, который используется, когда мы применяем этот класс. <code>&lt;div&gt;</code> центрируется с использованием <code>auto</code> левого и правого полей, а отступы в 20 пикселей применяются слева и справа. Скелет также устанавливает свойство <a><code>box-sizing</code></a> в <code>border-box</code>, как мы делали это раньше, поэтому дополнение и границы этого элемента будут включены в общую ширину.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.container {\n  position: relative;\n  width: 100%;\n  max-width: 960px;\n  margin: 0 auto;\n  padding: 0 20px;\n  box-sizing: border-box;\n}\n</pre></div>\n<p>Элементы могут быть только частью сетки, если они находятся внутри строки, так как в нашем предыдущем примере нам нужен дополнительный <code>&lt;div&gt;</code> или другой элемент с классом строки (<code>row</code>), вложенным между <code>content</code> <code>&lt;div&gt;</code> и нашим контейнером фактического содержимого <code>&lt;div&gt;</code>. Мы уже это сделали.</p>\n<p>Теперь давайте выложим контейнеры. Скелет основан на сетке из 12 столбцов. В верхних строках нужны классы из <code>one column</code>, чтобы они охватывали один столбец.</p>\n<p>Добавьте их сейчас, как показано в следующем фрагменте:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><div class="container">\n  <div class="row">\n    <div class="one column">1</div>\n    <div class="one column">2</div>\n    <div class="one column">3</div>\n    /* and so on */\n  </div>\n</div>\n</pre></div>\n<p>Затем дайте контейнеры во втором классе классов, объясняющие количество столбцов, которые они должны охватывать, например:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><div class="row">\n  <div class="one column">13</div>\n  <div class="six columns">14</div>\n  <div class="three columns">15</div>\n  <div class="two columns">16</div>\n</div>\n</pre></div>\n<p>Попробуйте сохранить свой HTML-файл и загрузить его в свой браузер, чтобы увидеть эффект.</p>\n<div class="notecard note" id="sect11">\n  <p><strong>Примечание:</strong> Примечание. Если вам не удаётся заставить этот пример работать, попробуйте сравнить его с нашим <a class="external" target="_blank">html-skeleton-finished.html</a> - файлом (см. также <a class="external" target="_blank">в режиме реального времени</a>).</p>\n</div>\n<p>Если вы посмотрите в файле skeleton.css, вы увидите, как это работает. Например, у Skeleton определены следующие элементы стиля с добавленными к ним классами «три столбца».</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.three.columns {\n  width: 22%;\n}\n</pre></div>\n<p>Весь Skeleton (или любая другая структура сетки) выполняет настройку предопределённых классов, которые вы можете использовать, добавив их в свою разметку. Это точно так же, как если бы вы сами делали расчёт этих процентов.</p>\n<p>Как вы можете видеть, нам нужно написать очень мало CSS при использовании Skeleton. Он касается всех плавающих для нас, когда мы добавляем классы в нашу разметку. Именно эта способность нести ответственность за компоновку над чем-то ещё, что делает использование рамки для сетчатой системы неотразимым выбором!</p>\n<p>Skeleton - это более простая сетка, чем некоторые из структур, с которыми вы можете столкнуться. Сетки в больших рамках, таких как Bootstrap и Foundation, предлагают больше функциональности и дополнительные точки останова для различной ширины экрана. Тем не менее, все они работают аналогичным образом - добавив определённые классы в свою разметку, вы можете контролировать, как элемент выложен с использованием предопределённой сетки.</p></div></section><section aria-labelledby="родные_css_сетки_с_grid_layout"><h2 id="родные_css_сетки_с_grid_layout"><a>Родные CSS Сетки с Grid Layout</a></h2><div class="section-content"><p>В начале этой статьи мы сказали, что CSS ранее не имел реальной системы для создания макетов сетки, но это изменится. Хотя мы ещё не можем использовать встроенную сетевую систему CSS, в следующем году мы увидим поддержку браузера для модуля компоновки сетки CSS (<a>CSS Grid Layout Module</a>).</p>\n<p>В настоящее время вы можете использовать только те методы, которые мы покажем вам в браузерах, которые реализуют макет сетки CSS «за флагом» - это означает, что он в настоящее время реализован, но в экспериментальном состоянии, которое вам нужно включить.</p>\n<p>В Firefox, например, вам нужно перейти к URL-адресу <code>about: config</code>, выполнить поиск по предпочтению <code>layout.css.grid.enabled</code> и дважды щёлкнуть его, чтобы включить CSS-сетки. Вы можете узнать, как использовать его в других браузерах, посетив <a class="external" target="_blank">Grid by Example</a>.</p>\n<p>Мы рассмотрели структуру Скелетной сетки выше - как и другие сторонние решётки и даже ручные сетки, для этого требуется добавить <code>&lt;div&gt;</code> для формирования строк, а затем указать количество столбцов, которые будут охватывать элементы в этих рядах.</p>\n<p>С помощью CSS Grid Layout вы можете полностью указать свою сетку в CSS, не добавляя эти вспомогательные классы в разметку вообще. Давайте рассмотрим наш простой пример и посмотрим, как мы будем создавать тот же макет с помощью CSS Grid Layout.</p></div></section><section aria-labelledby="создание_собственной_сетки"><h3 id="создание_собственной_сетки"><a>Создание собственной сетки</a></h3><div class="section-content"><p>Сначала начните с создания локальной копии файла <a class="external" target="_blank">css-grid.html</a>. Он содержит следующую разметку:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><div class="wrapper">\n  <div class="col">1</div>\n  <div class="col">2</div>\n  <div class="col">3</div>\n  <div class="col">4</div>\n  <div class="col">5</div>\n  <div class="col">6</div>\n  <div class="col">7</div>\n  <div class="col">8</div>\n  <div class="col">9</div>\n  <div class="col">10</div>\n  <div class="col">11</div>\n  <div class="col">12</div>\n  <div class="col">13</div>\n  <div class="col span6">14</div>\n  <div class="col span3">15</div>\n  <div class="col span2">16</div>\n</div>\n</pre></div>\n<p>На этот раз у нас есть родительский <code>&lt;div&gt;</code> с классом обёртки (<code>wrapper</code>), а затем все дочерние элементы просто появляются непосредственно внутри обёртки - никаких элементов строки. Мы добавили класс к элементам, которые должны охватывать более одного столбца.</p>\n<p>Теперь добавьте следующее в элемент <a><code>&lt;style&gt;</code></a>:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.wrapper {\n  width: 90%;\n  max-width: 960px;\n  margin: 0 auto;\n  display: grid;\n  grid-template-columns: repeat(12, 1fr);\n  grid-gap: 20px;\n}\n\n.col {\n  background: rgb(255, 150, 150);\n}\n</pre></div>\n<p>Здесь мы устанавливаем правило <code>.wrapper</code>, поэтому оно составляет 90% от ширины тела, с центром и имеет <a><code>max-width</code></a> 960px.</p>\n<p>Теперь для свойств сетки CSS. Мы можем объявить сетку, используя значение <code>grid</code> свойства <a><code>display</code></a>, установить жёлоб с свойством <a class="only-in-en-us" title="Currently only available in English (US)"><code>grid-gap</code> <small>(en-US)</small></a>, а затем создать сетку из 12 столбцов равной ширине, используя <a><code>grid-template-columns</code></a>, новую функцию <code>repeat()</code> и новую единицу, определённую для макета сетки - блок <code>fr</code>.</p>\n<p>Блок <code>fr</code> представляет собой блок фракции - он описывает долю доступного пространства в контейнере сетки. Если все столбцы равны <code>1fr</code>, каждый из них занимает равное количество места. Это устраняет необходимость вычислять проценты для создания гибкой сетки.</p>\n<p>Создав сетку, правила автоматического размещения сетки немедленно выведут наши коробки в этой сетке, и мы получим гибкую сетку с двенадцатью столбцами.</p>\n<p>\n  \n</p>\n<p>Чтобы создать контейнеры, которые охватывают несколько треков столбцов в сетке, мы можем использовать свойство <a><code>grid-column</code></a>. Чтобы охватить 6 столбцов, например:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.span6 {\n  grid-column: auto / span 6;\n}\n</pre></div>\n<p>И для span 3:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.span3 {\n  grid-column: auto / span 3;\n}\n</pre></div>\n<p>Значение перед косой чертой - это начальная строка - в этом случае мы явно не устанавливаем это и не позволяем браузеру размещать элемент на следующей доступной строке. Затем мы можем установить его на 6, 3 или сколько угодно строк.</p>\n<p>Добавьте нижеследующую часть вашего CSS:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.span2 {\n  grid-column: auto / span 2;\n}\n.span3 {\n  grid-column: auto / span 3;\n}\n.span4 {\n  grid-column: auto / span 4;\n}\n.span5 {\n  grid-column: auto / span 5;\n}\n.span6 {\n  grid-column: auto / span 6;\n}\n.span7 {\n  grid-column: auto / span 7;\n}\n.span8 {\n  grid-column: auto / span 8;\n}\n.span9 {\n  grid-column: auto / span 9;\n}\n.span10 {\n  grid-column: auto / span 10;\n}\n.span11 {\n  grid-column: auto / span 11;\n}\n.span12 {\n  grid-column: auto / span 12;\n}\n</pre></div>\n<p>Попробуйте сохранить и обновить, и вы увидите, что контейнеры охватывают несколько столбцов, если это необходимо. Круто!</p>\n<p>Сетки CSS являются <strong>двумерными</strong>, так как макет растёт и сжимается, элементы остаются выровненными по горизонтали и по вертикали.</p>\n<p>Вы можете проверить это, заменив последние 4 col <code>&lt;div&gt;</code> s следующим:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css"><div class="col">13some<br>content</div>\n<div class="col span6">14this<br>is<br>more<br>content</div>\n<div class="col span3">15this<br>is<br>less</div>\n<div class="col span2">16</div>\n</pre></div>\n<p>Здесь мы намеренно добавили некоторые фрагменты строки (<a><code>&lt;br&gt;</code></a>), чтобы заставить некоторые из столбцов стать выше других. Если вы попытаетесь сохранить и обновить, вы увидите, что столбцы регулируют их высоту, как самый высокий контейнер, поэтому все остаётся аккуратным.</p>\n<p>Окончательный макет выглядит так:</p>\n<p>\n  \n</p>\n<div class="notecard note" id="sect12">\n  <p><strong>Примечание:</strong> Если вам не удаётся заставить этот пример работать, вы можете проверить свой код на нашу <a class="external" target="_blank">законченную версию</a> (также смотрите, как она <a class="external" target="_blank">работает в прямом эфире</a>).</p>\n</div></div></section><section aria-labelledby="другие_полезные_функции_сетки_css"><h3 id="другие_полезные_функции_сетки_css"><a>Другие полезные функции сетки CSS</a></h3><div class="section-content"><p>С сетками CSS нам не нужно толкать вещи вдоль полей, чтобы их компенсировать. Попробуйте внести эти изменения в свой CSS:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.content {\n  grid-column: 2 / 8;\n}\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><div class="col span2 content">16</div>\n</pre></div>\n<p>Контейнер 16 теперь будет охватывать столбцы с 2 по 8, в следующей доступной строке, где он может поместиться.</p>\n<p>Мы можем так же легко группировать строки так же, как и столбцы:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.content {\n  grid-column: 2 / 8;\n  grid-row: 3 / 5;\n}\n</pre></div>\n<p>Контейнер 16 теперь будет охватывать строки с 3 по 5, а также столбцы с 2 по 8.</p>\n<p>Нам также не нужно использовать маржу для фальшивых желобов или явно рассчитать их ширину - сетка CSS имеет эту функциональность, встроенную прямо в свойство <code>grid-gap</code>.</p>\n<p>Мы просто касаемся поверхности того, что возможно с помощью CSS Grid Layout, но главное, что нужно понять в контексте этой статьи, это то, что вам не нужно создавать сетку с сеткой - она одна. Вы можете написать CSS, который помещает элемент непосредственно в предопределённую сетку. Это первый раз, когда это было возможно с помощью CSS и это улучшится, когда поддержка браузера закрепится.</p></div></section><section aria-labelledby="активное_обучение_напишите_свою_собственную_простую_сетку"><h3 id="активное_обучение_напишите_свою_собственную_простую_сетку"><a>Активное обучение: Напишите свою собственную простую сетку</a></h3><div class="section-content"><p>В макете «<a>Введение в CSS</a>» мы включили раздел о <a>CSS-таблицах</a>, который включал простой пример формы (см. Пример <a class="external" target="_blank">css-tables-example.html live</a> и <a class="external" target="_blank">исходный код</a>). Мы хотели бы, чтобы вы взяли копию этого примера и выполните следующие действия:</p>\n<ol>\n  <li>Удалите элементы <code>&lt;div&gt;</code> внутри <code>&lt;form&gt;</code> - вам больше не нужны эти данные, поскольку CSS-сетки могут обрабатывать размещение содержимого по строкам и столбцам для вас.</li>\n  <li>Используйте свойства сетки CSS, чтобы создать макет для вашей формы как можно ближе к оригиналу. Вам нужно будет установить ширину на содержащем элементе и подумать о том, как установить пробелы в столбцах, а также пробелы в строке.</li>\n</ol>\n<div class="notecard note" id="sect13">\n  <p><strong>Примечание:</strong> Сначала выполните это и если вы действительно застряли, вы можете проверить свой код на примере <a class="external" target="_blank">css-tables-as-grid.html</a>. Не обманывайте - сначала попробуйте упражнение!</p>\n</div></div></section><section aria-labelledby="резюме"><h2 id="резюме"><a>Резюме</a></h2><div class="section-content"><p>Прочитав эту статью, вы должны теперь понять, как grid-схемы и grid-структуры работают в CSS. Вы также заглянули в будущее сетки CSS и теперь должны понимать, что используемые нами grid-сетки - это, по сути, стоп-решение, пока у нас не будет широко распространённого способа достижения этого в CSS.</p></div></section><section aria-labelledby="in_this_module"><h2 id="in_this_module"><a>In this module</a></h2><div class="section-content"><ul>\n  <li><a>Introduction to CSS layout</a></li>\n  <li><a>Floats</a></li>\n  <li><a>Positioning</a></li>\n  <li><a>Practical positioning examples</a></li>\n  <li><a>Flexbox</a></li>\n  <li><a aria-current="page">Grids</a></li>\n</ul></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Float',
		
		content:
			'<header><h1>Float</h1></header><div class="section-content">\n<p>Первоначально используемое для "обтекания" картинок текстом, свойство <a><code>float</code></a> стало одним из наиболее часто используемых инструментов для создания макетов из нескольких столбцов на веб-страницах. С появлением flexbox и grid оно снова используется как задумывалось в начале, о чем подробнее в этой статье.</p>\n</div><section aria-labelledby="общие_сведения_о_float"><h2 id="общие_сведения_о_float"><a>Общие сведения о float</a></h2><div class="section-content"><p>Свойство <a><code>float</code></a> вводилось для того, чтобы разработчики могли включать изображение, с обтеканием текста вокруг него слева или справа, как это часто используется в газетах.</p>\n<p>Но разработчики быстро осознали, что можно обтекать всё что угодно, не только изображения, поэтому использование float расширилось, например для вёрстки забавных эффектов таких как <a class="external" target="_blank">drop-caps</a> (буквица).</p>\n<p>Floats очень часто использовались для создания макетов целых веб-страниц, отображающих несколько колонок информации, обтекаемых так, что колонки располагаются друг за другом (поведение по умолчанию предполагает, что колонки должны располагаются друг за другом, в том же порядке в котором они появляются в источнике). Доступны более новые, лучшие методы и поэтому использование floats для этих целей следует рассматривать как <a class="only-in-en-us" title="Currently only available in English (US)">устаревшей техникой <small>(en-US)<small></small></small></a>.</p>\n<p>В этой статье мы сконцентрируемся только на надлежащем использовании floats.</p></div></section><section aria-labelledby="простой_пример_float"><h2 id="простой_пример_float"><a>Простой пример float</a></h2><div class="section-content"><p>Давайте выясним как использовать floats. Мы начнём с очень простого примера включающего обтекание элемента блоком текста. Вы можете следовать за нами создав новый <code>index.html</code> файл на вашем компьютере, заполнив его <a class="external" target="_blank">простым шаблоном HTML</a>, и вставив код ниже в подходящее место. В конце раздела вы можете увидеть живой пример того, как должен выглядеть финальный код.</p>\n<p>Во-первых, мы начнём с некоторого простого HTML — добавьте следующее в body вашего HTML, удалив всё что там было до этого:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><h1>Simple float example</h1>\n\n<div class="box">Float</div>\n\n<p>\n  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam\n  dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus\n  ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus\n  laoreet sit amet.\n</p>\n\n<p>\n  Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet\n  orci vel, viverra egestas ligula. Curabitur vehicula tellus neque, ac ornare\n  ex malesuada et. In vitae convallis lacus. Aliquam erat volutpat. Suspendisse\n  ac imperdiet turpis. Aenean finibus sollicitudin eros pharetra congue. Duis\n  ornare egestas augue ut luctus. Proin blandit quam nec lacus varius commodo et\n  a urna. Ut id ornare felis, eget fermentum sapien.\n</p>\n\n<p>\n  Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada\n  ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed\n  est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus\n  tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies lectus\n  sed lobortis finibus. Vivamus eu urna eget velit cursus viverra quis\n  vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque\n  penatibus et magnis dis parturient montes, nascetur ridiculus mus.\n</p>\n</pre></div>\n<p>А теперь примените следующий CSS для вашего HTML (используя элемент <a><code>&lt;style&gt;</code></a> или <a><code>&lt;link&gt;</code></a> на отдельный файл <code>.css</code> — на ваше усмотрение):</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">body {\n  width: 90%;\n  max-width: 900px;\n  margin: 0 auto;\n  font:\n    0.9em/1.2 Arial,\n    Helvetica,\n    sans-serif;\n}\n\n.box {\n  width: 150px;\n  height: 100px;\n  border-radius: 5px;\n  background-color: rgb(207, 232, 220);\n  padding: 1em;\n}\n</pre></div>\n<p>Если вы сохраните и обновите сейчас, то вы увидите нечто похожее на то, чего ожидаете — блок располагается выше текста, при нормальном потоке. Для того чтобы текст обтекал его вокруг добавьте два свойства к правилу <code>.box</code>:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.box {\n  float: left;\n  margin-right: 15px;\n  width: 150px;\n  height: 100px;\n  border-radius: 5px;\n  background-color: rgb(207, 232, 220);\n  padding: 1em;\n}\n</pre></div>\n<p>Если вы сохраните и обновите сейчас, то вы увидите нечто похожее на следующее:</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Simple float example</h1>\n\n<div class="box">Float</div>\n\n<p>\n  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam\n  dolor, eu lacinia lorem placerat vulputate.\n</p>\n\n<p>\n  Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor\n  imperdiet nunc, at ultricies tellus laoreet sit amet. Sed auctor cursus massa\n  at porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas\n  ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae\n  convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis.\n  Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut\n  luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare\n  felis, eget fermentum sapien.\n</p>\n\n<p>\n  Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada\n  ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed\n  est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus\n  tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies lectus\n  sed lobortis finibus. Vivamus eu urna eget velit cursus viverra quis\n  vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque\n  penatibus et magnis dis parturient montes, nascetur ridiculus mus.\n</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 90%;\n  max-width: 900px;\n  margin: 0 auto;\n  font:\n    0.9em/1.2 Arial,\n    Helvetica,\n    sans-serif;\n}\n\n.box {\n  float: left;\n  margin-right: 15px;\n  width: 150px;\n  height: 150px;\n  border-radius: 5px;\n  background-color: rgb(207, 232, 220);\n  padding: 1em;\n}\n</pre></div><div class="code-example" id="sect1"><div class="example-header" id="sect2"></div></div>\n<p>Итак, давайте подумаем над тем, как работает float — элемент с установленным float (элемент <a><code>&lt;div&gt;</code></a> в данном случае) изымается из нормального потока документа и крепится с левой стороны от родительского контейнера (элемент <a><code>&lt;body&gt;</code></a> в данном случае). Любой контент, который следует ниже за обтекаемым элементом в макете при нормальном потоке теперь будет оборачивать его вокруг, заполняя пространство справа от него начиная на той же высоте что и вершина обтекаемого элемента. Там он остановится.</p>\n<p>Обтекание контента справа имеет точно такой же эффект, но наоборот — обтекаемый элемент будет прилипать справа, а контент будет оборачивать вокруг слева. Попробуйте изменить значение на <code>right</code> и замените <a><code>margin-right</code></a> на <a><code>margin-left</code></a> в последнем наборе правил, чтобы увидеть каков результат.</p>\n<p>В то время как мы можем добавлять margin к обтекаемому элементу чтобы оттолкнуть текст от него, мы не можем добавлять margin к тексту чтобы отодвинуть его от обтекаемого элемента. так происходит потому, что обтекаемые элементы изъяты из нормального потока, а следующие за ним блоки фактически располагаются за обтекаемым элементом. Вы можете продемонстрировать это, внеся некоторые изменения в ваш пример.</p>\n<p>Добавьте класс <code>special</code> к первому параграфу текста, тот который непосредственно следует за обтекаемым блоком, далее добавьте следующие правила в ваш CSS. Они дадут нашему параграфу цвет фона.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.special {\n  background-color: rgb(79, 185, 227);\n  padding: 10px;\n  color: #fff;\n}\n</pre></div>\n<p>Чтобы эффект был лучше виден, измените <code>margin-right</code> обтекаемого объекта на <code>margin</code>, так вы получите пространство вокруг него. Вы сможете увидеть фон параграфа располагающегося прям под обтекаемым блоком, как на примере ниже.</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Simple float example</h1>\n\n<div class="box">Float</div>\n\n<p class="special">\n  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam\n  dolor, eu lacinia lorem placerat vulputate.\n</p>\n\n<p>\n  Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor\n  imperdiet nunc, at ultricies tellus laoreet sit amet. Sed auctor cursus massa\n  at porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas\n  ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae\n  convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis.\n  Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut\n  luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare\n  felis, eget fermentum sapien.\n</p>\n\n<p>\n  Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada\n  ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed\n  est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus\n  tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies lectus\n  sed lobortis finibus. Vivamus eu urna eget velit cursus viverra quis\n  vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque\n  penatibus et magnis dis parturient montes, nascetur ridiculus mus.\n</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 90%;\n  max-width: 900px;\n  margin: 0 auto;\n  font:\n    0.9em/1.2 Arial,\n    Helvetica,\n    sans-serif;\n}\n\n.box {\n  float: left;\n  margin: 15px;\n  width: 150px;\n  height: 150px;\n  border-radius: 5px;\n  background-color: rgb(207, 232, 220);\n  padding: 1em;\n}\n\n.special {\n  background-color: rgb(79, 185, 227);\n  padding: 10px;\n  color: #fff;\n}\n</pre></div><div class="code-example" id="sect3"><div class="example-header" id="sect4"></div></div>\n<p><a>Линейные блоки</a> нашего последующего элемента были сокращены так что текст располагается вокруг обтекаемого объекта, но из-за того, что обтекаемый объект удаляется из нормального потока блок вокруг параграфа все ещё остаётся в полную ширину.</p></div></section><section aria-labelledby="очистка_обтекания"><h2 id="очистка_обтекания"><a>Очистка обтекания</a></h2><div class="section-content"><p>Мы увидели, что обтекаемый объект удалён из нормального потока и что другие элементы будут располагаться за ним, поэтому если мы хотим остановить перемещение следующего элемента нам необходимо очистить его; что достигается при помощи свойства <a><code>clear</code></a>.</p>\n<p>Добавьте класс <code>cleared</code> ко второму параграфу после обтекаемого элемента в ваш HTML из предыдущего примера. Далее добавьте следующий CSS:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.cleared {\n  clear: left;\n}\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Simple float example</h1>\n\n<div class="box">Float</div>\n\n<p class="special">\n  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam\n  dolor, eu lacinia lorem placerat vulputate.\n</p>\n\n<p class="cleared">\n  Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor\n  imperdiet nunc, at ultricies tellus laoreet sit amet. Sed auctor cursus massa\n  at porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas\n  ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae\n  convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis.\n  Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut\n  luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare\n  felis, eget fermentum sapien.\n</p>\n\n<p>\n  Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada\n  ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed\n  est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus\n  tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies lectus\n  sed lobortis finibus. Vivamus eu urna eget velit cursus viverra quis\n  vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque\n  penatibus et magnis dis parturient montes, nascetur ridiculus mus.\n</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 90%;\n  max-width: 900px;\n  margin: 0 auto;\n  font:\n    0.9em/1.2 Arial,\n    Helvetica,\n    sans-serif;\n}\n\n.box {\n  float: left;\n  margin: 15px;\n  width: 150px;\n  height: 150px;\n  border-radius: 5px;\n  background-color: rgb(207, 232, 220);\n  padding: 1em;\n}\n\n.special {\n  background-color: rgb(79, 185, 227);\n  padding: 10px;\n  color: #fff;\n}\n\n.cleared {\n  clear: left;\n}\n</pre></div><div class="code-example" id="sect5"><div class="example-header" id="sect6"></div></div>\n<p>Вы должны увидеть, что следующий параграф очищает float элемента и больше не появляется рядом с ним. Свойство <code>clear</code> принимает следующие значения:</p>\n<ul>\n  <li><code>left</code>: очищает объекты, обтекаемые слева.</li>\n  <li><code>right</code>: очищает объекты, обтекаемые справа.</li>\n  <li><code>both</code>: очищает любые обтекаемые объекты, слева или справа.</li>\n</ul></div></section><section aria-labelledby="очистка_блоков_обёрнутых_вокруг_обтекаемых_элементов"><h2 id="очистка_блоков_обёрнутых_вокруг_обтекаемых_элементов"><a>Очистка блоков обёрнутых вокруг обтекаемых элементов</a></h2><div class="section-content"><p>Вы теперь знаете, как очистить что-либо следующее за обтекаемым элементом, но давайте посмотрим, что происходит если у вас имеется высокий обтекаемый объект и короткий параграф с блоком, оборачивающим оба элемента. Измените ваш документ так чтоб первый параграф и наш обтекаемый блок были обёрнуты в <a><code>&lt;div&gt;</code></a> с классом <code>wrapper</code>.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><div class="wrapper">\n  <div class="box">Float</div>\n\n  <p>\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n    aliquam dolor, eu lacinia lorem placerat vulputate.\n  </p>\n</div>\n</pre></div>\n<p>В вашем CSS добавьте следующее правило для класса <code>.wrapper</code> и обновите страницу:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.wrapper {\n  background-color: rgb(79, 185, 227);\n  padding: 10px;\n  color: #fff;\n}\n</pre></div>\n<p>В добавок удалите класс <code>.cleared</code>:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.cleared {\n  clear: left;\n}\n</pre></div>\n<p>Вы увидите, что, точно так же как и в примере где мы устанавливаем цвет фона для параграфа, цвет фона располагается за обтекаемым объектом.</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Simple float example</h1>\n<div class="wrapper">\n  <div class="box">Float</div>\n\n  <p>\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n    aliquam dolor, eu lacinia lorem placerat vulputate.\n  </p>\n</div>\n\n<p class="cleared">\n  Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor\n  imperdiet nunc, at ultricies tellus laoreet sit amet. Sed auctor cursus massa\n  at porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas\n  ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae\n  convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis.\n  Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut\n  luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare\n  felis, eget fermentum sapien.\n</p>\n\n<p>\n  Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada\n  ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed\n  est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus\n  tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies lectus\n  sed lobortis finibus. Vivamus eu urna eget velit cursus viverra quis\n  vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque\n  penatibus et magnis dis parturient montes, nascetur ridiculus mus.\n</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 90%;\n  max-width: 900px;\n  margin: 0 auto;\n  font:\n    0.9em/1.2 Arial,\n    Helvetica,\n    sans-serif;\n}\n\n.wrapper {\n  background-color: rgb(79, 185, 227);\n  padding: 10px;\n  color: #fff;\n}\n\n.box {\n  float: left;\n  margin: 15px;\n  width: 150px;\n  height: 150px;\n  border-radius: 5px;\n  background-color: rgb(207, 232, 220);\n  padding: 1em;\n}\n</pre></div><div class="code-example" id="sect7"><div class="example-header" id="sect8"></div></div>\n<p>И ещё раз, так происходит потому, что обтекаемый объект изымается из нормального потока. Очистка следующего элемента не помогает с этой проблемой очистки блока, где вы хотите, чтобы нижняя часть блока обернула обтекаемый объект и оборачивающий контент даже если контент короче. Существует три потенциальных способа разобраться с этой проблемой, два из которых работают во всех браузерах, но при этом немного хитры и третий новый способ, который правильно справляется с этой ситуацией.</p></div></section><section aria-labelledby="clearfix_hack"><h3 id="clearfix_hack"><a>Clearfix hack</a></h3><div class="section-content"><p>Традиционно эта ситуация решалась с помощью так называемого «clearfix hack». Это включает вставку некоторого сгенерированного контента после блока, содержащего обтекаемый объект и обёрточный контент, а также настройки для очистки обоих.</p>\n<p>Добавьте следующий CSS в наш пример:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.wrapper::after {\n  content: "";\n  clear: both;\n  display: block;\n}\n</pre></div>\n<p>Теперь перезагрузите страницу и блок должен быть очищенным. По сути, это то же самое, как если бы вы добавили HTML-элемент такой как <code>&lt;div&gt;</code> ниже объекта и установили <code>clear: both</code>.</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Simple float example</h1>\n<div class="wrapper">\n  <div class="box">Float</div>\n\n  <p>\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n    aliquam dolor, eu lacinia lorem placerat vulputate.\n  </p>\n</div>\n<p class="cleared">\n  Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor\n  imperdiet nunc, at ultricies tellus laoreet sit amet. Sed auctor cursus massa\n  at porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas\n  ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae\n  convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis.\n  Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut\n  luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare\n  felis, eget fermentum sapien.\n</p>\n\n<p>\n  Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada\n  ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed\n  est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus\n  tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies lectus\n  sed lobortis finibus. Vivamus eu urna eget velit cursus viverra quis\n  vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque\n  penatibus et magnis dis parturient montes, nascetur ridiculus mus.\n</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 90%;\n  max-width: 900px;\n  margin: 0 auto;\n  font:\n    0.9em/1.2 Arial,\n    Helvetica,\n    sans-serif;\n}\n\n.wrapper {\n  background-color: rgb(79, 185, 227);\n  padding: 10px;\n  color: #fff;\n}\n\n.box {\n  float: left;\n  margin: 15px;\n  width: 150px;\n  height: 150px;\n  border-radius: 5px;\n  background-color: rgb(207, 232, 220);\n  padding: 1em;\n}\n\n.wrapper::after {\n  content: "";\n  clear: both;\n  display: block;\n}\n</pre></div><div class="code-example" id="sect9"><div class="example-header" id="sect10"></div></div></div></section><section aria-labelledby="использование_overflow"><h3 id="использование_overflow"><a>Использование overflow</a></h3><div class="section-content"><p>Альтернативный метод — это задать свойство <a><code>overflow</code></a> для обёртки (wrapper) на значение отличное от <code>visible</code>.</p>\n<p>Удалите clearfix CSS который вы добавляли в предыдущей секции и вместо него добавьте <code>overflow: auto</code> к правилу для обёртки. Блок снова должен быть очищен.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.wrapper {\n  background-color: rgb(79, 185, 227);\n  padding: 10px;\n  color: #fff;\n  overflow: auto;\n}\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Simple float example</h1>\n<div class="wrapper">\n  <div class="box">Float</div>\n\n  <p>\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n    aliquam dolor, eu lacinia lorem placerat vulputate.\n  </p>\n</div>\n<p class="cleared">\n  Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor\n  imperdiet nunc, at ultricies tellus laoreet sit amet. Sed auctor cursus massa\n  at porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas\n  ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae\n  convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis.\n  Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut\n  luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare\n  felis, eget fermentum sapien.\n</p>\n\n<p>\n  Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada\n  ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed\n  est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus\n  tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies lectus\n  sed lobortis finibus. Vivamus eu urna eget velit cursus viverra quis\n  vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque\n  penatibus et magnis dis parturient montes, nascetur ridiculus mus.\n</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 90%;\n  max-width: 900px;\n  margin: 0 auto;\n  font:\n    0.9em/1.2 Arial,\n    Helvetica,\n    sans-serif;\n}\n\n.wrapper {\n  background-color: rgb(79, 185, 227);\n  padding: 10px;\n  color: #fff;\n  overflow: auto;\n}\n\n.box {\n  float: left;\n  margin: 15px;\n  width: 150px;\n  height: 150px;\n  border-radius: 5px;\n  background-color: rgb(207, 232, 220);\n  padding: 1em;\n}\n</pre></div><div class="code-example" id="sect11"><div class="example-header" id="sect12"></div></div>\n<p>Этот пример работает путём создания того, что известно как <strong>Блочный Контекст Форматирования (block formatting context</strong> (BFC)<strong>).</strong> Это как мини макет внутри вашей страницы, внутри которого содержится все, следовательно наш обтекаемый элемент находится внутри BFC и фон располагается за обоими элементами. Обычно это будет срабатывать, однако, в определённых случаях вы можете обнаружить нежелательную полосу прокрутки или обрезанные тени из-за непреднамеренный последствий использования overflow.</p></div></section><section aria-labelledby="display_flow-root"><h3 id="display_flow-root"><a>display: flow-root</a></h3><div class="section-content"><p>Современный способ решения этой проблемы — это использование значения <code>flow-root</code> свойства <code>display</code>. Он существует только для создания BFC без использования хака — не будет возникать непреднамеренных последствий, когда вы используете его. Удалите <code>overflow: auto</code> из вашего правила <code>.wrapper</code> и добавьте <code>display: flow-root</code>. Если предположить, что у вас <a>поддерживающий браузер</a>, блок будет очищаться.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.wrapper {\n  background-color: rgb(79, 185, 227);\n  padding: 10px;\n  color: #fff;\n  display: flow-root;\n}\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Simple float example</h1>\n<div class="wrapper">\n  <div class="box">Float</div>\n\n  <p>\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n    aliquam dolor, eu lacinia lorem placerat vulputate.\n  </p>\n</div>\n<p class="cleared">\n  Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor\n  imperdiet nunc, at ultricies tellus laoreet sit amet. Sed auctor cursus massa\n  at porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas\n  ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae\n  convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis.\n  Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut\n  luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare\n  felis, eget fermentum sapien.\n</p>\n\n<p>\n  Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada\n  ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed\n  est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus\n  tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies lectus\n  sed lobortis finibus. Vivamus eu urna eget velit cursus viverra quis\n  vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque\n  penatibus et magnis dis parturient montes, nascetur ridiculus mus.\n</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 90%;\n  max-width: 900px;\n  margin: 0 auto;\n  font:\n    0.9em/1.2 Arial,\n    Helvetica,\n    sans-serif;\n}\n\n.wrapper {\n  background-color: rgb(79, 185, 227);\n  padding: 10px;\n  color: #fff;\n  display: flow-root;\n}\n\n.box {\n  float: left;\n  margin: 15px;\n  width: 150px;\n  height: 150px;\n  border-radius: 5px;\n  background-color: rgb(207, 232, 220);\n  padding: 1em;\n}\n</pre></div><div class="code-example" id="sect13"><div class="example-header" id="sect14"></div></div></div></section><section aria-labelledby="проверьте_свои_навыки!"><h2 id="проверьте_свои_навыки!"><a>Проверьте свои навыки!</a></h2><div class="section-content"><p>Вы достигли конца этой статьи, но помните ли вы самую важную информацию? Вы можете найти дополнительные тесты, чтобы убедиться, что вы усвоили эту информацию, прежде чем двигаться дальше — см. <a>Проверка ваших навыков: Floats</a>.</p></div></section><section aria-labelledby="заключение"><h2 id="заключение"><a>Заключение</a></h2><div class="section-content"><p>Теперь вы знаете все, что нужно знать о float в современной веб-разработке. См. Статью об <a class="only-in-en-us" title="Currently only available in English (US)">устаревших методах макета <small>(en-US)<small></small></small></a> устаревших методах макета для получения информации о том, как они использовались раньше, что может быть полезно, если вы работаете над старыми проектами.</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Позиционирование',
		
		content:
			'<header><h1>Позиционирование</h1></header><div class="section-content">\n<p>Позиционирование позволяет вам изымать элементы из нормального потока макета документа и заставить их вести себя по-другому; например, располагаться друг на друге или всегда оставаться на одном и том же месте внутри окна просмотра браузера. Эта статья объясняет разные значения <a><code>position</code></a> и как их использовать.</p>\n\n<p>Нам бы хотелось чтобы вы следовали за нами с упражнениями на вашем локальном ПК, если возможно возьмите копию <a class="external" target="_blank"><code>0_basic-flow.html</code></a> из нашего GitHub репозитория (<a class="external" target="_blank">исходный код здесь</a>) и используйте его как отправную точку.</p></div><section aria-labelledby="введение_в_позиционирование"><h2 id="введение_в_позиционирование"><a>Введение в позиционирование</a></h2><div class="section-content"><p>Вся идея позиционирования заключается в том, чтобы позволить нам переопределять поведение базового потока документа, описанного выше, для того чтобы производить интересные эффекты. Что если вам захочется слегка изменить позицию каких-либо блоков внутри макета относительно их позиции в потоке макета по умолчанию? Ваш инструмент - позиционирование. Или если вы хотите создать элемент пользовательского интерфейса, который плавает над другими частями страницы и/или всегда располагается на одном и том же месте в окне браузера не зависимо от того сколько прокручивалась страница? Позиционирование делает возможным работу таких макетов.</p>\n<p>Существует несколько разных типов позиционирования, которые вы можете применить к элементам HTML. Для активации специфического типа позиционирования у элемента, мы используем свойство <a><code>position</code></a>.</p></div></section><section aria-labelledby="статическое_позиционирование"><h3 id="статическое_позиционирование"><a>Статическое позиционирование</a></h3><div class="section-content"><p>Статическое позиционирование — это умолчание, которое получает каждый элемент, что всего лишь значит "поставить элемент в его нормальное положение в потоке макета документа — ничего особенного для рассмотрения".</p>\n<p>Чтобы продемонстрировать это и настроить ваш образец для будущих разделов, сначала добавьте <code>class</code> <code>positioned</code> ко второму <a><code>&lt;p&gt;</code></a> в HTML:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><p class="positioned">...</p>\n</pre></div>\n<p>А теперь добавьте следующее правило в конец вашего CSS:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.positioned {\n  position: static;\n  background: yellow;\n}\n</pre></div>\n<p>И если вы сейчас сохраните и обновите, то вы не увидите никаких изменений, не считая обновлённого цвета фона 2-го параграфа. Это нормально, как мы и говорили ранее, статическое позиционирование является поведением по умолчанию!</p>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> вы можете посмотреть живой пример на данном этапе на <a class="external" target="_blank"><code>1_static-positioning.html</code></a> (<a class="external" target="_blank">см. исходный код</a>).</p>\n</div></div></section><section aria-labelledby="относительное_позиционирование"><h3 id="относительное_позиционирование"><a>Относительное позиционирование</a></h3><div class="section-content"><p>Относительное позиционирование первый тип позиции, который мы рассмотрим. Оно очень похоже на статическое позиционирование, за исключением того что вы можете модифицировать окончательное положение позиционируемого объекта занявшего своё место в макете нормального потока, в том числе заставлять его перекрывать другие элементы на странице. Двигайтесь далее и обновите объявление <code>position</code> в вашем коде:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">position: relative;\n</pre></div>\n<p>Если вы сохраните и обновите на данном этапе, в результате вы совсем не увидите изменений. Так как же вам модифицировать положение? Вам необходимо использовать свойства <a><code>top</code></a>, <a><code>bottom</code></a>, <a class="only-in-en-us" title="Currently only available in English (US)"><code>left</code> <small>(en-US)</small></a>, и <a><code>right</code></a> которые мы объясним в следующем разделе.</p></div></section><section aria-labelledby="введение_в_top_bottom_left_и_right"><h3 id="введение_в_top_bottom_left_и_right"><a>Введение в top, bottom, left, и right</a></h3><div class="section-content"><p><a><code>top</code></a>, <a><code>bottom</code></a>, <a class="only-in-en-us" title="Currently only available in English (US)"><code>left</code> <small>(en-US)</small></a>, и <a><code>right</code></a> используются вместе с <a><code>position</code></a> чтобы указать куда именно перемещать позиционируемый элемент. Для того чтобы попробовать, добавьте следующее объявление к правилу <code>.positioned</code> в вашем CSS:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">top: 30px;\nleft: 30px;\n</pre></div>\n<div class="notecard note" id="sect2">\n  <p><strong>Примечание:</strong> значения этих свойств могут принимать любые <a>единицы</a> которые вы ожидаете по логике: пиксели, мм, rems, %, и т.д.</p>\n</div>\n<p>Если вы сейчас сохраните и обновите, вы получите примерно такой результат:</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Relative positioning</h1>\n\n<p>\n  I am a basic block level element. My adjacent block level elements sit on new\n  lines below me.\n</p>\n\n<p class="positioned">\n  By default we span 100% of the width of our parent element, and we are as tall\n  as our child content. Our total width and height is our content + padding +\n  border width/height.\n</p>\n\n<p>\n  We are separated by our margins. Because of margin collapsing, we are\n  separated by the width of one of our margins, not both.\n</p>\n\n<p>\n  inline elements <span>like this one</span> and <span>this one</span> sit on\n  the same line as one another, and adjacent text nodes, if there is space on\n  the same line. Overflowing inline elements\n  <span>wrap onto a new line if possible — like this one containing text</span>,\n  or just go on to a new line if not, much like this image will do:\n  <img src="long.jpg">\n</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 500px;\n  margin: 0 auto;\n}\n\np {\n  background: aqua;\n  border: 3px solid blue;\n  padding: 10px;\n  margin: 10px;\n}\n\nspan {\n  background: red;\n  border: 1px solid black;\n}\n\n.positioned {\n  position: relative;\n  background: yellow;\n  top: 30px;\n  left: 30px;\n}\n</pre></div><div class="code-example" id="sect3"><div class="example-header" id="sect4"></div></div>\n<p>Круто, правда? Хорошо, вероятно это не то, чего вы ожидали — почему он переместился вниз и вправо, когда мы указали вверх и влево? Как бы нелогично это ни звучало это всего лишь способ того как работает позиционирование — вам надо думать о невидимой силе толкающей указанную сторону позиционируемого блока, перемещая его в противоположную сторону. Так, например, если вы указали <code>top: 30px;</code>, сила толкает блок, заставляя его перемещаться вниз на 30px.</p>\n<div class="notecard note" id="sect5">\n  <p><strong>Примечание:</strong> вы можете посмотреть пример на этом этапе на <a class="external" target="_blank"><code>2_relative-positioning.html</code></a> (<a class="external" target="_blank">см. исходный код</a>).</p>\n</div></div></section><section aria-labelledby="абсолютное_позиционирование"><h3 id="абсолютное_позиционирование"><a>Абсолютное позиционирование</a></h3><div class="section-content"><p>Абсолютное позиционирование даёт совершенно другие результаты. Давайте попробуем изменить объявление позиции в вашем коде как показано ниже:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">position: absolute;\n</pre></div>\n<p>Если вы сохраните и обновите, то вы должны увидеть нечто подобное:</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Absolute positioning</h1>\n\n<p>\n  I am a basic block level element. My adjacent block level elements sit on new\n  lines below me.\n</p>\n\n<p class="positioned">\n  By default we span 100% of the width of our parent element, and we are as tall\n  as our child content. Our total width and height is our content + padding +\n  border width/height.\n</p>\n\n<p>\n  We are separated by our margins. Because of margin collapsing, we are\n  separated by the width of one of our margins, not both.\n</p>\n\n<p>\n  inline elements <span>like this one</span> and <span>this one</span> sit on\n  the same line as one another, and adjacent text nodes, if there is space on\n  the same line. Overflowing inline elements\n  <span>wrap onto a new line if possible — like this one containing text</span>,\n  or just go on to a new line if not, much like this image will do:\n  <img src="long.jpg">\n</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 500px;\n  margin: 0 auto;\n}\n\np {\n  background: aqua;\n  border: 3px solid blue;\n  padding: 10px;\n  margin: 10px;\n}\n\nspan {\n  background: red;\n  border: 1px solid black;\n}\n\n.positioned {\n  position: absolute;\n  background: yellow;\n  top: 30px;\n  left: 30px;\n}\n</pre></div><div class="code-example" id="sect6"><div class="example-header" id="sect7"></div></div>\n<p>В первую очередь обратите внимание на то, что интервал там, где должен быть позиционируемый элемент в потоке документа теперь отсутствует — первый и третий элементы сблизились так будто, он больше не существует! Ну, в каком-то смысле это правда. Абсолютно позиционированный элемент больше не существует в нормальном потоке макета документа. Вместо этого он располагается на своём собственном слое отдельно от всего остального. Это очень полезно: это значит, что мы можем создавать изолированные функции пользовательского интерфейса, которые не влияют на макет других элементов страницы. Например, всплывающие информационные блоки и меню управления; опрокидывающиеся панели; функции пользовательского интерфейса, которые можно перетаскивать в любом месте страницы; и так далее...</p>\n<p>Во-вторых, обратите внимание, что позиция элемента изменилась — это потому, что <a><code>top</code></a>, <a><code>bottom</code></a>, <a class="only-in-en-us" title="Currently only available in English (US)"><code>left</code> <small>(en-US)</small></a>, и <a><code>right</code></a> ведут себя по-другому с абсолютным позиционированием. Вместо того, чтобы позиционировать элемент на основе его относительного положения в обычном потоке макета документа, они определяют расстояние, на котором элемент должен находиться от каждой из сторон содержащего элемента. Поэтому в этом случае мы говорим, что абсолютно позиционированный элемент должен располагаться в 30px от верха "содержащего элемента" и 30px от левого края (В этом случае "содержащий элемент" является <strong>исходным содержащим блоком</strong>. См. раздел ниже для дополнительной информации).</p>\n<div class="notecard note" id="sect8">\n  <p><strong>Примечание:</strong> вы можете использовать <a><code>top</code></a>, <a><code>bottom</code></a>, <a class="only-in-en-us" title="Currently only available in English (US)"><code>left</code> <small>(en-US)</small></a>, и <a><code>right</code></a> для изменения размера элемента если вам надо. Попробуйте установить <code>top: 0; bottom: 0; left: 0; right: 0;</code> и <code>margin: 0;</code> для вашего позиционируемого элемента и посмотрите, что произойдёт! Потом снова все верните...</p>\n</div>\n<div class="notecard note" id="sect9">\n  <p><strong>Примечание:</strong> Да, margin-ы все ещё влияют на позиционируемый элемент. Однако, схлопывания margin не происходит.</p>\n</div>\n<div class="notecard note" id="sect10">\n  <p><strong>Примечание:</strong> вы можете посмотреть пример на этом этапе на <a class="external" target="_blank"><code>3_absolute-positioning.html</code></a> (<a class="external" target="_blank">см. исходный код</a>).</p>\n</div></div></section><section aria-labelledby="контекст_позиционирования"><h3 id="контекст_позиционирования"><a>Контекст позиционирования</a></h3><div class="section-content"><p>Какой элемент является "содержащим" относительно абсолютно позиционируемого элемента? Это очень сильно зависит от свойства позиции предка позиционируемого элемента (см. <a>Определение содержащего блока</a>).</p>\n<p>Если никакие из элементов предков не имеют конкретно заданного свойства позиции, то по умолчанию все элементы предков будут иметь статическую позицию. В результате этого абсолютно позиционируемый элемент будет содержаться в <strong>исходным содержащем блоке</strong>. Исходный содержащий блок имеет размеры области просмотра, а также является блоком, содержащим элемент <a><code>&lt;html&gt;</code></a>. Проще говоря, абсолютно позиционируемый элемент будет отображаться за пределами элемента <a><code>&lt;html&gt;</code></a> и будет расположен относительно исходного окна просмотра.</p>\n<p>Позиционируемый элемент вложен в <a><code>&lt;body&gt;</code></a> в исходном HTML, но в конечном макете он расположен на 30px от верхнего и левого края страницы. Мы можем изменить <strong>контекст</strong> <strong>позиционирования</strong> — относительно какого элемента позиционируется позиционируемый элемент. Это делается путём установки позиционирования на одном из предков элемента — на один из элементов, внутри которого он вложен (вы не можете позиционировать его относительно элемента, внутри которого он НЕ вложен). Чтобы продемонстрировать это, добавьте следующее объявление в правило вашего <code>body</code>:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">position: relative;\n</pre></div>\n<p>Это должно дать следующий результат:</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Positioning context</h1>\n\n<p>\n  I am a basic block level element. My adjacent block level elements sit on new\n  lines below me.\n</p>\n\n<p class="positioned">\n  Now I\'m absolutely positioned relative to the\n  <code>&lt;body&gt;</code> element, not the <code>&lt;html&gt;</code> element!\n</p>\n\n<p>\n  We are separated by our margins. Because of margin collapsing, we are\n  separated by the width of one of our margins, not both.\n</p>\n\n<p>\n  inline elements <span>like this one</span> and <span>this one</span> sit on\n  the same line as one another, and adjacent text nodes, if there is space on\n  the same line. Overflowing inline elements\n  <span>wrap onto a new line if possible — like this one containing text</span>,\n  or just go on to a new line if not, much like this image will do:\n  <img src="long.jpg">\n</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 500px;\n  margin: 0 auto;\n  position: relative;\n}\n\np {\n  background: aqua;\n  border: 3px solid blue;\n  padding: 10px;\n  margin: 10px;\n}\n\nspan {\n  background: red;\n  border: 1px solid black;\n}\n\n.positioned {\n  position: absolute;\n  background: yellow;\n  top: 30px;\n  left: 30px;\n}\n</pre></div><div class="code-example" id="sect11"><div class="example-header" id="sect12"></div></div>\n<p>Позиционируемый элемент теперь располагается относительно элемента <a><code>&lt;body&gt;</code></a>.</p>\n<div class="notecard note" id="sect13">\n  <p><strong>Примечание:</strong> вы можете посмотреть живой пример на этом этапе на <a class="external" target="_blank"><code>4_positioning-context.html</code></a> (<a class="external" target="_blank">см. исходный код</a>).</p>\n</div></div></section><section aria-labelledby="введение_в_z-index"><h3 id="введение_в_z-index"><a>Введение в z-index</a></h3><div class="section-content"><p>Все это абсолютное позиционирование — хорошее развлечение, но кое-что чего мы ещё не рассмотрели — когда элементы начинают перекрываться, что определяет который из элементов будет появляться поверх другого элемента? В примере, который мы видели все это время, у нас имеется только один позиционируемый элемент в контексте позиционирования, и он появляется сверху поскольку позиционируемые элементы "побеждают" не позиционированные элементы. Что же насчёт того, когда мы имеем более одного?</p>\n<p>Попробуйте добавить следующий CSS, чтобы сделать первый параграф так же абсолютно позиционированным:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">p:nth-of-type(1) {\n  position: absolute;\n  background: lime;\n  top: 10px;\n  right: 30px;\n}\n</pre></div>\n<p>На этом этапе вы увидите, что первый параграф окрашенный в лаймовый изъят из потока документа и помещён чуточку выше того места, где он был исходно. А также он расположен под оригинальным параграфом <code>.positioned</code>, где они оба перекрываются. Это потому что параграф <code>.positioned</code> является вторым параграфом по порядку в источнике и позже позиционируемые элементы в порядке источника выигрывают над ранее позиционируемыми элементами в порядке источника.</p>\n<p>Можете ли вы изменить порядок наложения? Да, можете, используя свойство <a><code>z-index</code></a>. "z-index" это ссылка к z-оси. Вы можете вспомнить из предыдущих этапов в этом курсе, где мы обсуждали использование горизонтальных (x-ось) и вертикальных (y-оси) координат веб-страницами для определения позиции для таких вещей, как фоновые изображения и смещение теней. (0,0) находится наверху слева страницы (или элемента) и оси x- и y- направляются направо и вниз страницы (во всяком случае, для языков, направленных слева на право).</p>\n<p>У веб-страниц также имеется z-ось: воображаемая линия, которая направляется от поверхности вашего экрана к вашему лицу (или что ещё вам нравится иметь перед экраном). Значения <a><code>z-index</code></a> влияют на то где позиционируемый элемент располагается на этой оси; положительные значения перемещают их выше по наложению, а отрицательные значения перемещают их ниже по наложению. По умолчанию все позиционируемые элементы имеют <code>z-index</code> <code>auto</code>, что фактически равно 0.</p>\n<p>Для того чтобы изменить порядок наложения, попробуйте объявить для вашего <code>p:nth-of-type(1)</code> правила:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">z-index: 1;\n</pre></div>\n<p>Теперь вы должны видеть законченный пример, с параграфом лаймового цвета сверху:</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>z-index</h1>\n\n<p>\n  I am a basic block level element. My adjacent block level elements sit on new\n  lines below me.\n</p>\n\n<p class="positioned">\n  Now I\'m absolutely positioned relative to the\n  <code>&lt;body&gt;</code> element, not the <code>&lt;html&gt;</code> element!\n</p>\n\n<p>\n  We are separated by our margins. Because of margin collapsing, we are\n  separated by the width of one of our margins, not both.\n</p>\n\n<p>\n  inline elements <span>like this one</span> and <span>this one</span> sit on\n  the same line as one another, and adjacent text nodes, if there is space on\n  the same line. Overflowing inline elements\n  <span>wrap onto a new line if possible — like this one containing text</span>,\n  or just go on to a new line if not, much like this image will do:\n  <img src="long.jpg">\n</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 500px;\n  margin: 0 auto;\n  position: relative;\n}\n\np {\n  background: aqua;\n  border: 3px solid blue;\n  padding: 10px;\n  margin: 10px;\n}\n\nspan {\n  background: red;\n  border: 1px solid black;\n}\n\n.positioned {\n  position: absolute;\n  background: yellow;\n  top: 30px;\n  left: 30px;\n}\n\np:nth-of-type(1) {\n  position: absolute;\n  background: lime;\n  top: 10px;\n  right: 30px;\n  z-index: 1;\n}\n</pre></div><div class="code-example" id="sect14"><div class="example-header" id="sect15"></div></div>\n<p>Обратите внимание что <code>z-index</code> принимает значения индекса только без единиц измерения; вы не можете задавать значения, что хотите, чтобы какой-то элемент был на 23 пикселя выше по z-оси — это так не работает. Более высокие значения будут располагаться над меньшими значениями и от вас зависит какие значения вы используете. Используя 2 и 3, вы получите тот же эффект что и 300 и 40000.</p>\n<div class="notecard note" id="sect16">\n  <p><strong>Примечание:</strong> вы можете посмотреть живой пример на этом этапе на <a class="external" target="_blank"><code>5_z-index.html</code></a> (<a class="external" target="_blank">см. исходный код</a>).</p>\n</div></div></section><section aria-labelledby="фиксированное_позиционированиее"><h3 id="фиксированное_позиционированиее"><a>Фиксированное позиционированиее</a></h3><div class="section-content"><p>А теперь давайте посмотрим на фиксированное позиционирование. Оно работает точно также как и абсолютное позиционирование, одним ключевым отличием: в то время как абсолютное позиционирование фиксирует элемент в месте относительно его ближайшего позиционированного предка (исходный содержащий блок если нет иного), <strong>фиксированное позиционирование</strong> <em>обычно</em> фиксирует элемент в месте относительно видимой части области просмотра, кроме случаев, когда один из его потомков является фиксированным блоком из-за того, что его <a>свойству transform</a> отличается от none. Это значит, что вы можете создать элементы пользовательского интерфейса, которые зафиксированы на месте, как постоянные меню навигации, которые всегда видимы вне зависимости от того сколько прокручивается страница.</p>\n<p>Давайте составим простой пример, чтобы показать, что мы имеем в виду. Во-первых, удалите существующие правила <code>p:nth-of-type(1)</code> и <code>.positioned</code> из вашего CSS.</p>\n<p>А теперь, обновите правило <code>body</code> удалив объявление <code>position: relative;</code> и добавьте фиксированную высоту как тут:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">body {\n  width: 500px;\n  height: 1400px;\n  margin: 0 auto;\n}\n</pre></div>\n<p>Теперь мы собираемся дать элементу <a class="only-in-en-us" title="Currently only available in English (US)"><code>&lt;h1&gt;</code> <small>(en-US)</small></a> <code>position: fixed;</code>, а также заставить его располагаться на верху окна просмотра. Добавьте следующее правило в ваш CSS:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">h1 {\n  position: fixed;\n  top: 0;\n  width: 500px;\n  margin-top: 0;\n  background: white;\n  padding: 10px;\n}\n</pre></div>\n<p><code>top: 0;</code> необходим чтобы приклеить его к верху экрана. мы дали заголовку ту же ширину что и колонкам с контентом и затем даём ему белый фон и немного padding и margin, чтобы контент не был видимым под ним.</p>\n<p>Если вы сохраните и обновите сейчас, вы увидите маленький забавный эффект, при котором заголовок останется неизменным, а содержимое будет прокручиваться вверх и исчезать под ним. Но мы можем улучшить это — в данный момент некоторый контент начинается под заголовком. Это из-за того, что позиционируемый заголовок больше не появляется в потоке документа, поэтому остальное содержимое поднимается наверх. Нам надо сдвинуть все это немного вниз; мы можем сделать это установив немного верхнего margin к первому параграфу. Добавьте его сейчас:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">p:nth-of-type(1) {\n  margin-top: 60px;\n}\n</pre></div>\n<p>Теперь вы должны видеть законченный пример:</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Fixed positioning</h1>\n\n<p>\n  I am a basic block level element. My adjacent block level elements sit on new\n  lines below me.\n</p>\n\n<p class="positioned">I\'m not positioned any more...</p>\n\n<p>\n  We are separated by our margins. Because of margin collapsing, we are\n  separated by the width of one of our margins, not both.\n</p>\n\n<p>\n  inline elements <span>like this one</span> and <span>this one</span> sit on\n  the same line as one another, and adjacent text nodes, if there is space on\n  the same line. Overflowing inline elements\n  <span>wrap onto a new line if possible — like this one containing text</span>,\n  or just go on to a new line if not, much like this image will do:\n  <img src="long.jpg">\n</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 500px;\n  height: 1400px;\n  margin: 0 auto;\n}\n\np {\n  background: aqua;\n  border: 3px solid blue;\n  padding: 10px;\n  margin: 10px;\n}\n\nspan {\n  background: red;\n  border: 1px solid black;\n}\n\nh1 {\n  position: fixed;\n  top: 0px;\n  width: 500px;\n  background: white;\n  padding: 10px;\n}\n\np:nth-of-type(1) {\n  margin-top: 60px;\n}\n</pre></div><div class="code-example" id="sect17"><div class="example-header" id="sect18"></div></div>\n<div class="notecard note" id="sect19">\n  <p><strong>Примечание:</strong> вы можете посмотреть живой пример на этом этапе на <a class="external" target="_blank"><code>6_fixed-positioning.html</code></a> (<a class="external" target="_blank">см. исходный код</a>).</p>\n</div></div></section><section aria-labelledby="position_sticky"><h3 id="position_sticky"><a>position: sticky</a></h3><div class="section-content"><p>Доступно другое значение позиции называемое <code>position: sticky</code>, которое несколько новее чем другие. По сути, это гибрид относительной и фиксированной позиции, который позволяет позиционируемому элементу вести себя как будто он относительно позиционирован, до тех пор пока он не будет прокручен до определённой пороговой точки (например, 10px от вершины окна просмотра), после чего он становится фиксированным. Это можно использовать, например, чтобы заставить панель навигации прокручиваться вместе со страницей до определённой точки, а затем задерживать в верхней части страницы.</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Sticky positioning</h1>\n\n<p>\n  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam\n  dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus\n  ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus\n  laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum,\n  tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus\n  neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat\n  volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros\n  pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec\n  lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.\n</p>\n\n<div class="positioned">Sticky</div>\n\n<p>\n  Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada\n  ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed\n  est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus\n  tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies lectus\n  sed lobortis finibus. Vivamus eu urna eget velit cursus viverra quis\n  vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque\n  penatibus et magnis dis parturient montes, nascetur ridiculus mus.\n</p>\n\n<p>\n  Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam\n  dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus\n  ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus\n  laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum,\n  tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus\n  neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat\n  volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros\n  pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec\n  lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.\n</p>\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 500px;\n  margin: 0 auto;\n}\n\n.positioned {\n  background: rgba(255, 84, 104, 0.3);\n  border: 2px solid rgb(255, 84, 104);\n  padding: 10px;\n  margin: 10px;\n  border-radius: 5px;\n}\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.positioned {\n  position: sticky;\n  top: 30px;\n  left: 30px;\n}\n</pre></div><div class="code-example" id="sect20"><div class="example-header" id="sect21"></div></div>\n<p>Интересное и общее использование <code>position: sticky</code> заключается в создании индексных страниц с прокруткой, где разные заголовки липнут к верху страницы, когда они достигают его. Разметка такого примера может выглядеть так:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><h1>Sticky positioning</h1>\n\n<dl>\n  <dt>A</dt>\n  <dd>Apple</dd>\n  <dd>Ant</dd>\n  <dd>Altimeter</dd>\n  <dd>Airplane</dd>\n  <dt>B</dt>\n  <dd>Bird</dd>\n  <dd>Buzzard</dd>\n  <dd>Bee</dd>\n  <dd>Banana</dd>\n  <dd>Beanstalk</dd>\n  <dt>C</dt>\n  <dd>Calculator</dd>\n  <dd>Cane</dd>\n  <dd>Camera</dd>\n  <dd>Camel</dd>\n  <dt>D</dt>\n  <dd>Duck</dd>\n  <dd>Dime</dd>\n  <dd>Dipstick</dd>\n  <dd>Drone</dd>\n  <dt>E</dt>\n  <dd>Egg</dd>\n  <dd>Elephant</dd>\n  <dd>Egret</dd>\n</dl>\n</pre></div>\n<p>CSS может выглядеть как показано ниже. В нормальном потоке элементы <a><code>&lt;dt&gt;</code></a> будут прокручиваться вместе с контентом. Когда мы добавляем <code>position: sticky</code> к элементу <a><code>&lt;dt&gt;</code></a>, вместе со значением <a><code>top</code></a> 0, поддерживающие браузеры будут приклеивать заголовки к вершине окна просмотра когда они будут достигать той позиции. каждый последующий заголовок будет затем заменять предыдущий при его прокрутке вверх к той позиции.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">dt {\n  background-color: black;\n  color: white;\n  padding: 10px;\n  position: sticky;\n  top: 0;\n  left: 0;\n  margin: 1em 0;\n}\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 500px;\n  height: 1400px;\n  margin: 0 auto;\n}\n\ndt {\n  background-color: black;\n  color: white;\n  padding: 10px;\n  position: sticky;\n  top: 0;\n  left: 0;\n  margin: 1em 0;\n}\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><h1>Sticky positioning</h1>\n\n<dl>\n  <dt>A</dt>\n  <dd>Apple</dd>\n  <dd>Ant</dd>\n  <dd>Altimeter</dd>\n  <dd>Airplane</dd>\n  <dt>B</dt>\n  <dd>Bird</dd>\n  <dd>Buzzard</dd>\n  <dd>Bee</dd>\n  <dd>Banana</dd>\n  <dd>Beanstalk</dd>\n  <dt>C</dt>\n  <dd>Calculator</dd>\n  <dd>Cane</dd>\n  <dd>Camera</dd>\n  <dd>Camel</dd>\n  <dt>D</dt>\n  <dd>Duck</dd>\n  <dd>Dime</dd>\n  <dd>Dipstick</dd>\n  <dd>Drone</dd>\n  <dt>E</dt>\n  <dd>Egg</dd>\n  <dd>Elephant</dd>\n  <dd>Egret</dd>\n</dl>\n</pre></div><div class="code-example" id="sect22"><div class="example-header" id="sect23"></div></div>\n<p>Липкие элементы являются "липкими" относительно ближайшего предка с "прокручивающимся механизмом", который определяется свойством <a>позиции</a> его предка.</p>\n<div class="notecard note" id="sect24">\n  <p><strong>Примечание:</strong> вы можете посмотреть живой пример на этом этапе на <a class="external" target="_blank"><code>7_sticky-positioning.html</code></a> (<a class="external" target="_blank">см. исходный код</a>).</p>\n</div></div></section><section aria-labelledby="проверь_свои_навыки!"><h2 id="проверь_свои_навыки!"><a>Проверь свои навыки!</a></h2><div class="section-content"><p>Вы достигли конца этой статьи, но помните ли вы самую важную информацию? Вы можете найти дальнейшую проверку что вы усвоили эту информацию прежде чем, отправитесь дальше — см. <a>Проверьте свои навыки: Позиционирование</a>.</p></div></section><section aria-labelledby="заключение"><h2 id="заключение"><a>Заключение</a></h2><div class="section-content"><p>Я уверен, что вы повеселились с основами позиционирования; хотя это не является методом, который вы бы использовали для целого макета, всё же как вы видите, существует много задач, подходящих для него.</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Макет с несколькими столбцами',
		
		content:
			'<header><h1>Макет с несколькими столбцами</h1></header><div class="section-content">\n<p>Спецификация макет с несколькими столбцами даёт вам метод вёрстки контента по столбцам, точно также как вы можете видеть в газете. Эта статья объясняет, как использовать эту функцию.</p>\n</div><section aria-labelledby="базовый_пример"><h2 id="базовый_пример"><a>Базовый пример</a></h2><div class="section-content"><p>Сейчас мы будем изучать как использовать макет с несколькими столбцами, часто называемый <em>multicol.</em> Вы можете следовать за нами <a class="external" target="_blank">скачав файл отправной точки multicol</a> и добавлять CSS в соответствующие места. В конце раздела вы можете посмотреть живой пример того, как конечный код должен выглядеть.</p>\n<p>Наша отправная точка содержит немного очень простого HTML; обёртка с классом <code>container</code> внутри которого имеется заголовок и несколько параграфов.</p>\n<p><a><code>&lt;div&gt;</code></a> с классом контейнер станет нашим multicol контейнером. Мы включаем multicol используя одно из двух свойств <a><code>column-count</code></a> или <a class="only-in-en-us" title="Currently only available in English (US)"><code>column-width</code> <small>(en-US)</small></a>. Какое значение вы дадите свойству <code>column-count</code> столько столбцов он и создаст, поэтому если вы добавите следующий CSS в ваши стили и перезагрузите страницу, то получите три столбца:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.container {\n  column-count: 3;\n}\n</pre></div>\n<p>Колонки, которые вы создаёте имеют гибкую ширину — браузер решает какое пространство назначить каждому столбцу.</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 90%;\n  max-width: 900px;\n  margin: 2em auto;\n  font:\n    0.9em/1.2 Arial,\n    Helvetica,\n    sans-serif;\n}\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><div class="container">\n  <h1>Simple multicol example</h1>\n\n  <p>\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n    aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,\n    pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at\n    ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer\n    ligula ipsum, tristique sit amet orci vel, viverra egestas ligula. Curabitur\n    vehicula tellus neque, ac ornare ex malesuada et. In vitae convallis lacus.\n    Aliquam erat volutpat. Suspendisse ac imperdiet turpis. Aenean finibus\n    sollicitudin eros pharetra congue. Duis ornare egestas augue ut luctus.\n    Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare felis,\n    eget fermentum sapien.\n  </p>\n\n  <p>\n    Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada\n    ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed\n    est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus\n    tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies\n    lectus sed lobortis finibus. Vivamus eu urna eget velit cursus viverra quis\n    vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque\n    penatibus et magnis dis parturient montes, nascetur ridiculus mus.\n  </p>\n</div>\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.container {\n  column-count: 3;\n}\n</pre></div><div class="code-example" id="sect1"><div class="example-header" id="sect2"></div></div>\n<p>Измените ваш CSS чтобы использовать следующий <code>column-width</code>:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.container {\n  column-width: 200px;\n}\n</pre></div>\n<p>Теперь браузер будет давать столько столбцов размером, который вы определили, сколько он сможет; любое оставшееся пространство далее делится между существующими столбцами. Это значит, что вы не получите точную ширину, которую вы задали, только если ваш контейнер не делится точно на эту ширину.</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 90%;\n  max-width: 900px;\n  margin: 2em auto;\n  font:\n    0.9em/1.2 Arial,\n    Helvetica,\n    sans-serif;\n}\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><div class="container">\n  <h1>Simple multicol example</h1>\n\n  <p>\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n    aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,\n    pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at\n    ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer\n    ligula ipsum, tristique sit amet orci vel, viverra egestas ligula. Curabitur\n    vehicula tellus neque, ac ornare ex malesuada et. In vitae convallis lacus.\n    Aliquam erat volutpat. Suspendisse ac imperdiet turpis. Aenean finibus\n    sollicitudin eros pharetra congue. Duis ornare egestas augue ut luctus.\n    Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare felis,\n    eget fermentum sapien.\n  </p>\n\n  <p>\n    Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada\n    ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed\n    est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus\n    tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies\n    lectus sed lobortis finibus. Vivamus eu urna eget velit cursus viverra quis\n    vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque\n    penatibus et magnis dis parturient montes, nascetur ridiculus mus.\n  </p>\n</div>\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.container {\n  column-width: 200px;\n}\n</pre></div><div class="code-example" id="sect3"><div class="example-header" id="sect4"></div></div></div></section><section aria-labelledby="стилизация_столбцов"><h2 id="стилизация_столбцов"><a>Стилизация столбцов</a></h2><div class="section-content"><p>Столбцы, созданные при помощи multicol не могут быть стилизованы по одному. Нет способа сделать один столбец больше, чем другие, или изменить фон или цвет текста одного столбца. У вас есть две возможности изменить способ отображения столбцов:</p>\n<ul>\n  <li>Изменение размера отступов между столбцами используя <a><code>column-gap</code></a>.</li>\n  <li>Добавление линейки между столбцами при помощи <a><code>column-rule</code></a>.</li>\n</ul>\n<p>Используя ваш пример выше, измените размер отступа добавлением свойства <code>column-gap</code>:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.container {\n  column-width: 200px;\n  column-gap: 20px;\n}\n</pre></div>\n<p>Вы можете поиграть с разными значениями — свойство принимает любые единицы измерения длины. Теперь добавьте линейку между столбцами при помощи <code>column-rule</code>. Таким же способом как и свойство <a><code>border</code></a> с которым вы сталкивались в предыдущих уроках, <code>column-rule</code> — это короткая запись <a><code>column-rule-color</code></a>, <a><code>column-rule-style</code></a> и <a class="only-in-en-us" title="Currently only available in English (US)"><code>column-rule-width</code> <small>(en-US)</small></a> и принимает те же значения что и <code>border</code>.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.container {\n  column-count: 3;\n  column-gap: 20px;\n  column-rule: 4px dotted rgb(79, 185, 227);\n}\n</pre></div>\n<p>Попробуйте добавить линейки других стилей и цветов.</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 90%;\n  max-width: 900px;\n  margin: 2em auto;\n  font:\n    0.9em/1.2 Arial,\n    Helvetica,\n    sans-serif;\n}\n.container {\n  column-count: 3;\n  column-gap: 20px;\n  column-rule: 4px dotted rgb(79, 185, 227);\n}\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><div class="container">\n  <h1>Simple multicol example</h1>\n\n  <p>\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n    aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,\n    pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at\n    ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer\n    ligula ipsum, tristique sit amet orci vel, viverra egestas ligula. Curabitur\n    vehicula tellus neque, ac ornare ex malesuada et. In vitae convallis lacus.\n    Aliquam erat volutpat. Suspendisse ac imperdiet turpis. Aenean finibus\n    sollicitudin eros pharetra congue. Duis ornare egestas augue ut luctus.\n    Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare felis,\n    eget fermentum sapien.\n  </p>\n\n  <p>\n    Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada\n    ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed\n    est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus\n    tristique elit dolor, sed pretium metus suscipit vel. Mauris ultricies\n    lectus sed lobortis finibus. Vivamus eu urna eget velit cursus viverra quis\n    vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque\n    penatibus et magnis dis parturient montes, nascetur ridiculus mus.\n  </p>\n</div>\n</pre></div><div class="code-example" id="sect5"><div class="example-header" id="sect6"></div></div>\n<p>Следует обратить внимание на то, что линейка не занимает никакой ширины. Она располагается в промежутках, которые вы создали при помощи <code>column-gap</code>. Чтобы придать больше пространства по обе стороны от линейки, вам нужно увеличить размер <code>column-gap</code>.</p></div></section><section aria-labelledby="свойств_column-span"><h2 id="свойств_column-span"><a>Свойств column-span</a></h2><div class="section-content"><p>Вы можете заставить элемент растянуться через все столбцы. В этом случае контент разрывается, когда сталкивается со spanning элементом и продолжается ниже, создавая новый набор блоков столбцов. Чтобы растянуть элемент через все столбцы используйте свойство <a class="only-in-en-us" title="Currently only available in English (US)"><code>column-span</code> <small>(en-US)</small></a> установленное на значение <code>all</code>.</p>\n<div class="notecard note" id="sect7">\n  <p><strong>Примечание:</strong> Обратите внимание что невозможно растянуть элемент через несколько столбцов. Это свойство может иметь либо значение <code>none</code> (по умолчанию) либо <code>all</code>.</p>\n</div>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 90%;\n  max-width: 900px;\n  margin: 2em auto;\n  font:\n    0.9em/1.2 Arial,\n    Helvetica,\n    sans-serif;\n}\n.container {\n  column-count: 3;\n  column-gap: 20px;\n  column-rule: 4px dotted rgb(79, 185, 227);\n}\nh2 {\n  column-span: all;\n  background-color: rgb(79, 185, 227);\n  color: white;\n  padding: 0.5em;\n}\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><div class="container">\n  <h1>Simple multicol example</h1>\n\n  <p> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate.\n  Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula.\n\n  </p><h2>Spanning subhead</h2>\n  Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat volutpat. Suspendisse\n  ac imperdiet turpis. Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit\n  quam nec lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.<p></p>\n\n  <p>Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed est. Nam id risus quis ante semper consectetur eget aliquam lorem. Vivamus tristique\n  elit dolor, sed pretium metus suscipit vel. Mauris ultricies lectus sed lobortis finibus. Vivamus eu urna eget velit\n  cursus viverra quis vestibulum sem. Aliquam tincidunt eget purus in interdum. Cum sociis natoque penatibus et magnis\n  dis parturient montes, nascetur ridiculus mus.</p>\n</div>\n</pre></div><div class="code-example" id="sect8"><div class="example-header" id="sect9"></div></div></div></section><section aria-labelledby="столбцы_и_фрагментация"><h2 id="столбцы_и_фрагментация"><a>Столбцы и фрагментация</a></h2><div class="section-content"><p>Содержимое макета нескольких столбцов является фрагментированным. По сути, он ведёт себя так же, как контент в постраничных медиа — так же, как когда вы печатаете веб-страницы. Когда вы переводите ваш контент в multicol контейнер он фрагментируется на столбцы и контент разбивается чтобы позволить этому произойти.</p>\n<p>Порой это разрывание происходит в местах, мешающих чтению. В живом примере ниже, я использовал multicol чтобы разместить несколько блоков, каждый из которых имеет заголовок и немного текста внутри. Заголовок отделяется от текста, если столбцы разделяются между ними.</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 90%;\n  max-width: 900px;\n  margin: 2em auto;\n  font:\n    0.9em/1.2 Arial,\n    Helvetica,\n    sans-serif;\n}\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><div class="container">\n  <div class="card">\n    <h2>I am the heading</h2>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n      aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,\n      pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc,\n      at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta.\n      Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula.\n    </p>\n  </div>\n\n  <div class="card">\n    <h2>I am the heading</h2>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n      aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,\n      pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc,\n      at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta.\n      Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula.\n    </p>\n  </div>\n\n  <div class="card">\n    <h2>I am the heading</h2>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n      aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,\n      pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc,\n      at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta.\n      Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula.\n    </p>\n  </div>\n  <div class="card">\n    <h2>I am the heading</h2>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n      aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,\n      pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc,\n      at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta.\n      Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula.\n    </p>\n  </div>\n\n  <div class="card">\n    <h2>I am the heading</h2>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n      aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,\n      pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc,\n      at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta.\n      Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula.\n    </p>\n  </div>\n\n  <div class="card">\n    <h2>I am the heading</h2>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n      aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,\n      pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc,\n      at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta.\n      Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula.\n    </p>\n  </div>\n\n  <div class="card">\n    <h2>I am the heading</h2>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n      aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,\n      pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc,\n      at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta.\n      Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula.\n    </p>\n  </div>\n</div>\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.container {\n  column-width: 250px;\n  column-gap: 20px;\n}\n\n.card {\n  background-color: rgb(207, 232, 220);\n  border: 2px solid rgb(79, 185, 227);\n  padding: 10px;\n  margin: 0 0 1em 0;\n}\n</pre></div><div class="code-example" id="sect10"><div class="example-header" id="sect11"></div></div>\n<p>Для того чтобы управлять этим поведением мы можем использовать свойства из спецификации <a class="only-in-en-us" title="Currently only available in English (US)">CSS Фрагментации <small>(en-US)<small></small></small></a>. Эта спецификация даёт нам свойства для управления разрывами контента в multicol и постраничных медиа. Например, добавьте свойство <a class="only-in-en-us" title="Currently only available in English (US)"><code>break-inside</code> <small>(en-US)</small></a> со значением <code>avoid</code> к правилам <code>.card</code>. Это контейнер заголовка и текста и поэтому мы не хотим фрагментировать этот блок.</p>\n<p>В настоящее время также стоит добавлять старое свойство <code>page-break-inside: avoid</code> для лучшей поддержки старых браузеров.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.card {\n  break-inside: avoid;\n  page-break-inside: avoid;\n  background-color: rgb(207, 232, 220);\n  border: 2px solid rgb(79, 185, 227);\n  padding: 10px;\n  margin: 0 0 1em 0;\n}\n</pre></div>\n<p>Перезагрузите страницу и ваши блоки должны остаться в целости.</p>\n<div class="code-example"><pre compile="false" disable="true" language="markup">body {\n  width: 90%;\n  max-width: 900px;\n  margin: 2em auto;\n  font:\n    0.9em/1.2 Arial,\n    Helvetica,\n    sans-serif;\n}\n</pre></div>\n<div class="code-example"><pre compile="false" disable="true" language="markup"><div class="container">\n  <div class="card">\n    <h2>I am the heading</h2>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n      aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,\n      pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc,\n      at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta.\n      Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula.\n    </p>\n  </div>\n\n  <div class="card">\n    <h2>I am the heading</h2>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n      aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,\n      pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc,\n      at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta.\n      Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula.\n    </p>\n  </div>\n\n  <div class="card">\n    <h2>I am the heading</h2>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n      aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,\n      pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc,\n      at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta.\n      Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula.\n    </p>\n  </div>\n  <div class="card">\n    <h2>I am the heading</h2>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n      aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,\n      pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc,\n      at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta.\n      Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula.\n    </p>\n  </div>\n\n  <div class="card">\n    <h2>I am the heading</h2>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n      aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,\n      pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc,\n      at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta.\n      Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula.\n    </p>\n  </div>\n\n  <div class="card">\n    <h2>I am the heading</h2>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n      aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,\n      pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc,\n      at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta.\n      Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula.\n    </p>\n  </div>\n\n  <div class="card">\n    <h2>I am the heading</h2>\n    <p>\n      Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus\n      aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci,\n      pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc,\n      at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta.\n      Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula.\n    </p>\n  </div>\n</div>\n</pre></div>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.container {\n  column-width: 250px;\n  column-gap: 20px;\n}\n\n.card {\n  break-inside: avoid;\n  page-break-inside: avoid;\n  background-color: rgb(207, 232, 220);\n  border: 2px solid rgb(79, 185, 227);\n  padding: 10px;\n  margin: 0 0 1em 0;\n}\n</pre></div><div class="code-example" id="sect12"><div class="example-header" id="sect13"></div></div></div></section><section aria-labelledby="проверь_свои_навыки!"><h2 id="проверь_свои_навыки!"><a>Проверь свои навыки!</a></h2><div class="section-content"><p>Вы достигли конца этой статьи, но помните ли вы самую важную информацию? Вы можете найти дальнейшие тесты для проверки того, что вы усвоили эту информацию прежде чем, отправитесь дальше — см. <a>Поверьте свои навыки: Макет с несколькими столбцами</a>.</p></div></section><section aria-labelledby="заключение"><h2 id="заключение"><a>Заключение</a></h2><div class="section-content"><p>Вы теперь знаете, как использовать базовые функции макета с несколькими столбцами, ещё один инструмент в вашем распоряжении при выборе метода макета для дизайна который вы строите.</p></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Отзывчивый дизайн',
		
		content:
			'<header><h1>Отзывчивый дизайн</h1></header><div class="section-content">\n<p>На заре веб-дизайна страницы создавались для экрана определённого размера. Если у пользователя был экран большего или меньшего размера чем ожидал дизайнер, то результат мог быть от нежелательных полос прокрутки, до слишком длинной строки и плохого использования пространства. Поскольку становились доступны много различных размеров экранов, появилась концепция <em>отзывчивого (адаптивного) веб-дизайна</em> <em>(responsive web design</em> (RWD)) — набор методов, которые позволяют веб-страницам менять свой макет и внешний вид в соответствии с разной шириной экрана, разрешением и т.д. Это та самая, идея которая изменила подход к дизайну веба для множества устройств, и в этой статье мы поможем вам понять основные методы, которые вам необходимо знать, чтобы освоить его.</p>\n</div><section aria-labelledby="исторические_макеты_сайтов"><h2 id="исторические_макеты_сайтов"><a>Исторические макеты сайтов</a></h2><div class="section-content"><p>В какой-то момент истории при разработке веб-сайта у вас было два варианта:</p>\n<ul>\n  <li>Вы могли создать <em>жидкий</em> сайт, который будет растягиваться чтобы заполнить окно браузера</li>\n  <li>или сайт с <em>фиксированной шириной</em>, который будет иметь фиксированный размер в пикселях.</li>\n</ul>\n<p>Эти два подхода, как правило, приводили к тому, что веб-сайт лучше всего выглядел на экране человека, создавшего сайт! Жидкий сайт приводил к раздавленному дизайну на маленьких экранах (как видно ниже) и не читаемо длинным строкам на больших.</p>\n<p>\n  \n</p>\n<div class="notecard note" id="sect1">\n  <p><strong>Примечание:</strong> Посмотрите этот простой жидкий макет: <a class="external" target="_blank">пример</a>, <a class="external" target="_blank">исходный код</a>. При просмотре примера, растягивайте и сжимайте окно браузера чтобы увидеть, как это выглядит при разных размерах.</p>\n</div>\n<p>Сайт с фиксированной шириной рисковал иметь горизонтальную полосу прокрутки на экранах меньших чем ширина сайта (как видно ниже) и много белого пространства на краях дизайна на больших экранах.</p>\n<p>\n  \n</p>\n<div class="notecard note" id="sect2">\n  <p><strong>Примечание:</strong> Посмотрите этот простой макет с фиксированной шириной: <a class="external" target="_blank">пример</a>, <a class="external" target="_blank">исходный код</a>. Снова изучите результат по мере изменения размера окна браузера.</p>\n</div>\n<div class="notecard note" id="sect3">\n  <p><strong>Примечание:</strong> Скриншоты выше сделаны используя <a class="external" target="_blank">Responsive Design Mode</a> в Firefox DevTools.</p>\n</div>\n<p>Когда мобильный веб стал становиться реальностью с первыми функциональными телефонами, компании желающие охватить мобильники начали создавать в основном специальные мобильные версии своих сайтов, с различными URL (часто что-то наподобие <em>m.example.com</em> или <em>example.mobi</em>). Это означало, что необходимо было разрабатывать и поддерживать в актуальном состоянии две отдельные версии сайта.</p>\n<p>Кроме того, эти мобильные сайты часто предлагали очень урезанный вариант. Поскольку мобильные гаджеты стали мощнее и способными отображать целые веб-сайты, пользователей мобильных устройств раздражало, что они обнаруживали себя запертыми в мобильной версии сайта, неспособные получить доступ к информации, которая, как они знали, есть в полнофункциональной версии сайта.</p></div></section><section aria-labelledby="гибкий_макет_до_отзывчивого_дизайна"><h2 id="гибкий_макет_до_отзывчивого_дизайна"><a>Гибкий макет до отзывчивого дизайна</a></h2><div class="section-content"><p>Было разработано несколько подходов чтобы попытаться разрешить недостатки построения веб-сайтов жидким методом или методом с фиксированной шириной. В 2004 году Камерон Адамс написал пост <a class="external" target="_blank">Resolution dependent layout</a>, описывающий метод создания дизайна который мог бы адаптироваться к разным разрешениям экрана. Этот подход требовал, чтобы JavaScript узнавал разрешение экрана и загружал корректный CSS.</p>\n<p>Зои Миккели Гилленвотер сыграла важную роль в свой работе описав и формализовав различные способы посредствам которых могут быть созданы гибкие сайты, пытаясь найти золотую середину между заполнением экрана или полностью фиксированным размером.</p></div></section><section aria-labelledby="отзывчивый_дизайн"><h2 id="отзывчивый_дизайн"><a>Отзывчивый дизайн</a></h2><div class="section-content"><p>Термин адаптивный дизайн был <a class="external" target="_blank">Придуман Итаном Маркоттом в 2010 году</a> и описывал использование трёх методов в сочетании.</p>\n<ol>\n  <li>Первой была идея жидких сеток, нечто что уже исследовала Гилленвотер, что можно прочитать в статье Маркотта - <a class="external" target="_blank">Fluid Grids</a> (опубликовано в 2009 в A List Apart).</li>\n  <li>Вторым методом была идея <a class="external" target="_blank">жидких изображений</a>. Используя очень простой метод настройки свойства <code>max-width</code> на <code>100%</code>, изображения будут становиться меньше если содержащий столбец становится уже чем изначальный размер изображения, но никогда не становится больше. Это позволяет изображению уменьшаться чтобы соответствовать столбцу гибких размеров, а не перекрываться с ним, но не расти и становиться пиксельным если столбец становится шире изображения.</li>\n  <li>Третьим ключевым компонентом были <a>медиавыражения</a>. Медиавыражения позволяют переключать тип макета применяя только CSS то, что Камерон Адамс исследовал, используя JavaScript. Вместо того чтобы иметь один макет для всех размеров экранов, макет мог изменяться. Боковые панели можно перемещать для маленьких экранов, либо отображать альтернативную навигацию.</li>\n</ol>\n<p>Очень важно понять, что <strong>адаптивный веб-дизайн</strong> — <strong>это не отдельная технология</strong>, это термин используемый, чтобы описать подход к веб-дизайну или набор лучших практик, используемых для создания макета, который может реагировать на используемое устройство для просмотра контента. В первоначальном исследовании Маркотта это означало гибкие сетки (с использованием floats) и медиавыражения, однако почти за 10 лет, прошедших с момента написания этой статьи, адаптивная работа стала стандартом по умолчанию. Современные методы макета CSS отзывчивы по своей сути, и у нас есть новые штучки, встроенные в веб-платформу для того, чтобы делать дизайн отзывчивых сайтов проще.</p>\n<p>Остальная часть этой статьи укажет вам на различные функции веб-платформы, которые вы, возможно, захотите использовать при создании адаптивного сайта.</p></div></section><section aria-labelledby="медиавыражения"><h2 id="медиавыражения"><a>Медиавыражения</a></h2><div class="section-content"><p>Отзывчивый дизайн появился благодаря медиавыражениям (media queries). Спецификация Media Queries Level 3 стала Рекомендованным Кандидатом в 2009 году, что означает, что она была признана готовой к реализации в браузерах. Медиавыражения позволяют нам проводить серию тестов (например, является ли экран пользователя больше, чем определённая ширина или разрешение) и выборочно применять CSS к стилю страницы соответственно с нуждами пользователя.</p>\n<p>Например, следующее медиавыражение проверяет отображается ли текущая страница как экранная медиа (а не как печатный документ) и имеет ли область просмотра ширину как минимум 800 px. CSS будет применяться к селектору <code>.container</code> только если эти две вещи истины.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">@media screen and (min-width: 800px) {\n  .container {\n    margin: 1em 2em;\n  }\n}\n</pre></div>\n<p>Вы можете добавлять несколько медиавыражений в пределах одной таблицы стилей, подстраивая весь ваш макет или его части так, чтобы наилучшим образом соответствовать разным размерам экрана. Точки, в которых применяются медиавыражения и меняется макет, известны как <em>контрольные точки.</em></p>\n<p>Общим подходом при использовании медиавыражений является создание простого одноколоночного макета для устройств с узкими экранами (например, мобильные телефоны), затем проверка для больших экранов и применение макета с несколькими столбцам, когда вы знаете, что у вас достаточно ширины экрана, чтобы уместить все. Такой подход часто называют <strong>mobile first</strong> дизайном.</p>\n<p>Узнать больше о <a>медиавыражениях</a> можно в документации MDN.</p></div></section><section aria-labelledby="гибкие_сетки"><h2 id="гибкие_сетки"><a>Гибкие сетки</a></h2><div class="section-content"><p>Отзывчивые сайты не просто меняют свой макет между контрольными точками, они построены на гибких сетках. Гибкая сетка подразумевает что вам не надо заботиться о каждом возможном существующем размере устройства и строить для них идеальный макет в пикселях. Такой подход был бы невозможен имея широкое множество существующих устройств разных размеров, как и факт того, что даже на ПК люди не всегда используют браузер с развёрнутым до максимума окном.</p>\n<p>Используя гибкую сетку, вам всего лишь надо добавить контрольную точку и изменить дизайн в точке, когда ваш контент начинает выглядеть плохо. Например, если длина строки становится нечитаемо длинной при увеличении размера экрана, или блок становится сдавленным с двумя словами в каждой строке при сужении экрана.</p>\n<p>В первые дни отзывчивого дизайна, нашим единственным вариантом выполнения было использование <a>floats</a>. Гибкий обтекаемый макет достигался путём присвоения каждому элементу процентной ширины удостоверившись, что итоговые значения в макете не превышают 100%. В своей оригинальной статье о плавучих сетках Маркотт подробно описал формулу для преобразования макета, созданного с использованием пикселей, в проценты.</p>\n<pre compile="false" disable="true" language="css">target / context = result\n</pre>\n<p>Например, если размер нашего целевого столбца — 60 пикселей, а контекст (или контейнер) в котором он находится — 960 пикселей, то мы делим 60 на 960 чтобы получить значение которое мы можем использовать в нашем CSS, после переноса десятичной точки вправо на 2 цифры.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup">.col {\n  width: 6.25%; /* 60 / 960 = 0.0625 */\n}\n</pre></div>\n<p>Этот подход сегодня можно найти во многих местах в Интернете и он задокументирован здесь в разделе макетов в нашей статье <a class="only-in-en-us" title="Currently only available in English (US)">Устаревших методов макетов <small>(en-US)<small></small></small></a>. В вашей работе вероятно, что вы столкнётесь с веб-сайтами, использующими этот подход, поэтому стоит понимать его, даже если вы не будете строить современные сайты используя гибкие сетки основанные на float.</p>\n<p>Следующий пример демонстрирует простой отзывчивый дизайн, с использованием медиавыражений и гибких сеток. На узких экранах макет отображает блоки, расположенные друг над другом:</p>\n<p>\n  \n</p>\n<p>На более широких экранах они перемещаются в два столбца:</p>\n<p>\n  \n</p>\n<div class="notecard note" id="sect4">\n  <p><strong>Примечание:</strong> вы можете найти <a class="external" target="_blank">живой пример</a> и <a class="external" target="_blank">исходный код</a> этого примера на GitHub.</p>\n</div></div></section><section aria-labelledby="современные_технологии_макетов"><h2 id="современные_технологии_макетов"><a>Современные технологии макетов</a></h2><div class="section-content"><p>Современные методы макетов такие как <a>Макет с несколькими столбцами</a>, <a>Flexbox</a>, и <a>Grid</a> являются отзывчивыми по умолчанию. Они все предполагают, что вы пытаетесь создать гибкую сетку и дают вам более лёгкий способ сделать так.</p></div></section><section aria-labelledby="multicol"><h3 id="multicol"><a>Multicol</a></h3><div class="section-content"><p>Самый старый из этих методов — это multicol, когда вы задаёте <code>column-count</code>, это отражает то на сколько столбцов вы хотите разбить ваш контент. Далее браузер рассчитывает их размер, размер, который изменится согласно размеру экрана.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.container {\n  column-count: 3;\n}\n</pre></div>\n<p>Если вместо этого вы зададите <code>column-width</code>, то вы определите <em>минимальную</em> ширину. Браузер создаст столько столбцов той ширины, сколько будет комфортно умещаться в контейнер, а затем поделит оставшееся пространство между всеми столбцами. Поэтому число столбцов будет меняться согласно тому сколько имеется места.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.container {\n  column-width: 10em;\n}\n</pre></div></div></section><section aria-labelledby="flexbox"><h3 id="flexbox"><a>Flexbox</a></h3><div class="section-content"><p>В Flexbox, в качестве исходного поведения, flex элементы будут сжиматься и распределять пространство между элементами в соответствии с пространством в их контейнере. Изменяя значения <code>flex-grow</code> и <code>flex-shrink</code> вы можете указать, как вы хотите, чтобы предметы вели себя когда они сталкиваются с большим или меньшим пространством вокруг себя.</p>\n<p>В примере ниже каждый flex элемент будет принимать равное количество пространства во flex контейнере используя запись <code>flex: 1</code> как описано в главе <a>Flexbox: Гибкое изменение размеров flex элементов</a>.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.container {\n  display: flex;\n}\n\n.item {\n  flex: 1;\n}\n</pre></div>\n<div class="notecard note" id="sect5">\n  <p><strong>Примечание:</strong> В качестве примера мы перестроили простой отзывчивый макет выше, в этот раз используя flexbox. Вы видите что нас больше не надо использовать странные процентные значения для подсчёта размера столбцов: <a class="external" target="_blank">пример</a>, <a class="external" target="_blank">исходный код</a>.</p>\n</div></div></section><section aria-labelledby="css_grid"><h3 id="css_grid"><a>CSS grid</a></h3><div class="section-content"><p>В макете CSS Grid единицы измерения <code>fr</code> позволяют распределять доступное пространство между дорожками сетки. Следующий пример создаёт grid контейнер с тремя дорожками размером <code>1fr</code>. Это создаст три вертикальные дорожки, каждая занимающая одну часть свободного пространства в контейнере. Вы можете узнать больше об этом подходе к созданию сетки в теме Изучение Макета Grid в разделе <a>Гибкие grids с единицами fr</a>.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">.container {\n  display: grid;\n  grid-template-columns: 1fr 1fr 1fr;\n}\n</pre></div>\n<div class="notecard note" id="sect6">\n  <p><strong>Примечание:</strong> версия grid макета ещё проще, поскольку мы можем определить столбцы в .wrapper: <a class="external" target="_blank">пример</a>, <a class="external" target="_blank">исходный код</a>.</p>\n</div></div></section><section aria-labelledby="отзывчивые_изображения"><h2 id="отзывчивые_изображения"><a>Отзывчивые изображения</a></h2><div class="section-content"><p>Самый простой подход к отзывчивым изображениям был описан в ранних статьях Маркотта по отзывчивому дизайну. По сути, вы берёте изображение максимального размера, которое могло понадобиться, и уменьшаете его. Этот подход до сих пор используется и в большинстве таблиц стилей вы найдёте следующий CSS:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">img {\n  max-width: 100%;\n}\n</pre></div>\n<p>Существуют очевидные недостатки к этому подходу. Изображение может быть изображено намного меньше своего исходного размера, что является пустой тратой пропускной способности — пользователь мобильных может загружать изображение, в несколько раз превышающее размер того, что он фактически видит в окне браузера. Кроме того, вам может не понадобиться такое же соотношение сторон изображения на мобильном устройстве, как на компьютере. Либо, учитывая меньший размер изображения на мобильном телефоне, вы можете захотеть показать совсем другое изображение, которое легче понять на маленьком экране. Такие вещи можно достичь, просто уменьшая изображение.</p>\n<p>Отзывчивые изображения, используя элемент <a><code>&lt;picture&gt;</code></a> и атрибуты <code>srcset</code> и <code>sizes</code> элемента <a><code>&lt;img&gt;</code></a> оба решают эти проблемы. Вы можете указать несколько размеров вместе с «подсказками» (метаданные, описывающие размер экрана и разрешение, для которых изображение лучше всего подходит), и браузер выберет наиболее подходящее изображение для каждого устройства, гарантируя, что пользователь загрузит изображение подходящего размера для устройства, которое они используют.</p>\n<p>Вы также можете напрямую использовать изображения разных размеров, обеспечивая разное кадрирование или совершенно другое изображение для разных размеров экрана.</p>\n<p>Вы можете найти подробное <a>руководство по отзывчивым изображениям в разделе изучения HTML</a> на MDN.</p></div></section><section aria-labelledby="отзывчивая_типографика"><h2 id="отзывчивая_типографика"><a>Отзывчивая типографика</a></h2><div class="section-content"><p>Элементом отзывчивого дизайна, не освещённого ранее в работе, была идея отзывчивой типографики. Главным образом, она описывает изменение размеров шрифта в зависимости от ширины экрана при помощи медиавыражений.</p>\n<p>В этом примере, мы хотим задать нашему заголовку первого уровня <code>4rem</code>, что значит, что он будет в четыре раза больше нашего базового размера шрифта. Это очень большой заголовок! Мы хотим этот гигантский заголовок только на экранах больших размеров, поэтому мы сначала создаём меньший заголовок, а затем используем медиавыржаение, чтобы переписать его для больших экранов, если мы знаем, что у пользователя есть экран размером как минимум <code>1200px</code>.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">html {\n  font-size: 1em;\n}\n\nh1 {\n  font-size: 2rem;\n}\n\n@media (min-width: 1200px) {\n  h1 {\n    font-size: 4rem;\n  }\n}\n</pre></div>\n<p>Мы отредактировали наш приведённый выше пример отзывчивой сетки grid, чтобы он также включал в себя адаптивный тип, используя описанный метод. Вы можете видеть, как заголовок меняет размеры, когда макет переходит в версию с двумя столбцами.</p>\n<p>В мобильных версиях заголовок меньше:</p>\n<p>\n  \n</p>\n<p>На компьютерах, однако, мы видим больший размер заголовка:</p>\n<p>\n  \n</p>\n<div class="notecard note" id="sect7">\n  <p><strong>Примечание:</strong> смотрите этот пример в действии: <a class="external" target="_blank">пример</a>, <a class="external" target="_blank">исходный код</a>.</p>\n</div>\n<p>Такой подход к типографике показывает, что вам не нужно ограничиваться в использовании медиавыражений только изменением макета страницы. Они могут быть использоваться для настройки любого элемента, чтобы сделать его более удобным или привлекательным при других размерах экрана.</p></div></section><section aria-labelledby="using_viewport_units_for_responsive_typography"><h3 id="using_viewport_units_for_responsive_typography"><a>Using viewport units for responsive typography</a></h3><div class="section-content"><p>An interesting approach is to use the viewport unit <code>vw</code> to enable responsive typography. <code>1vw</code> is equal to one percent of the viewport width, meaning that if you set your font size using <code>vw</code>, it will always relate to the size of the viewport.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">h1 {\n  font-size: 6vw;\n}\n</pre></div>\n<p>The problem with doing the above is that the user loses the ability to zoom any text set using the <code>vw</code> unit, as that text is always related to the size of the viewport. <strong>Therefore you should never set text using viewport units alone</strong>.</p>\n<p>There is a solution, and it involves using <a><code>calc()</code></a>. If you add the <code>vw</code> unit to a value set using a fixed size such as <code>em</code>s or <code>rem</code>s then the text will still be zoomable. Essentially, the <code>vw</code> unit adds on top of that zoomed value:</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="css">h1 {\n  font-size: calc(1.5rem + 3vw);\n}\n</pre></div>\n<p>This means that we only need to specify the font size for the heading once, rather than set it up for mobile and redefine it in the media queries. The font then gradually increases as you increase the size of the viewport.</p>\n<div class="notecard note" id="sect8">\n  <p><strong>Примечание:</strong> See an example of this in action: <a class="external" target="_blank">example</a>, <a class="external" target="_blank">source code</a>.</p>\n</div></div></section><section aria-labelledby="the_viewport_meta_tag"><h2 id="the_viewport_meta_tag"><a>The viewport meta tag</a></h2><div class="section-content"><p>If you look at the HTML source of a responsive page, you will usually see the following <a><code>&lt;meta&gt;</code></a> tag in the <code>&lt;head&gt;</code> of the document.</p>\n<div class="code-example"><div class="example-header"></div><pre compile="false" disable="true" language="markup"><meta name="viewport" content="width=device-width,initial-scale=1">\n</pre></div>\n<p>This meta tag tells mobile browsers that they should set the width of the viewport to the device width, and scale the document to 100% of its intended size, which shows the document at the mobile-optimized size that you intended.</p>\n<p>Why is this needed? Because mobile browsers tend to lie about their viewport width.</p>\n<p>This meta tag exists because when the original iPhone launched and people started to view websites on a small phone screen, most sites were not mobile optimized. The mobile browser would, therefore, set the viewport width to 960 pixels, render the page at that width, and show the result as a zoomed-out version of the desktop layout. Other mobile browsers (e.g. on Google Android) did the same thing. Users could zoom in and pan around the website to view the bits they were interested in, but it looked bad. You will still see this today if you have the misfortune to come across a site that does not have a responsive design.</p>\n<p>The trouble is that your responsive design with breakpoints and media queries won\'t work as intended on mobile browsers. If you\'ve got a narrow screen layout that kicks in at 480px viewport width or less, and the viewport is set at 960px, you\'ll never see your narrow screen layout on mobile. By setting <code>width=device-width</code> you are overriding Apple\'s default <code>width=960px</code> with the actual width of the device, so your media queries will work as intended.</p>\n<p><strong>So you should <em>always</em> include the above line of HTML in the head of your documents.</strong></p>\n<p>There are other settings you can use with the viewport meta tag, however in general the above line is what you will want to use.</p>\n<ul>\n  <li><code>initial-scale</code>: Sets the initial zoom of the page, which we set to 1.</li>\n  <li><code>height</code>: Sets a specific height for the viewport.</li>\n  <li><code>minimum-scale</code>: Sets the minimum zoom level.</li>\n  <li><code>maximum-scale</code>: Sets the maximum zoom level.</li>\n  <li><code>user-scalable</code>: Prevents zooming if set to <code>no</code>.</li>\n</ul>\n<p>You should avoid using <code>minimum-scale</code>, <code>maximum-scale</code>, and in particular setting <code>user-scalable</code> to <code>no</code>. Users should be allowed to zoom as much or as little as they need to; preventing this causes accessibility problems.</p></div></section><section aria-labelledby="summary"><h2 id="summary"><a>Summary</a></h2><div class="section-content"><p>Responsive design refers to a site or application design that responds to the environment in which it is viewed. It encompasses a number of CSS and HTML features and techniques and is now essentially just how we build websites by default. Consider the sites that you visit on your phone — it is probably fairly unusual to come across a site that is the desktop version scaled down, or where you need to scroll sideways to find things. This is because the web has moved to this approach of designing responsively.</p>\n<p>It has also become much easier to achieve responsive designs with the help of the layout methods you have learned in these lessons. If you are new to web development today you have many more tools at your disposal than in the early days of responsive design. It is therefore worth checking the age of any materials you are referencing. While the historical articles are still useful, modern use of CSS and HTML makes it far easier to create elegant and useful designs, no matter what device your visitor views the site with.</p></div></section><section aria-labelledby="in_this_module"><h2 id="in_this_module"><a>In this module</a></h2><div class="section-content"><ul>\n  <li><a>Introduction to CSS layout</a></li>\n  <li><a>Normal flow</a></li>\n  <li><a>Flexbox</a></li>\n  <li><a>Grid</a></li>\n  <li><a>Floats</a></li>\n  <li><a>Positioning</a></li>\n  <li><a>Multiple-column layout</a></li>\n  <li><a aria-current="page">Responsive design</a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)">Beginner\'s guide to media queries <small>(en-US)<small></small></small></a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)">Legacy layout methods <small>(en-US)<small></small></small></a></li>\n  <li><a class="only-in-en-us" title="Currently only available in English (US)">Supporting older browsers <small>(en-US)<small></small></small></a></li>\n  <li><a>Fundamental layout comprehension assessment</a></li>\n</ul></div></section>',
		works: [],
	},
	{
		book: 'CSS',
		title: 'Фундаментальное понимание раскладки',
		
		content:
			'<header><h1>Фундаментальное понимание раскладки</h1></header><div class="section-content"><p>Если вы проработали этот модуль, то уже имеете базовое представление о том, что вам нужно знать, чтобы создавать современную CSS раскладку и работать с более старым CSS. Это задание проверит некоторые из ваших знаний путём разработки раскладки для простой веб-страницы, используя различные техники.</p>\n</div><section aria-labelledby="резюме_проекта"><h2 id="резюме_проекта"><a>Резюме проекта</a></h2><div class="section-content"><p>Вам предоставили некоторый html, базовый css и изображения — ваша задача, создать раскладку для дизайна, который должен выглядеть как на изображении ниже.</p>\n<p>\n  \n</p></div></section><section aria-labelledby="базовые_настройки"><h3 id="базовые_настройки"><a>Базовые настройки</a></h3><div class="section-content"><p>Вы можете скачать HTML, CSS, и набор из шести изображений <a class="external" target="_blank">тут</a>.</p>\n<p>Сохраните HTML документ и css стили внутри директории на вашем компьютере и добавьте изображения внутрь папки с именем <code>images</code>. Открыв <code>index.html</code> файл в браузере, вы должны получить страницу с базовой стилизацией, но без раскладки, что должно выглядеть как на изображении ниже.</p>\n<p>Эта отправная точка и всё содержимое отображается браузером в нормальном потоке.</p>\n<p>\n  \n</p></div></section><section aria-labelledby="ваши_задачи"><h3 id="ваши_задачи"><a>Ваши задачи</a></h3><div class="section-content"><p>Теперь вам нужно реализовать раскладку. Задачи, которые вам необходимо выполнить:</p>\n<ol>\n  <li>Отобразить пункты навигации в строку, с одинаковым количеством пространства между элементами.</li>\n  <li>Панель навигации должна прокручиваться вместе с содержимым страницы и закрепляться вверху видимой области документа в рамках экрана.</li>\n  <li>Изображение, которое находится внутри статьи, должно обтекаться текстом вокруг него.</li>\n  <li><a><code>&lt;article&gt;</code></a> и <a><code>&lt;aside&gt;</code></a> элементы должны отображаться как двухколоночная раскладка. Колонки должны иметь гибкий размер, если окно браузера уменьшится, колонки должны стать более узкими.</li>\n  <li>Фотографии должны отображаться как двухколоночная сетка с отступом в 1px между изображениями.</li>\n</ol>\n<p>Вам нет необходимости изменять HTML для создания этой раскладки и техник, которые вы должны использовать:</p>\n<ul>\n  <li>Позиционирование</li>\n  <li>Раскладка на Float</li>\n  <li>Раскладка на Flexbox</li>\n  <li>Раскладка на CSS Grid</li>\n</ul>\n<p>Есть множество способов, как выполнить некоторые из этих задач и часто не существует одного правильного или неправильного способа это сделать. Попробуйте несколько разных способов и увидите, какой работает лучше. Делайте заметки о ваших экспериментах и вы всегда сможете обсудить ваш способ в отдельной дискуссии для этого задания или на <a>#mdn</a> IRC канале.</p></div></section><section aria-labelledby="оценка_работы"><h2 id="оценка_работы"><a>Оценка работы</a></h2><div class="section-content"><p>Если вы проходите эту аттестацию как часть организованного курса, вы должны быть в состоянии дать свою работу вашему учителю/наставнику для оценки. Если вы занимаетесь самообучением, тогда вы легко можете получить руководство по оценке работы, задавая вопросы в <a class="external" target="_blank">отдельной дискуссии для этого задания</a> или на <a>#mdn</a> IRC канале в <a class="external" target="_blank">Mozilla IRC</a>. Сначала попробуйте выполнить упражнение — нет никаких причин для жульничества!</p></div></section>',
		works: [],
	},
];
